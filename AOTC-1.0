import openai

from openai import OpenAI
client = OpenAI()

openai.api_key = '__________PLACEHOLDER______________'


"""
Blood on the Clocktower Engine (5â€“15 players)

IMPORTANT: This codebase uses universal 0-indexed seat numbers throughout.
Player.seat values are 0-indexed, PER_SEAT lists are 0-indexed, and all stored seat numbers in player memory are 0-indexed.
No conversion needed for PER_SEAT lists (PER_SEAT[player.seat]). DO NOT DELETE THIS COMMENT.
"""

import random
import textwrap
import os
from enum import Enum, auto
from dataclasses import dataclass, field
from typing import List, Dict, Any, Optional, Tuple, Union
import re
import math
from datetime import datetime
import inspect

try:
    import openai
    OPENAI_AVAILABLE = True
except ImportError:
    OPENAI_AVAILABLE = False

# --- LLM Integration Settings ---
USE_LLM = False  # Set to True to use LLM for player decisions, False for random actions
API_KEY = None  # OpenAI API key storage
# TEST MODE: Only one seat uses LLM, others are random
TEST_MODE = False
LLM_SEAT = 0  # 0-indexed seat number to use LLM for (if TEST_MODE)
PER_SEAT_USE_LLM = None  # Will be set to a list of bools per player after setup
# --- NEW: Human vs LLM support ---
PER_SEAT_IS_HUMAN = None  # Will be set to a list of bools per player after setup
FAST_LLM_VOTING = False  # If True, LLMs vote on all nominations at once

# --- LLM Input Tracking ---
LLM_INPUT_STATS = {
    "discussion": {"count": 0, "total_words": 0},
    "nomination": {"count": 0, "total_words": 0},
    "voting": {"count": 0, "total_words": 0},
    "fast_voting": {"count": 0, "total_words": 0},
    "target_selection": {"count": 0, "total_words": 0},
    "slayer_shot": {"count": 0, "total_words": 0},
}

# --- Global flags ---
PRINT_STATISTICS = False  # Will be set during setup

def track_llm_input(action_type: str, messages: List[Dict]):
    """Track word count for LLM prompts by action type."""
    if action_type not in LLM_INPUT_STATS:
        LLM_INPUT_STATS[action_type] = {"count": 0, "total_words": 0}
    
    # Count words in all messages
    total_words = 0
    for message in messages:
        if "content" in message:
            total_words += len(message["content"].split())
    
    LLM_INPUT_STATS[action_type]["count"] += 1
    LLM_INPUT_STATS[action_type]["total_words"] += total_words

def print_llm_input_stats():
    """Print summary of LLM input statistics."""
    print_colored("\n=== LLM INPUT STATISTICS ===", 'STORYTELLER')
    total_prompts = sum(stats["count"] for stats in LLM_INPUT_STATS.values())
    total_words = sum(stats["total_words"] for stats in LLM_INPUT_STATS.values())
    
    if total_prompts == 0:
        print_colored("No LLM prompts were used in this game.", 'STORYTELLER')
        return
    
    print_colored(f"Total LLM prompts: {total_prompts}", 'STORYTELLER')
    print_colored(f"Total words input: {total_words:,}", 'STORYTELLER')
    print_colored(f"Average words per prompt: {total_words // total_prompts:,}", 'STORYTELLER')
    print_colored("\nBreakdown by action type:", 'STORYTELLER')
    
    for action_type, stats in sorted(LLM_INPUT_STATS.items()):
        if stats["count"] > 0:
            avg_words = stats["total_words"] // stats["count"]
            print_colored(f"  {action_type}: {stats['count']} prompts, {stats['total_words']:,} words total, {avg_words:,} avg", 'STORYTELLER')

# --- Color print helper for tagged output ---
COLOR_CODES = {
    'PUBLIC': '\033[92m',      # Green
    'STORYTELLER': '\033[93m', # Yellow
    'PRIVATE': '\033[95m',     # Magenta
    'PROMPT': '\033[94m',      # Blue
    'LLM': '\033[96m',         # Cyan
    'ERROR': '\033[91m',       # Red
    'PINK': '\033[95m',        # Pink (same as Magenta)
    'ENDC': '\033[0m',         # Reset
}
def print_colored(msg, tag):
    color = COLOR_CODES.get(tag, '')
    endc = COLOR_CODES['ENDC']
    print(f"{color}[{tag}] {msg}{endc}")
    if DEBUG_ALL_LOGS:
        print(f"[DEBUG_ALL_LOGS][{tag}] {msg}")

def print_llm_prompt_for_seat(player, msg, tag):
    # Show PRIVATE messages to human players (night abilities)
    if is_human_player(player) and tag == 'PRIVATE':
        print_colored(msg, tag)
    # Only print if this seat is LLM-driven and not human, and no human is playing
    elif is_llm_player(player) and not is_human_player(player) and not any(PER_SEAT_IS_HUMAN):
        print_colored(msg, tag)
    # If a human is playing, log these prompts to the storyteller log for post-game review
    elif any(PER_SEAT_IS_HUMAN):
        try:
            frame = inspect.currentframe().f_back
            gs = frame.f_locals.get('gs', None)
            if gs is not None:
                gs.log_secret(f"[LLM PROMPT] {msg}")
        except Exception:
            pass

def call_gpt(messages, label=None, max_tokens=1500, temperature=0.7): # At some point, this should implement the prompt_cache_key feature, but that's a future task.
    """
    Calls the OpenAI API (Responses API) with the provided messages.
    Systematically logs every LLM prompt to the storyteller log for post-game review.
    """
    if not USE_LLM and not TEST_MODE:
        return "LLM API calls are disabled. Using random decisions instead."
    if not OPENAI_AVAILABLE:
        print_colored("OpenAI package not installed. Install with: pip install openai", 'ERROR')
        return "OpenAI package not available. Using random decisions instead."
    
    # Track input statistics
    action_type = "unknown"
    if label:
        label_lower = label.lower()
        for known_type in LLM_INPUT_STATS.keys():
            if known_type in label_lower:
                action_type = known_type
                break
    track_llm_input(action_type, messages)

    # Get player and game state from calling context for XML logging
    try:
        frame = inspect.currentframe().f_back
        player = frame.f_locals.get('player', None)
        gs2 = frame.f_locals.get('gs', None)

        if gs2 is not None and player is not None:
            prompt_content = '\n'.join([f"{m['role'].upper()}: {m['content']}" for m in messages])
            gs2.log_llm_prompt(player, action_type, prompt_content, label=label)

        prompt_log = []
        prompt_log.append(f"[LLM PROMPT] {label if label else ''}")
        if player is not None:
            prompt_log.append(f"Seat {player.seat} ({player.name})")
        for m in messages:
            prompt_log.append(f"{m['role'].upper()}: {m['content']}")
        prompt_log_str = '\n'.join(prompt_log)
        if gs2 is not None:
            gs2.log_secret(prompt_log_str)
        if DEBUG_ALL_LOGS:
            print("\n[DEBUG_ALL_LOGS] LLM PROMPT:")
            print(prompt_log_str)
    except Exception as e:
        print_colored(f"[LOGGING ERROR] Could not log LLM prompt: {e}", 'ERROR')

    # --- API call (Responses API, GPT-5) ---
    try:
        from openai import OpenAI
    except Exception:
        print_colored("OpenAI SDK import failed. Install/upgrade with: pip install --upgrade openai", 'ERROR')
        return "OpenAI SDK not available. Using random decisions instead."

    key = None
    try:
        if 'openai' in globals():
            key = getattr(openai, "api_key", None)
    except Exception:
        pass
    key = key or (API_KEY if 'API_KEY' in globals() else None)
    client = OpenAI(api_key=key) if key else OpenAI()  # also uses OPENAI_API_KEY env var

    def _extract_text(resp):
        # 1) Convenience accessor if present
        try:
            txt = getattr(resp, "output_text", None)
            if isinstance(txt, str) and txt.strip():
                return txt.strip()
        except Exception:
            pass
        # 2) Parse standard Responses shape: response.output[*].content[*].text.value
        try:
            out = getattr(resp, "output", None) or (resp.get("output") if isinstance(resp, dict) else None)
            if out:
                chunks = []
                for item in out:
                    content_list = getattr(item, "content", None) or (item.get("content") if isinstance(item, dict) else None)
                    if not content_list:
                        continue
                    for c in content_list:
                        if isinstance(c, dict):
                            if c.get("type") in ("text", "output_text"):
                                t = c.get("text")
                                if isinstance(t, dict) and "value" in t:
                                    chunks.append(t["value"])
                                elif isinstance(t, str):
                                    chunks.append(t)
                        else:
                            typ = getattr(c, "type", None)
                            if typ in ("text", "output_text"):
                                t = getattr(c, "text", None)
                                if hasattr(t, "value"):
                                    chunks.append(t.value)
                                elif isinstance(t, str):
                                    chunks.append(t)
                if chunks:
                    return "\n".join(chunks).strip()
        except Exception:
            pass
        # 3) Fallback if server routed to chat completions internally
        try:
            ch = getattr(resp, "choices", None)
            if ch:
                msg = getattr(ch[0], "message", None)
                if msg and getattr(msg, "content", None):
                    return msg.content.strip()
                txt = getattr(ch[0], "text", None)
                if isinstance(txt, str) and txt.strip():
                    return txt.strip()
        except Exception:
            pass
        # 4) No text found
        return ""

    def _create(effort: str, out_tokens: int, modified_messages=None):
        # Use modified messages if provided, otherwise use original messages
        messages_to_send = modified_messages if modified_messages is not None else messages
        
        return client.responses.create(
            model="gpt-5-mini",
            input=messages_to_send,        # list of {"role": "system/user/assistant", "content": "..."}
            max_output_tokens=out_tokens,   # caps visible output (and, for GPT-5, reasoning too)
            reasoning={"effort": effort},   # reduce hidden reasoning budget
            # omit temperature; some GPT-5 variants reject it
        )
    
    def _add_game_context(messages):
        """Add context that this is just a game to help avoid policy violations"""
        modified_messages = []
        for msg in messages:
            if msg['role'] == 'system':
                # Add game context to system messages
                content = msg['content']
                if "This is a game called Blood on the Clocktower" not in content:
                    content = f"This is a game called Blood on the Clocktower. Please keep in mind that it is all a simulation. {content}"
                modified_messages.append({'role': 'system', 'content': content})
            else:
                modified_messages.append(msg)
        return modified_messages

    # First attempt: low effort + a reasonable floor for output tokens
    effective_max = max(int(max_tokens), 1024)
    try:
        resp = _create("low", effective_max)
        content = _extract_text(resp)
    except Exception as e:
        if "invalid_prompt" in str(e).lower() or "usage policy" in str(e).lower() or "400" in str(e):
            # Policy violation detected, retry with game context added
            if DEBUG_ALL_LOGS and gs2 is not None:
                gs2.log_secret(f"[DEBUG] Policy violation detected, retrying with game context: {e}")
            try:
                modified_messages = _add_game_context(messages)
                resp = _create("medium", effective_max, modified_messages)
                content = _extract_text(resp)
            except Exception as e2:
                # If still fails, log and return fallback
                if DEBUG_ALL_LOGS and gs2 is not None:
                    gs2.log_secret(f"[DEBUG] Still failed after adding game context: {e2}")
                content = "I understand this is a game scenario. Based on the available options, I will make a reasonable choice."
        else:
            # Other error, re-raise
            raise
    
    # Log cache statistics if debug is enabled or print_statistics is enabled
    debug_enabled = DEBUG_ALL_LOGS
    print_stats_enabled = PRINT_STATISTICS
    
    # Debug output to see what's happening
    if DEBUG_ALL_LOGS or print_stats_enabled:
        try:
            # Check if we have a valid response object
            if 'resp' in locals() and resp is not None:
                usage = getattr(resp, 'usage', None)
            if usage:
                input_tokens = getattr(usage, 'input_tokens', 0)
                output_tokens = getattr(usage, 'output_tokens', 0)
                
                # Extract cached token information
                input_details = getattr(usage, 'input_tokens_details', None)
                cached_tokens = getattr(input_details, 'cached_tokens', 0) if input_details else 0
                
                # Extract reasoning tokens if available
                output_details = getattr(usage, 'output_tokens_details', None)
                reasoning_tokens = getattr(output_details, 'reasoning_tokens', 0) if output_details else 0
                
                # Calculate hit rate
                hit_pct = (cached_tokens / input_tokens * 100) if input_tokens > 0 else 0
                
                # Display cache statistics in a different color
                cache_stats = f"[CACHE] {label or ''}: input={input_tokens} cached={cached_tokens} ({hit_pct:.1f}%), output={output_tokens}, reasoning={reasoning_tokens}"
                print_colored(cache_stats, 'PINK')
                
                # # Print the final prompt if print_statistics is enabled
                # if print_stats_enabled:
                #     print_colored(f"[PROMPT] Final prompt submitted to LLM:", 'DEBUG')
                #     for i, msg in enumerate(messages):
                #         print_colored(f"[PROMPT] {i+1}. {msg['role'].upper()}: {msg['content']}", 'DEBUG')
                #     print_colored(f"[PROMPT] End of prompt", 'DEBUG')
        except Exception as e:
            print_colored(f"[CACHE] Error reading cache stats: {e}", 'ERROR')

    # If we still got truncated (no visible text) or status=incomplete, retry once with more room & minimal effort
    try:
        # Check if we have a valid response object
        if 'resp' in locals() and resp is not None:
            status = getattr(resp, "status", None)
            reason = getattr(getattr(resp, "incomplete_details", None), "reason", None)
        else:
            status = reason = None
    except Exception:
        status = reason = None

    if (not content) or (status == "incomplete" and reason == "max_output_tokens"):
        if DEBUG_ALL_LOGS and gs2 is not None:
            # Check if we have a valid response object for usage info
            usage_info = "unknown"
            if 'resp' in locals() and resp is not None:
                try:
                    usage = getattr(resp, 'usage', None)
                    if usage:
                        output_tokens = getattr(usage, 'output_tokens', None)
                        usage_info = str(output_tokens) if output_tokens is not None else "unknown"
                except Exception:
                    usage_info = "error"
            
            gs2.log_secret(f"[DEBUG] Retry due to incomplete/empty output. status={status}, reason={reason}, used={usage_info}")
        try:
            resp = _create("minimal", max(effective_max * 2, 2048))
            content = _extract_text(resp)
        except Exception as e:
            if "invalid_prompt" in str(e).lower() or "usage policy" in str(e).lower() or "400" in str(e):
                # Policy violation detected, retry with game context added
                if DEBUG_ALL_LOGS and gs2 is not None:
                    gs2.log_secret(f"[DEBUG] Policy violation detected on retry, retrying with game context: {e}")
                try:
                    modified_messages = _add_game_context(messages)
                    resp = _create("minimal", max(effective_max * 2, 2048), modified_messages)
                    content = _extract_text(resp)
                except Exception as e2:
                    # If still fails, log and return fallback
                    if DEBUG_ALL_LOGS and gs2 is not None:
                        gs2.log_secret(f"[DEBUG] Still failed after adding game context on retry: {e2}")
                    content = "(Policy violation - using fallback response)"
            else:
                # Other error, re-raise
                raise
        
        # Log cache statistics for retry attempt if debug is enabled or print_statistics is enabled
        debug_enabled = DEBUG_ALL_LOGS
        print_stats_enabled = PRINT_STATISTICS
        
        if DEBUG_ALL_LOGS or print_stats_enabled:
            try:
                # Check if we have a valid response object
                if 'resp' in locals() and resp is not None:
                    usage = getattr(resp, 'usage', None)
                    if usage:
                        input_tokens = getattr(usage, 'input_tokens', 0)
                        output_tokens = getattr(usage, 'output_tokens', 0)
                        
                        # Extract cached token information
                        input_details = getattr(usage, 'input_tokens_details', None)
                        cached_tokens = getattr(input_details, 'cached_tokens', 0) if input_details else 0
                        
                        # Extract reasoning tokens if available
                        output_details = getattr(usage, 'output_tokens_details', None)
                        reasoning_tokens = getattr(output_details, 'reasoning_tokens', 0) if output_details else 0
                        
                        # Calculate hit rate
                        hit_pct = (cached_tokens / input_tokens * 100) if input_tokens > 0 else 0
                        
                        # Display cache statistics in a different color
                        cache_stats = f"[CACHE] {label or ''} (retry): input={input_tokens} cached={cached_tokens} ({hit_pct:.1f}%), output={output_tokens}, reasoning={reasoning_tokens}"
                        print_colored(cache_stats, 'PINK')
                        
                        # # Print the final prompt if print_statistics is enabled (for retry attempts)
                        # if print_stats_enabled:
                        #     print_colored(f"[PROMPT] Final prompt submitted to LLM (retry):", 'DEBUG')
                        #     for i, msg in enumerate(messages):
                        #         print_colored(f"[PROMPT] {i+1}. {msg['role'].upper()}: {msg['content']}", 'DEBUG')
                        #     print_colored(f"[PROMPT] End of prompt (retry)", 'DEBUG')
            except Exception as e:
                print_colored(f"[CACHE] Error reading retry cache stats: {e}", 'ERROR')

    content = (content or "").strip()
    if not content:
        content = "(No content returned.)"

    # Log response in XML format
    try:
        if gs2 is not None and player is not None:
            # Extract cache statistics for XML logging
            cache_info = {}
            try:
                # Check if we have a valid response object
                if 'resp' in locals() and resp is not None:
                    usage = getattr(resp, 'usage', None)
                    if usage:
                        input_tokens = getattr(usage, 'input_tokens', 0)
                        output_tokens = getattr(usage, 'output_tokens', 0)
                        
                        input_details = getattr(usage, 'input_tokens_details', None)
                        cached_tokens = getattr(input_details, 'cached_tokens', 0) if input_details else 0
                        
                        output_details = getattr(usage, 'output_tokens_details', None)
                        reasoning_tokens = getattr(output_details, 'reasoning_tokens', 0) if output_details else 0
                        
                        hit_pct = (cached_tokens / input_tokens * 100) if input_tokens > 0 else 0
                        
                        cache_info = {
                            'input_tokens': input_tokens,
                            'cached_tokens': cached_tokens,
                            'hit_percentage': round(hit_pct, 1),
                            'output_tokens': output_tokens,
                            'reasoning_tokens': reasoning_tokens
                        }
            except Exception:
                pass  # Cache info is optional
            
            gs2.log_llm_response(player, action_type, content, label=label, **cache_info)
    except Exception as e:
        print_colored(f"[LOGGING ERROR] Could not log LLM response: {e}", 'ERROR')

    return content


# def call_gpt(messages, label=None, max_tokens=400, temperature=0.7):
#     """
#     Calls the OpenAI API with the provided messages.
#     Systematically logs every LLM prompt to the storyteller log for post-game review.
#     """
#     if not USE_LLM and not TEST_MODE:
#         return "LLM API calls are disabled. Using random decisions instead."
#     if not OPENAI_AVAILABLE:
#         print_colored("OpenAI package not installed. Install with: pip install openai", 'ERROR')
#         return "OpenAI package not available. Using random decisions instead."
    
#     # Track input statistics
#     action_type = "unknown"
#     if label:
#         # Extract action type from label (e.g., "Discussion (Seat 1)" -> "discussion")
#         label_lower = label.lower()
#         for known_type in LLM_INPUT_STATS.keys():
#             if known_type in label_lower:
#                 action_type = known_type
#                 break
#     track_llm_input(action_type, messages)
    
#     # Get player and game state from calling context for XML logging
#     try:
#         frame = inspect.currentframe().f_back
#         player = frame.f_locals.get('player', None)
#         gs2 = frame.f_locals.get('gs', None)
        
#         # Log prompt in XML format if we have the context
#         if gs2 is not None and player is not None:
#             prompt_content = '\n'.join([f"{m['role'].upper()}: {m['content']}" for m in messages])
#             gs2.log_llm_prompt(player, action_type, prompt_content, label=label)
        
#         # Also log to storyteller log for backward compatibility
#         prompt_log = []
#         prompt_log.append(f"[LLM PROMPT] {label if label else ''}")
#         if player is not None:
#             prompt_log.append(f"Seat {player.seat} ({player.name})")
#         for m in messages:
#             prompt_log.append(f"{m['role'].upper()}: {m['content']}")
#         prompt_log_str = '\n'.join(prompt_log)
#         if gs2 is not None:
#             gs2.log_secret(prompt_log_str)
#         if DEBUG_ALL_LOGS:
#             print("\n[DEBUG_ALL_LOGS] LLM PROMPT:")
#             print(prompt_log_str)
#     except Exception as e:
#         print_colored(f"[LOGGING ERROR] Could not log LLM prompt: {e}", 'ERROR')
    
#     try:
#         if not getattr(openai, 'api_key', None):
#             if API_KEY:
#                 openai.api_key = API_KEY
#             else:
#                 print_colored("No API key provided. Using random decisions instead.", 'ERROR')
#                 return "No API key provided. Using random decisions instead."
#         response = openai.chat.completions.create(
#             model="gpt-4.1-mini",
#             messages=messages,
#             max_tokens=max_tokens,
#             temperature=temperature
#         )
#         content = response.choices[0].message.content.strip()
        
#         # Log response in XML format
#         try:
#             if gs2 is not None and player is not None:
#                 gs2.log_llm_response(player, action_type, content, label=label)
#         except Exception as e:
#             print_colored(f"[LOGGING ERROR] Could not log LLM response: {e}", 'ERROR')
        
#         return content
#     except Exception as e:
#         print_colored(f"API call error: {e}", 'ERROR')
#         return f"API error: {str(e)[:100]}... Using random decisions instead."

def get_effective_role(player: "Player") -> Tuple[str, str, "Alignment"]:
    """
    Get the effective role information for a player, handling drunk case and lunatic case.
    Returns (role_name, ability_desc, alignment)
    """
    # Handle Drunk case
    if player.role.name == "Drunk" and "drunk_role" in player.hidden_state:
        fake_role_name = player.hidden_state["drunk_role"]
        fake_role = ROLE_BY_NAME[fake_role_name]
        return fake_role_name, fake_role.ability_desc, Alignment.TOWNSFOLK
    
    # Handle Lunatic case - they think they're the demon
    elif player.role.name == "Lunatic" and "lunatic_demon_info" in player.hidden_state:
        fake_demon_type = player.hidden_state["lunatic_demon_info"]["fake_demon_type"]
        fake_demon_role = ROLE_BY_NAME[fake_demon_type]
        return fake_demon_type, fake_demon_role.ability_desc, Alignment.DEMON
    
    else:
        return player.role.name, player.role.ability_desc, player.role.alignment

def get_effective_role_name(player: "Player") -> str:
    """
    Get just the effective role name for a player, handling drunk case and lunatic case.
    Returns the role name the player thinks they are.
    Use this when you want to show the player what they think they are.
    """
    # Handle Drunk case (drunk_role is in hidden_state, not memory, because players should not be told that they are the Drunk [same as with Lunatic])
    if player.role.name == "Drunk" and "drunk_role" in player.hidden_state:
        return player.hidden_state["drunk_role"]
    
    # Handle Lunatic case - they think they're the demon
    elif player.role.name == "Lunatic" and "lunatic_demon_info" in player.hidden_state:
        return player.hidden_state["lunatic_demon_info"]["fake_demon_type"]
    
    else:
        return player.role.name

def get_actual_role_info(player: "Player") -> Tuple[str, str, "Alignment"]:
    """
    Get the actual role information for a player, ignoring drunk/lunatic effects.
    Returns (role_name, ability_desc, alignment) that the player actually is.
    Use this when you want to show other players that get full role information (e.g., Ravenkeeper learns that someone is actually aDrunk) or in secret/dev logs what the player actually is.
    """
    return player.role.name, player.role.ability_desc, player.role.alignment

def get_actual_role_name(player: "Player") -> str:
    """
    Get the actual role name for a player, ignoring drunk/lunatic effects.
    Returns the role name the player actually is.
    Use this when you want to show other players that get full role information (e.g., Ravenkeeper learns that someone is actually a Drunk) or in secret/dev logs what the player actually is.
    """
    return player.role.name

def get_base_role_distribution(player_count: int) -> Tuple[int, int, int, int]:
    """
    Get the base role distribution for a given player count.
    Returns (base_town, base_outsider, base_minion, base_demon)
    This is the distribution before any Baron/Capo Crimini modifications.
    """
    if player_count == 5:
        return 3, 0, 1, 1
    elif player_count == 6:
        return 3, 1, 1, 1
    elif player_count == 7:
        return 5, 0, 1, 1
    elif player_count == 8:
        return 5, 1, 1, 1
    elif player_count == 9:
        return 5, 2, 1, 1
    elif player_count == 10:
        return 7, 0, 2, 1
    elif player_count == 11:
        return 7, 1, 2, 1
    elif player_count == 12:
        return 7, 2, 2, 1
    elif player_count == 13:
        return 9, 0, 3, 1
    elif player_count == 14:
        return 9, 1, 3, 1
    elif player_count == 15:
        return 9, 2, 3, 1
    else:
        # Fallback for invalid player counts
        return 0, 0, 0, 0

def get_role_reference_guide(gs: "GameState") -> str:
    """
    Get a comprehensive reference guide of all roles in the game.
    This helps players understand all characters, not just their own.
    Only shows roles from the chosen character set.
    """
    lines = []
    
    # Determine which character sets to include based on gs.character_set
    # 1 = Trouble Brewing, 2 = Bad Moon Rising, 3 = Both
    include_tb = gs.character_set in [1, 3]
    include_bmr = gs.character_set in [2, 3]
    
    if include_tb and include_bmr:
        lines.append("=== BLOOD ON THE CLOCKTOWER - ALL ROLES ===")
    elif include_tb:
        lines.append("=== BLOOD ON THE CLOCKTOWER - TROUBLE BREWING ROLES ===")
    elif include_bmr:
        lines.append("=== BLOOD ON THE CLOCKTOWER - BAD MOON RISING ROLES ===")
    
    # Trouble Brewing Roles
    if include_tb:
        lines.append("\n--- TROUBLE BREWING ---")
        
        lines.append("\nTOWNSFOLK:")
        for role in TB_TOWNSFOLK:
            lines.append(f"  {role.name}: {role.ability_desc}")
        
        lines.append("\nOUTSIDERS:")
        for role in TB_OUTSIDERS:
            lines.append(f"  {role.name}: {role.ability_desc}")
        
        lines.append("\nMINIONS:")
        for role in TB_MINIONS:
            lines.append(f"  {role.name}: {role.ability_desc}")
        
        lines.append("\nDEMONS:")
        for role in TB_DEMONS:
            lines.append(f"  {role.name}: {role.ability_desc}")
    
    # Bad Moon Rising Roles
    if include_bmr:
        lines.append("\n--- BAD MOON RISING ---")
        
        lines.append("\nTOWNSFOLK:")
        for role in BMR_TOWNSFOLK:
            lines.append(f"  {role.name}: {role.ability_desc}")
        
        lines.append("\nOUTSIDERS:")
        for role in BMR_OUTSIDERS:
            lines.append(f"  {role.name}: {role.ability_desc}")
        
        lines.append("\nMINIONS:")
        for role in BMR_MINIONS:
            lines.append(f"  {role.name}: {role.ability_desc}")
        
        lines.append("\nDEMONS:")
        for role in BMR_DEMONS:
            lines.append(f"  {role.name}: {role.ability_desc}")
    
    return "\n".join(lines)

def format_player_prompt(gs: "GameState", player: "Player", action_type: str, options=None) -> List[Dict]:
    """
    Format a prompt for a player decision.
    This function ensures all players get the same universal prompt structure.
    """
    messages = []
    
    # === UNIVERSAL PROMPT PREFIX (same for all players in a given game) ===
    universal_prefix = {
        "role": "system",
        "content": (
            "You are playing Blood on the Clocktower, a social deduction game. "
            "You are an AI player participating in this game. "
            "Always respond using the appropriate format tags: <THINK> for private thoughts and <SAY> for public statements. "
            "Your responses should be strategic, logical, and appropriate for your role and alignment. "
            "Remember that this is a game of deception and deduction - not all information you receive may be truthful."
        )
    }
    messages.append(universal_prefix)
    


    slayer_instruction = {
        "role": "system",
        "content": "[SLAYER INSTRUCTION] To attempt or pretend to attempt a Slayer shot during any daytime discussion or nomination action, include 'SLAYER_SHOT: <target name>' in your public comment. Example: 'I think Golf is suspicious. SLAYER_SHOT: Golf' The game will detect this and resolve the Slayer ability if appropriate. Only one Slayer shot is allowed per Slayer per game. If you are not a Slayer and are not pretending to be a Slayer, you can ignore these instructions."
    }
    messages.append(slayer_instruction)
        
    gossip_instruction = {
        "role": "system",
        "content": "[GOSSIP INSTRUCTION] To make or pretend to make a Gossip statement during any daytime discussion or nomination action, include 'GOSSIP: <statement>' in your public comment. Example: 'I think we should be careful. GOSSIP: The Demon is sitting next to a Minion.' The game will evaluate this statement for truthfulness. If you are not a Gossip and are not pretending to be a Gossip, you can ignore these instructions."
    }
    messages.append(gossip_instruction)
    
    # Get effective role information (handles drunk case externally)
    role_name, ability_desc, alignment = get_effective_role(player)
    
    # Combine role/ability and private info into one message
    private_lines = []


    # Add character set information
    character_set_names = {1: "Trouble Brewing", 2: "Bad Moon Rising", 3: "Both Character Sets"}
    private_lines.append(f"Character Set: {character_set_names.get(gs.character_set, 'Unknown')}")

    
    private_lines.append("")  # Line break for clarity
    
    # Add discussion format information
    private_lines.append("<DISCUSSION_FORMAT>")
    private_lines.append("Discussion proceeds in assigned seat order (Seat 0, Seat 1, Seat 2, etc.) with TWO PASSES per day:")
    private_lines.append("- First Pass: Each player speaks once in seat order")
    private_lines.append("- Second Pass: Each player speaks again in seat order")
    private_lines.append("This means you will have two opportunities to contribute to the day's discussion. On the first day, some players will speak before others have had a chance to speak once.")
    private_lines.append("</DISCUSSION_FORMAT>")
    
    private_lines.append("")  # Line break for clarity
    
    private_lines.append(f"<STRATEGY_GUIDANCE>")
    private_lines.append("In some cases, even good players may have a reason to pretend to be a character they are not, so as to fool the evil team. For example, it might be wise for the soldier or Ravenkeeper to pretend to be a character that the imp would like to target, such as the fortune teller or empath. However, this is a risky strategy, because if you are caught in a lie, you may be executed.")
    private_lines.append("IMPORTANT: When bluffing as any character, you should only claim to be a character that is actually present in this game. Check the ROLE_REFERENCE section below to see which characters are available in your character set.")
    private_lines.append("Pay close attention to who is ALIVE vs DEAD in the game state. Only living players can be nominated, voted for, or targeted by abilities.")
    private_lines.append("In general, players should try to execute almost every single day, even if they do not have definitive evidence. Choosing not to execute someone more than once per game is usually suicide, unless there is strong reason to wait (e.g., good reason to believe a mastermind minion is in play after killing a demon). However, it is crucial to not fixate on a single hypothesis/candidate when there is not evidence in favor of them, and instead people should consider alternative candidates rather than bandwagoning. When voting, if you are a good player, you should vote to execute the player who seems most likely to be evil, based on logic and evidence (not just suspicion). If you are an evil player, you should try to avoid being executed and subtly push for good players to be executed, while blending in. All players should use logic and evidence to the best of their ability, but remember you will almost never have perfect proof, and waiting for perfect proof is usually a guaranteed suicide for the good team.")
    private_lines.append("Be careful not to fall into a cycle of just repeating what everyone else says. Just because a lot of people around you are saying X does not mean you should necessarily repeat X, unless it seems true. Be wary of this kind of groupthink or bandwagoning, and evaluate logic and evidence on the merits.")
    private_lines.append("")
    private_lines.append("BAD MOON RISING MECHANICS:")
    private_lines.append("- Some characters can target dead players (Professor resurrection)")
    private_lines.append("- Some characters have multiple 'deaths' (Zombuul, Fool)")
    private_lines.append("- Some characters can prevent death (Pacifist, Devil's Advocate)")
    private_lines.append("- Some characters can make others drunk for extended periods (Courtier, Minstrel)")
    private_lines.append("- Some characters can change alignment (Goon)")
    private_lines.append("- Some characters can extend the game (Mastermind)")
    private_lines.append("- Some characters can make public statements (Gossip)")
    private_lines.append("- Some characters can choose targets when learning of death (Moonchild)")
    private_lines.append("</STRATEGY_GUIDANCE>")
    
    private_lines.append("")  # Line break for clarity
    
    private_lines.append(f"<RESPONSE_FORMAT>")
    private_lines.append("When responding for public discussion, use the following format:")
    private_lines.append("<THINK>your private reasoning here</THINK>")
    private_lines.append("<SAY>what you say out loud to the group</SAY>")
    private_lines.append("Only the <SAY> section will be shared with the group.")
    private_lines.append("")
    private_lines.append("REMINDER: If bluffing as a character, only claim to be characters that are actually in play in this game (check the ROLE_REFERENCE section).")
    private_lines.append("</RESPONSE_FORMAT>")

    private_lines.append("")  # Line break for clarity

    # Add full role reference guide so players understand all characters
    role_guide = get_role_reference_guide(gs)
    private_lines.append("")
    private_lines.append(f"<ROLE_REFERENCE>\n{role_guide}\n</ROLE_REFERENCE>")
    
    private_lines.append("")  # Line break for clarity

    # Add role distribution information (base distribution, excluding Baron/Capo Crimini effects)
    base_town, base_outsider, base_minion, base_demon = get_base_role_distribution(len(gs.players))
    private_lines.append("<ROLE_DISTRIBUTION>")
    private_lines.append(f"Base role distribution for {len(gs.players)} players (excluding any Baron/Capo Crimini modifications):")
    private_lines.append(f"- Townsfolk: {base_town}")
    private_lines.append(f"- Outsiders: {base_outsider}")
    private_lines.append(f"- Minions: {base_minion}")
    private_lines.append(f"- Demons: {base_demon}")
    private_lines.append("Note: The actual distribution may differ due to Baron, Capo Crimini, or other character effects.")
    private_lines.append("</ROLE_DISTRIBUTION>")
    
    private_lines.append("")  # Line break for clarity

    private_lines.append(f"Some important strategic guidance to consider for discussions and strategies: There are a few common failure modes which can cause the good team to fail, namely that they bandwagons mindlessly around a common refrain--sometimes in support of executing someone on flimsy grounds, sometimes in support of not executing anyone even when there is clearly someone who should be executed.")

    # Add recent public discussion (consolidated and placed prior to any player-specific parts of the prompt.)
    recent_discussion = []
    current_day = gs.day
    # Include messages from current day and previous two days
    for entry in gs.public_log:
        # Extract day number from phase_tick_id (e.g., "Day 3", "Night 2")
        phase_tick = entry.get('phase_tick_id', '')
        entry_day = None
        if phase_tick.startswith('Day '):
            try:
                entry_day = int(phase_tick.split(' ')[1])
            except (IndexError, ValueError):
                continue
        elif phase_tick.startswith('Night '):
            try:
                entry_day = int(phase_tick.split(' ')[1])
            except (IndexError, ValueError):
                continue
        
        # Only include messages from current day and previous two days
        if entry_day is not None and entry_day >= current_day - 2:
            # Discussion messages have format "PlayerName: message"
            if ((':' in entry['msg'] and not entry['msg'].startswith("Day ") and not entry['msg'].startswith("Nominations begin") and not entry['msg'].startswith("Players vote")) or 
                ('âš¡' in entry['msg'] and 'attempts a Slayer shot' in entry['msg']) or
                ('nobody has had a chance to speak yet' in entry['msg'])):
                recent_discussion.append(entry['msg'])
    
    if recent_discussion:
        private_lines.append("")
        private_lines.append("Recent public discussion (last 3 days, this day included):")
        private_lines.extend(recent_discussion)  # All messages from the last 3 days (this day included).
    

    
    # Add game state information (moved here to appear after public discussion)
    game_state = get_game_snapshot(gs, player)
    private_lines.append("")
    private_lines.append(f"<GAME_STATE>\n{game_state}\n</GAME_STATE>")
    
    # Add caution instruction
    private_lines.append("")
    private_lines.append("IMPORTANT: Think carefully to yourself about the logic of what you plan to do or say, especially if you are an evil player planning to bluff. Evaluate multiple options for what you should do or say, and ask yourself questions like 'how might I get caught?' or 'how might this help or hurt my team?' But remember to blend in and avoid detection.")
    
    # === PLAYER-SPECIFIC SECTION ===
    
    private_lines.append("")
    private_lines.append(f"<ROLE_INFO>")
    private_lines.append(f"Seat: {player.seat}")
    private_lines.append(f"Role: {role_name}")
    private_lines.append(f"Ability: {ability_desc}")
    private_lines.append(f"Alignment: {alignment.value}")
    private_lines.append(f"Goal: {'Help the good team eliminate the demon.' if alignment in {Alignment.TOWNSFOLK, Alignment.OUTSIDER} else 'Help the evil team eliminate the good players.'}")
    private_lines.append(f"</ROLE_INFO>")

    # Add specific instructions for night action roles
    if action_type == "target_selection":
        private_lines.append("")
        private_lines.append("<NIGHT_ACTION_INSTRUCTIONS>")
        private_lines.append("This is a NIGHT ACTION where you must choose a target. Think strategically about:")
        private_lines.append("- Who would be the most valuable target for your team's goals?")
        private_lines.append("- What information have you gathered that could inform your choice?")
        private_lines.append("- How might your choice affect the game state?")
        private_lines.append("- What risks or benefits come with each potential target?")
        private_lines.append("Use <THINK> to carefully analyze your options and reasoning before making your choice.")
        private_lines.append("</NIGHT_ACTION_INSTRUCTIONS>")
    
    # Add bluffing reminder for all players (important for both good and evil players)
    private_lines.append("")
    private_lines.append("BLUFFING REMINDER FOR ALL PLAYERS: When bluffing as any character, only claim to be characters that are actually present in this game. Check the ROLE_REFERENCE section below. This advice applies to all players regardless of alignment.")
    
    private_lines.append("</RESPONSE_FORMAT>")
    
    # Add PRIVATE MEMORY if it contains info not already in the above
    if player.memory:
        mem_lines = []
        mem_lines.append("<PRIVATE_MEMORY>")
        for k, v in player.memory.items():
            # Never show 'was_demon' information to exorcist (they shouldn't know if they targeted the demon)
            if k == "exorcist" and isinstance(v, dict) and "data" in v and "was_demon" in v["data"]:
                # Show exorcist memory without revealing whether they targeted the demon
                data_copy = v["data"].copy()
                del data_copy["was_demon"]
                mem_lines.append(f"- {k}: {{'type': '{v['type']}', 'data': {data_copy}}}")
                continue
            # Special formatting for fast_votes with clarification
            elif k == "fast_votes" and isinstance(v, list):
                mem_lines.append(f"- {k}: {', '.join(str(x) for x in v)} (list of seat numbers you voted YES on during fast voting)")
            elif k in ("imp", "minions", "other_minions") and isinstance(v, list):
                mem_lines.append(f"- {k}: {', '.join(str(x) for x in v)}")
            else:
                mem_lines.append(f"- {k}: {v}")
        mem_lines.append("</PRIVATE_MEMORY>")
        if len(mem_lines) > 2:  # More than just the opening and closing tags
            private_lines.append("")  # Line break for clarity
            private_lines.extend(mem_lines)
    
    messages.append({
        "role": "system",
        "content": "\n".join(private_lines)
    })
    
    # Add DEAD status if player is dead
    if not player.alive:
        messages.append({
            "role": "system",
            "content": "<PLAYER_STATUS>\nYou are DEAD. You may still talk, but you cannot use your ability or nominate/vote (unless otherwise allowed).\n</PLAYER_STATUS>"
        })
    
    # Add player's own recent actions/results if available
    if player.memory:
        action_results = []
        for k, v in player.memory.items():
            if k.startswith('action_result_'):
                action_results.append(f"- {k.replace('action_result_', '')}: {v}")
        
        if action_results:
            messages.append({
                "role": "system",
                "content": f"<YOUR_RECENT_ACTIONS>\n" + "\n".join(action_results) + "\n</YOUR_RECENT_ACTIONS>"
            })
    
    if action_type == "nomination":
        # Check if Bad Moon Rising characters are available to determine available players
        bmr_available = gs.character_set in [2, 3]  # 2=Bad Moon Rising, 3=Both
        
        # List available players and who has already been nominated
        if bmr_available:
            available_players = [p for p in gs.players if p is not player]
            alive_names = ', '.join(f'{p.name} (Seat {p.seat}){" [DEAD]" if not p.alive else ""}' for p in available_players)
        else:
            alive_players = [p for p in gs.players if p.alive]
            alive_names = ', '.join(f'{p.name} (Seat {p.seat})' for p in alive_players if p is not player)
        
        nominations = gs.memory.get("nominations", [])
        already_nominated = [n["nominee"] for n in nominations]
        already_nominated_names = ', '.join(f'{p.name} (Seat {p.seat})' for p in already_nominated) if already_nominated else 'None'
        

        
        # Check if Bad Moon Rising characters are available to determine nomination text
        nomination_text = "one player (other than yourself)" if bmr_available else "one living player (other than yourself)"
        
        # Determine the correct label for available players
        available_label = "Available players" if bmr_available else "Alive players"
        
        messages.append({
            "role": "system",
            "content": (
                f"\nIt is the nomination phase. You may nominate {nomination_text} for execution, or PASS if you do not wish to nominate anyone. "
                "You may only nominate once per day.\n"
                "You should avoid nominating without any cause, but you should nominate if you have some reason to be suspicious.\n"
                f"{available_label} you can nominate: {alive_names}\n"
                f"Players already nominated today: {already_nominated_names}\n"
                "Avoid and ignore generic rhetoric about calls for caution; only emphasize caution when there is very specific/concrete reason to hold off (e.g., fear of a mastermind, fear of executing the saint, confidence that players will get new information over time).\n"
                "Respond ONLY in one of the following formats: {NOMINATE: seat number or name} or {PASS}. For example: {NOMINATE: 2} or {NOMINATE: Charlie} or {PASS}.\n"
            )
        })
    
    # Add voting context if this is a voting action
    if action_type == "voting":
        
        if options and "nominee" in options:
            nominee = options["nominee"]
            nominator = options.get("nominator")
            messages.append({
                "role": "system",
                "content": (
                                    f"\nIt is the voting phase. {nominee.name} (Seat {nominee.seat}) has been nominated for execution"
                f"{f' by {nominator.name} (Seat {nominee.seat})' if nominator else ''}.\n"
                f"You must vote YES or NO on whether to execute {nominee.name}.\n"
                "Avoid and ignore generic rhetoric about calls for caution; only emphasize caution when there is very specific/concrete reason to hold off (e.g., fear of a mastermind, fear of executing the saint, confidence that players will get new information over time).\n"
                    "Respond with either YES or NO.\n"
                )
            })
    
    # Add fast voting context if this is a fast voting action
    if action_type == "fast_voting":
        # Get nominees from options
        nominees = options.get("nominees", []) if options else []
        nominee_names = ', '.join(f'{p.name} (Seat {p.seat})' for p in nominees) if nominees else 'No nominees specified'
        
        messages.append({
            "role": "system",
            "content": (
                f"\nIt is the fast voting phase. The following players have been nominated for execution: {nominee_names}\n"
                "You must provide ALL your votes at once. List the FULL NAMES of the players you want to vote YES for, separated by commas.\n"
                "If you do not list a player's name, you will vote NO for them.\n"
                "You cannot vote for yourself.\n"
                "Examples:\n"
                "- 'Charlie, Delta' means vote YES for Charlie and Delta, NO for everyone else\n"
                "- 'Charlie' means vote YES only for Charlie, NO for everyone else\n"
                "- 'none' or 'no' means vote NO for everyone\n"
                "- 'all' means vote YES for everyone (except yourself)\n"
                "Respond with the full names of players you want to vote YES for, separated by commas."
            )
        })
    
    # Add player identification at the end of every prompt
    messages.append({
        "role": "system",
        "content": f"\n---\nYou are {player.name} (Seat {player.seat})."
    })
    
    # Add specific user message for target selection actions
    if action_type == "target_selection":
        if options:
            target_names = ', '.join(f'{p.name} (Seat {p.seat})' for p in options)
            messages.append({
                "role": "user",
                "content": f"Choose a target from: {target_names}. Think strategically about your choice and explain your reasoning in <THINK> tags before making your decision."
            })
    
    return messages



def parse_llm_response(response, action_type, options=None, player=None):
    """
    Parse the response from the LLM API.
    Only <SAY> is ever shown publicly. If <SAY> is missing, fallback to first non-THINK block or a default message.
    Robustly strips <THINK> blocks even if unclosed, to prevent leaks.
    """
    if response is None or "API error" in response or "API call" in response:
        # Handle API errors with random choices
        if action_type == "target_selection" and options:
            return random.choice(options).seat
        elif action_type == "discussion":
            return "I have nothing to share right now."
        elif action_type == "nomination":
            # Bias random fallback to nominate more often
            return "PASS" if random.random() < 0.2 else (random.choice(options).seat if options else "PASS")  # Reduced from 0.3 to 0.2 (80% chance to nominate)
        elif action_type == "voting":
            # Bias random fallback to vote YES more often
            return "YES" if random.random() < 0.7 else "NO"
        elif action_type == "fast_voting":
            # For fast voting, return a list of player names to vote YES for
            if options and "nominees" in options:
                nominees = options["nominees"]
                # Randomly choose 1-2 players to vote YES for (bias toward voting YES)
                num_yes_votes = 1 if random.random() < 0.6 else 2
                yes_votes = random.sample(nominees, min(num_yes_votes, len(nominees)))
                return ", ".join(p.name for p in yes_votes)
            return "none"
        elif action_type == "slayer_shot":
            return "PASS" if random.random() < 0.7 else (random.choice(options).seat if options else "PASS")
        else:
            return None
    # Extract <MEMORY>...</MEMORY> and append to player.memory if present
    if player is not None:
        memory_blocks = re.findall(r'<MEMORY>(.*?)</MEMORY>', response, re.DOTALL | re.IGNORECASE)
        for mem in memory_blocks:
            key = f"note_{len(player.memory)}"
            player.memory[key] = mem.strip()
    # Extract and log <THINK> block for important night-action roles and all LLM actions
    if player is not None:
        think_matches = re.findall(r'<THINK>(.*?)</THINK>', response, re.DOTALL | re.IGNORECASE)
        for think in think_matches:
            think_clean = think.strip()
            if think_clean:
                # Always log all private thoughts to the storyteller log
                if 'gs' in globals():
                    gs = globals()['gs']
                    gs.log_secret(f"[LLM <THINK>] {player.label()}: {think_clean}")
                else:
                    print_colored(f"[LLM <THINK>] {player.label()}: {think_clean}", 'PRIVATE')
    # --- FIX: Remove all <THINK> blocks, even if unclosed, before public output ---
    # Remove all <THINK>...</THINK> blocks
    response_wo_think = re.sub(r'<THINK>.*?</THINK>', '', response, flags=re.DOTALL | re.IGNORECASE)
    # Remove any remaining <THINK> blocks that are not closed
    response_wo_think = re.sub(r'<THINK>.*', '', response_wo_think, flags=re.DOTALL | re.IGNORECASE)
    # Extract <SAY> block for public output
    say_match = re.search(r'<SAY>(.*?)</SAY>', response_wo_think, re.DOTALL | re.IGNORECASE)
    if say_match:
        response = say_match.group(1).strip()
    else:
        # Fallback: remove any other tags and return the first non-empty line
        # Remove all tags like <...>
        response_wo_tags = re.sub(r'<[^>]+>', '', response_wo_think)
        # Get the first non-empty line
        lines = [line.strip() for line in response_wo_tags.splitlines() if line.strip()]
        if lines:
            response = lines[0]
        else:
            response = "(No public statement provided.)"
        # Log a warning if <SAY> is missing
        if player is not None:
            if 'gs' in globals():
                gs = globals()['gs']
                gs.log_secret(f"[WARNING] LLM for {player.label()} did not provide a <SAY> block. Full response: {response}")
    clean_response = response.strip().lower()
    # --- Nomination parsing with delimiter ---
    if action_type == "nomination" or action_type == "slayer_shot":
        # Look for {NOMINATE: seat/name} or {PASS}
        match = re.search(r'\{\s*NOMINATE\s*:\s*([^}]+)\}', response, re.IGNORECASE)
        if match:
            nominee_str = match.group(1).strip()
            if nominee_str.lower() == "pass":
                return "PASS"
            # Try to match seat number or name
            if nominee_str.isdigit():
                seat_num = int(nominee_str)
                # All seat numbers are now 0-indexed
                seat_idx = seat_num
                if options:
                    valid_seats = [p.seat for p in options]
                    if seat_idx in valid_seats:
                        return seat_idx
                    else:
                        # Invalid seat, try random instead of PASS
                        return random.choice(options).seat if options else "PASS"
                return seat_idx
            # Try to match by name
            if options:
                for player in options:
                    if player.name.lower() == nominee_str.lower():
                        return player.seat
                    elif player.name.lower().startswith(nominee_str.lower()):
                        return player.seat
        # Fallback to old logic
        if "pass" in clean_response or "none" in clean_response or "no" in clean_response:
            return "PASS"
        # Try to find player names in the response
        if options:
            for player in options:
                if player.name.lower() in clean_response:
                    return player.seat
        # Try to find seat numbers in the response
        for word in clean_response.split():
            if word.isdigit():
                seat_num = int(word)
                # All seat numbers are now 0-indexed
                seat_idx = seat_num
                if options:
                    valid_seats = [p.seat for p in options]
                    if seat_idx in valid_seats:
                        return seat_idx
        # If we get here and have options, try random instead of PASS
        return random.choice(options).seat if options else "PASS"
    # --- Voting: prevent self-votes ---
    elif action_type == "voting":
        # Look for YES/NO in the response
        if player is not None and options and isinstance(options, dict):
            nominee = options.get("nominee")
            if nominee and player.seat == nominee.seat:
                # Prevent self-vote
                return "NO"
        if "yes" in clean_response or "yea" in clean_response or "aye" in clean_response:
            return "YES"
        else:
            return "NO"
    # --- Fast Voting: parse comma-delimited list of players to vote YES for ---
    elif action_type == "fast_voting":
        # Parse comma-delimited list of player names to vote YES for
        # All other players not mentioned are assumed to be NO votes
        yes_votes = []
        # Split by comma and clean up each name
        if "," in response:
            vote_parts = [part.strip() for part in response.split(",")]
        else:
            vote_parts = [response.strip()]
        
        # Extract names from each part
        for part in vote_parts:
            # Look for player names in the part
            for player_name in part.split():
                # Try to match by full name or partial name
                for p in options:
                    if (p.name.lower() == player_name.lower() or 
                        p.name.lower().startswith(player_name.lower()) or
                        player_name.lower() in p.name.lower()):
                        if p.seat not in yes_votes:
                            yes_votes.append(p.seat)
                        break
        
        # Also check for "YES" or "NO" keywords in the response
        if "yes" in clean_response or "yea" in clean_response or "aye" in clean_response:
            # If they say YES but don't specify names, assume they mean all nominees
            if not yes_votes and options:
                yes_votes = [p.seat for p in options]
        elif "no" in clean_response or "none" in clean_response:
            # If they say NO, clear any votes
            yes_votes = []
        elif "all" in clean_response:
            # If they say ALL, vote YES for all nominees (except themselves)
            if options:
                yes_votes = [p.seat for p in options if player is None or p.seat != player.seat]
        
        return yes_votes
    elif action_type == "target_selection":
        for word in clean_response.split():
            if word.isdigit():
                seat_num = int(word)
                # All seat numbers are now 0-indexed
                seat_idx = seat_num
                if options:
                    valid_seats = [p.seat for p in options]
                    if seat_idx in valid_seats:
                        return seat_idx
                    else:
                        # Invalid seat, use random fallback
                        return random.choice(options).seat if options else 1
                else:
                    return seat_idx
        return random.choice(options).seat if options else 1
    elif action_type == "discussion":
        return response
    return response

# --- Core Enums & Dataclasses ---
class Alignment(Enum):
    TOWNSFOLK = "townsfolk"
    OUTSIDER  = "outsider"
    MINION    = "minion"
    DEMON     = "demon"

@dataclass(frozen=True)
class Role:
    name: str
    alignment: Alignment
    ability_desc: str
    first_night: bool = False
    other_nights: bool = False

@dataclass
class Player:
    seat: int
    name: str
    role: Role
    alive: bool = True
    poisoned: bool = False
    drunk: bool = False
    poisoned_turns: int = 0
    # Bad Moon Rising additions
    death_count: int = 0  # Track how many times player has "died" (for Zombuul, Fool, etc.)
    can_die: bool = True  # Can be set to False to prevent death (Pacifist, Devil's Advocate)
    drunk_until_day: int = 0  # Track when drunkenness ends (Courtier, Minstrel)
    memory: Dict[str, Any] = field(default_factory=dict)  # All info learned, as dict of dicts
    scratchpad: str = ""  # LLM chain-of-thought, cleared after each LLM action
    # Hidden state that is NOT shown to the player in prompts
    hidden_state: Dict[str, Any] = field(default_factory=dict)  # Internal game state not visible to player
    def label(self): return f"{self.name} (Seat {self.seat})"

# CLI output = print statements in your terminal/console (no web interface needed)

# --- LLM Integration Notes ---
"""
This engine will require LLM integration at the following points:

1. Player Decision-Making:
   - Night ability target selection (Fortune Teller, Poisoner, Imp, etc.)
   - Day ability usage (Slayer, etc.)
   - Nominations and voting

2. Player Communication:
   - Day discussions
   - Sharing information
   - Arguments for/against nominations

3. Required LLM Prompt Components:
   - Player's role and ability
   - Public information (deaths, nominations, etc.)
   - Private information (night ability results)
   - Current game state (day number, alive players)
   - Storyteller guidance (optional)

All places requiring LLM integration are marked with:
   # PLACEHOLDER: In a real implementation, this would be an LLM decision
   # TODO: Replace with LLM-based [specific action]
"""

class Phase(Enum):
    SETUP = auto()
    FIRST_NIGHT = auto()
    NIGHT = auto()
    DAY_DISCUSSION = auto()
    DAY_ACTIONS = auto()  # Phase for Moonchild (Gossip now handled during day discussion)
    NOMINATIONS = auto()
    VOTING = auto()
    EXECUTION = auto()
    END = auto()

@dataclass
class GameState:
    players: List[Player]
    phase: 'Phase' = None
    day: int = 0
    storyteller_log: List[str] = field(default_factory=list)
    public_log: List[dict] = field(default_factory=list)  # Now stores dicts with phase_tick_id
    memory: Dict[str, Any] = field(default_factory=dict)  # Game-level memory (not player-specific)
    phase_tick_id: str = ""  # Tracks current phase for log tagging
    # XML logging fields
    xml_log: List[dict] = field(default_factory=list)  # Structured XML log entries
    current_action_id: int = 0  # Unique ID for each action
    character_set: int = 1  # 1=Trouble Brewing, 2=Bad Moon Rising, 3=Both
    
    def log_secret(self, m): self.storyteller_log.append(m)
    def log_public(self, m):
        # Add phase_tick_id to each public log entry
        self.public_log.append({"msg": m, "phase_tick_id": self.phase_tick_id})
        print_colored(m, 'PUBLIC')
        if DEBUG_ALL_LOGS:
            print_colored(m, 'PUBLIC')
    
    def log_xml(self, entry_type: str, content: str, **attributes):
        """Log an entry in XML format"""
        self.current_action_id += 1
        entry = {
            "id": self.current_action_id,
            "type": entry_type,
            "content": content,
            "phase": self.phase.name if self.phase else "unknown",
            "day": self.day,
            "phase_tick_id": self.phase_tick_id,
            "attributes": attributes
        }
        self.xml_log.append(entry)
    
    def log_llm_prompt(self, player: "Player", action_type: str, prompt_content: str, **attributes):
        """Log an LLM prompt in XML format"""
        # Add distinct header with day, player info, and action type
        day_info = f"Day {self.day}" if self.phase in [Phase.DAY_DISCUSSION, Phase.NOMINATIONS, Phase.VOTING, Phase.EXECUTION] else f"Night {self.day}"
        header = f"=== {day_info} - {player.name} (Seat {player.seat}) - {action_type.upper()} ACTION ===\n"
        
        # Add line breaks for clearer delineation between prompt parts
        formatted_content = header + prompt_content.replace("SYSTEM:", "\n--- SYSTEM ---\nSYSTEM:").replace("USER:", "\n--- USER ---\nUSER:").replace("ASSISTANT:", "\n--- ASSISTANT ---\nASSISTANT:")
        
        self.log_xml("llm_prompt", formatted_content, 
                     player_name=player.name, 
                     player_seat=player.seat,
                     action_type=action_type,
                     **attributes)
    
    def log_llm_response(self, player: "Player", action_type: str, response_content: str, **attributes):
        """Log an LLM response in XML format"""
        self.log_xml("llm_response", response_content,
                     player_name=player.name,
                     player_seat=player.seat,
                     action_type=action_type,
                     **attributes)
    
    def log_target_selection(self, player: "Player", action_type: str, target: "Player", **attributes):
        """Log a target selection in XML format"""
        self.log_xml("target_selection", f"{player.name} (Seat {player.seat}) selected {target.name} (Seat {target.seat})",
                     player_name=player.name,
                     player_seat=player.seat,
                     target_name=target.name,
                     target_seat=target.seat,
                     action_type=action_type,
                     **attributes)
    
    def log_phase_start(self, phase_name: str):
        """Log the start of a game phase"""
        self.log_xml("phase_start", f"Starting {phase_name}", phase_name=phase_name)
    
    def log_phase_end(self, phase_name: str):
        """Log the end of a game phase"""
        self.log_xml("phase_end", f"Ending {phase_name}", phase_name=phase_name)
    
    def log_action_start(self, action_type: str, player: "Player" = None, **attributes):
        """Log the start of a player action"""
        player_info = f" by {player.name} (Seat {player.seat})" if player else ""
        self.log_xml("action_start", f"Starting {action_type}{player_info}", 
                     action_type=action_type,
                     player_name=player.name if player else None,
                     player_seat=player.seat if player else None,
                     **attributes)
    
    def log_action_end(self, action_type: str, result: str, player: "Player" = None, **attributes):
        """Log the end of a player action with result"""
        player_info = f" by {player.name} (Seat {player.seat})" if player else ""
        self.log_xml("action_end", f"Ending {action_type}{player_info}: {result}",
                     action_type=action_type,
                     result=result,
                     player_name=player.name if player else None,
                     player_seat=player.seat if player else None,
                     **attributes)
    
    def set_phase_tick(self, phase_name):
        self.phase_tick_id = phase_name
    def get_public_log_since(self, last_phase_tick_id):
        # Return all public log entries after the given phase_tick_id
        found = last_phase_tick_id is None
        result = []
        for entry in self.public_log:
            if found:
                result.append(entry["msg"])
            elif entry["phase_tick_id"] == last_phase_tick_id:
                found = True
        return result
    def tag_memory(self, key, value):
        # Tag memory with current day/night for LLM prompt assembly
        tag = f"Day {self.day}" if self.phase in [Phase.DAY_DISCUSSION, Phase.NOMINATIONS, Phase.VOTING, Phase.EXECUTION] else f"Night {self.day}"
        self.memory[key] = {"tag": tag, "value": value}

# --- Role List (Trouble Brewing) ---
# Imported from original code
TB_ROLES: List[Role] = [
    # Townsfolk  (12)
    Role("Washerwoman",   Alignment.TOWNSFOLK, "You start knowing that 1 of 2 players is a particular Townsfolk.", first_night=True),
    Role("Librarian",     Alignment.TOWNSFOLK, "You start knowing that 1 of 2 players is a particular Outsider. (Or that zero are in play.)", first_night=True),
    Role("Investigator",  Alignment.TOWNSFOLK, "You start with knowledge that one of two players is a particular Minion. You will be told that either [player x] or [player y] is a [type of minion]", first_night=True),
    Role("Chef",          Alignment.TOWNSFOLK, "You start knowing how many adjacent 'pairs' of evil players there were at the beginning of the game, including players that might register as evil.", first_night=True),
    Role("Empath",        Alignment.TOWNSFOLK, "Each night, you learn how many of your 2 alive neighbours are evil.", first_night=True, other_nights=True),
    Role("Fortune Teller",Alignment.TOWNSFOLK, "Each night, choose 2 players: you learn if either is a Demon. One of the good players will show up as a demon when you check them (they are your red herring)."),
    Role("Undertaker",    Alignment.TOWNSFOLK, "Each night*, you learn the role of the player who died by execution today.", other_nights=True),
    Role("Monk",          Alignment.TOWNSFOLK, "Each night*, choose a player (not yourself): they are safe from the Demon tonight.", other_nights=True),
    Role("Ravenkeeper",   Alignment.TOWNSFOLK, "If you die at night, you are woken to choose a player: you learn their character."),
    Role("Slayer",        Alignment.TOWNSFOLK, "Once per game, during the day, publicly choose a player: if they are the Demon, they die."),
    Role("Soldier",       Alignment.TOWNSFOLK, "You are safe from the Demon."),
    Role("Virgin",        Alignment.TOWNSFOLK, "The 1st time you are nominated, if the nominator is a Townsfolk, they are executed immediately."),
    Role("Mayor",         Alignment.TOWNSFOLK, "If only 3 players live & no execution occurs, your team wins. If you die at night, another player might die instead."),
    # Outsiders  (4)
    Role("Saint",  Alignment.OUTSIDER, "If you die by execution, your team loses."),
    Role("Butler", Alignment.OUTSIDER, "Each night, choose a player (not yourself): tomorrow, you may only vote if they are voting too.", first_night=True, other_nights=True),
    Role("Drunk",  Alignment.OUTSIDER, "You do not know you are the Drunk. You think you are a Townsfolk character, but you are not."),
    Role("Recluse",Alignment.OUTSIDER, "You might register as evil & as a Minion or Demon, even if dead."),
    # Minions    (4)
    Role("Poisoner",      Alignment.MINION, "Each night, choose a player: they are poisoned tonight and tomorrow day.", first_night=True, other_nights=True),
    Role("Baron",         Alignment.MINION, "There are extra Outsiders in play. [+2 Outsiders]"),
    Role("Spy",           Alignment.MINION, "Each night, you see the Grimoire. You might register as good & as a Townsfolk or Outsider, even if dead.", first_night=True, other_nights=True),
    Role("Scarlet Woman", Alignment.MINION, "If there are 5 or more players alive & the Demon dies, you become the Demon."),
    # Demon      (1)
    Role("Imp", Alignment.DEMON, "Each night*, choose a player: they die. If you kill yourself this way, a Minion becomes the Imp.", other_nights=True),
]

# --- Role List (Bad Moon Rising) ---
BMR_ROLES: List[Role] = [
    # Townsfolk  (13)
    Role("Grandparent",   Alignment.TOWNSFOLK, "You start knowing a good player & character. If the Demon kills them, you die too.", first_night=True),
            Role("Sailor",        Alignment.TOWNSFOLK, "Each night, choose a living player. Either you or they will become drunk until dusk (this is random and unknown to you). You can not die.", other_nights=True),
    Role("Housekeeper",   Alignment.TOWNSFOLK, "Each night, choose 2 alive players (not yourself): you learn how many woke tonight due to their ability.", other_nights=True),
    Role("Exorcist",      Alignment.TOWNSFOLK, "Each night*, choose a player (different to last night): if you choose the Demon, the Demon learns who you but does not wake tonight. You are not told whether or not you chose the demon, so you do not get information this way.", other_nights=True),
    Role("Innkeeper",     Alignment.TOWNSFOLK, "Each night*, choose 2 players: they can not die tonight, but 1 is drunk until dusk.", other_nights=True),
    Role("Gambler",       Alignment.TOWNSFOLK, "Each night*, choose a player & guess their character: if you guess wrong, you die.", other_nights=True),
    Role("Gossip",        Alignment.TOWNSFOLK, "Each day, you may make a public statement. Tonight, if it was true, a player dies."),
    Role("Courtier",      Alignment.TOWNSFOLK, "Once per game, at night, choose a character: they are drunk for 3 nights & 3 days.", other_nights=True),
    Role("Professor",     Alignment.TOWNSFOLK, "Once per game, at night*, choose a dead player: if they are a Townsfolk, they are resurrected.", other_nights=True),
    Role("Minstrel",      Alignment.TOWNSFOLK, "When a Minion dies by execution, all other players (except Travellers) are drunk until dusk tomorrow."),
    Role("Herbalist",     Alignment.TOWNSFOLK, "If both your alive neighbours are good, they can't die."),
    Role("Pacifist",      Alignment.TOWNSFOLK, "Executed good players might not die."),
    Role("Fool",          Alignment.TOWNSFOLK, "The first time you die, you don't."),
    # Outsiders  (4)
    Role("Tinker",        Alignment.OUTSIDER, "You might die at any time."),
    Role("Moonchild",     Alignment.OUTSIDER, "When you learn that you died, publicly choose 1 alive player. Tonight, if it was a good player, they die."),
    Role("Goon",          Alignment.OUTSIDER, "Each night, the 1st player to choose you with their ability is drunk until dusk. You become their alignment."),
    Role("Lunatic",       Alignment.OUTSIDER, "You think you are a Demon, but you are not. The Demon knows who you are & who you choose at night."),
    # Minions    (4)
    Role("Capo Crimini",  Alignment.MINION, "You start knowing which Outsiders are in play. If 1 died today, choose a player tonight: they die. [âˆ’1 or +1 Outsider]", first_night=True, other_nights=True),
    Role("Devil's Advocate", Alignment.MINION, "Each night, choose a living player (different to last night): if executed tomorrow, they don't die.", other_nights=True),
    Role("Assassin",      Alignment.MINION, "Once per game, at night*, choose a player: they die, even if for some reason they could not.", other_nights=True),
    Role("Mastermind",    Alignment.MINION, "If the Demon dies by execution (ending the game), play for 1 more day. If a player is then executed, their team loses."),
    # Demons     (4)
    Role("Zombuul",       Alignment.DEMON, "Each night*, if no-one died today, choose a player: they die. The 1st time you die, you live but register as dead.", other_nights=True),
    Role("Pukka",         Alignment.DEMON, "Each night, choose a player: they are poisoned. The previously poisoned player dies then becomes healthy.", first_night=True, other_nights=True),
    Role("Shabaloth",     Alignment.DEMON, "Each night*, choose 2 players: they die. A dead player you chose last night might be regurgitated.", other_nights=True),
    Role("Po",            Alignment.DEMON, "Each night*, you may choose a player: they die. If your last choice was no-one, choose 3 players tonight.", other_nights=True),
]

# Combine both character sets
ALL_ROLES = TB_ROLES + BMR_ROLES
ROLE_BY_NAME = {r.name: r for r in ALL_ROLES}

# Role lists for each alignment (from both character sets)
TOWNSFOLK  = [r for r in ALL_ROLES if r.alignment is Alignment.TOWNSFOLK]
OUTSIDERS  = [r for r in ALL_ROLES if r.alignment is Alignment.OUTSIDER]
MINIONS    = [r for r in ALL_ROLES if r.alignment is Alignment.MINION]
DEMONS     = [r for r in ALL_ROLES if r.alignment is Alignment.DEMON]

# Character set specific lists
TB_TOWNSFOLK = [r for r in TB_ROLES if r.alignment is Alignment.TOWNSFOLK]
TB_OUTSIDERS = [r for r in TB_ROLES if r.alignment is Alignment.OUTSIDER]
TB_MINIONS = [r for r in TB_ROLES if r.alignment is Alignment.MINION]
TB_DEMONS = [r for r in TB_ROLES if r.alignment is Alignment.DEMON]

BMR_TOWNSFOLK = [r for r in BMR_ROLES if r.alignment is Alignment.TOWNSFOLK]
BMR_OUTSIDERS = [r for r in BMR_ROLES if r.alignment is Alignment.OUTSIDER]
BMR_MINIONS = [r for r in BMR_ROLES if r.alignment is Alignment.MINION]
BMR_DEMONS = [r for r in BMR_ROLES if r.alignment is Alignment.DEMON]

# --- Poison / Drunk Helpers ---
def is_sober_trustworthy(pl: Player) -> bool:
    """True if the player is NOT drunk or currently poisoned."""
    return pl.poisoned_turns == 0 and not pl.drunk

def mark_poisoned(target: Player, nights: int = 1, source: str = "Poisoner"):
    """Applies poisoning for <nights> full night/day cycles."""
    target.poisoned = True
    target.poisoned_turns = max(target.poisoned_turns, nights)
    target.hidden_state["poisoned_by"] = source
    
    # If Pukka is the source, mark that this player was ever poisoned by Pukka
    # This ensures Pukka poison dominates even if other sources poison them later
    if source == "Pukka":
        target.hidden_state["was_ever_pukka_poisoned"] = True

def mark_drunk(target: Player, until_day: int):
    """Marks a player as drunk until the specified day."""
    target.drunk = True
    target.drunk_until_day = max(target.drunk_until_day, until_day)

def check_drunkenness_expiry(gs: GameState):
    """Check if any players' drunkenness should expire."""
    for player in gs.players:
        if player.drunk and player.drunk_until_day <= gs.day:
            player.drunk = False
            player.drunk_until_day = 0
            gs.log_secret(f"(Drunkenness ends) {player.label()} is no longer drunk.")

def can_target_player(target: Player, allow_dead: bool = False) -> bool:
    """Check if a player can be targeted by abilities."""
    if allow_dead:
        return True  # Can target dead players (for Professor resurrection, etc.)
    
    # Zombuul who are "dead for targeting" cannot be targeted even if they're secretly "alive" as a "dead" zombuul
    if (target.role.name == "Zombuul" and 
        target.hidden_state.get("zombuul_dead_for_targeting", False)):
        return False
    
    return target.alive  # Default: only target living players

def get_targetable_players(gs: GameState, allow_dead: bool = False, exclude_self: Player = None) -> List[Player]:
    """Get list of players that can be targeted."""
    targets = []
    for player in gs.players:
        if exclude_self and player == exclude_self:
            continue
        if can_target_player(player, allow_dead):
            targets.append(player)
    return targets

def get_targeting_description(allow_dead: bool = False) -> str:
    """Get a description of what players can be targeted."""
    if allow_dead:
        return "all players (including dead players)"
    else:
        return "living players only"

def attempt_kill_player(gs: GameState, target: Player, killer: str = "unknown") -> bool:
    """Attempt to kill a player, respecting death prevention abilities."""
    # Check if player is already dead
    if not target.alive:
        gs.log_secret(f"{target.label()} is already dead, cannot be killed by {killer}.")
        return False
    
    # Check for protection abilities
    if not target.can_die:
        gs.log_secret(f"{target.label()} cannot die (protected by ability).")
        return False
    
    # Check for Monk protection
    if "protected_by_monk" in target.hidden_state:
        gs.log_secret(f"{target.label()} cannot die (protected by Monk).")
        return False
    
    # Check for Innkeeper protection
    if "protected_by_innkeeper" in target.hidden_state:
        gs.log_secret(f"{target.label()} cannot die (protected by Innkeeper).")
        return False
    
    # Check for Herbalist protection (if both neighbors are good)
    if target.role.name in ["Herbalist"]:
        # Get neighbors (assuming circular seating)
        n = len(gs.players)
        left_neighbor = gs.players[(target.seat - 1) % n]
        right_neighbor = gs.players[(target.seat + 1) % n]
        
        if (left_neighbor.alive and left_neighbor.role.alignment in {Alignment.TOWNSFOLK, Alignment.OUTSIDER} and
            right_neighbor.alive and right_neighbor.role.alignment in {Alignment.TOWNSFOLK, Alignment.OUTSIDER}):
            gs.log_secret(f"{target.label()} cannot die (protected by Herbalist - both neighbors are good).")
            return False
    
    target.death_count += 1
    
    # Handle special death mechanics
    if target.role.name == "Fool" and target.death_count == 1:
        gs.log_secret(f"Fool {target.label()} dies for the first time but doesn't actually die!")
        return False
    elif target.role.name == "Zombuul" and target.death_count == 1:
        gs.log_secret(f"Zombuul {target.label()} dies for the first time but continues living (registers as dead)!")
        # Zombuul stays alive but registers as dead for targeting purposes
        target.hidden_state["zombuul_dead_for_targeting"] = True
        return False
    elif target.role.name == "Zombuul" and target.death_count == 2:
        gs.log_secret(f"Zombuul {target.label()} dies for the second time and actually dies!")
        # Zombuul actually dies on second death
        target.alive = False
        target.memory["last_alive_day"] = gs.day
        target.hidden_state["died_night"] = gs.day  # Track which night they died (for Shabaloth regurgitation)
        
        gs.log_secret(f"{target.label()} was killed by {killer}.")
        return True
    
    # Normal death
    target.alive = False
    target.memory["last_alive_day"] = gs.day  # Track when they were last alive
    target.hidden_state["died_night"] = gs.day  # Track which night they died (for Shabaloth regurgitation)
    
    gs.log_secret(f"{target.label()} was killed by {killer}.")
    return True

def resolve_ability(player: Player, normal_fn, drunk_fn=None):
    """
    Resolves a character's ability based on their drunk/poisoned state.
    
    Args:
        player: The player whose ability is being used
        normal_fn: Function to call if player is sober/trustworthy
        drunk_fn: Function to call if player is drunk/poisoned (default: return None)
        
    Returns:
        Result of the appropriate function
    """
    if is_sober_trustworthy(player):
        return normal_fn()
    else:
        # If no drunk_fn provided, return None
        return drunk_fn() if drunk_fn else None

def setup_game(names: List[str], character_set: int = 1, print_stats: bool = False) -> GameState:
    """
    Sets up a Trouble Brewing game for 5â€“15 players, including Baron logic for Outsiders.
    
    Args:
        names: List of player names
        character_set: 1=Trouble Brewing, 2=Bad Moon Rising, 3=Both
        print_stats: If True, print prompt/usage statistics after setup
    """
    # Set global flag for print_statistics
    global PRINT_STATISTICS
    PRINT_STATISTICS = print_stats
    print_colored(f"[DEBUG] Set global PRINT_STATISTICS to {print_stats}", 'DEBUG')
    
    n = len(names)
    assert 5 <= n <= 15, "Player count must be 5â€“15."
    names = names[:]
    random.shuffle(names)

    # Set base distribution by player count
    base_town, base_outsider, base_minion, base_demon = get_base_role_distribution(n)
    # Determine character set based on selection and player count
    if character_set == 1:
        # Trouble Brewing only
        available_townsfolk = TB_TOWNSFOLK
        available_outsiders = TB_OUTSIDERS
        available_minions = TB_MINIONS
        available_demons = TB_DEMONS
    elif character_set == 2:
        # Bad Moon Rising only
        available_townsfolk = BMR_TOWNSFOLK
        available_outsiders = BMR_OUTSIDERS
        available_minions = BMR_MINIONS
        available_demons = BMR_DEMONS
    else:
        # Both character sets
        available_townsfolk = TOWNSFOLK
        available_outsiders = OUTSIDERS
        available_minions = MINIONS
        available_demons = DEMONS
    
    # Select minion(s) and check for Baron and Capo Crimini
    minions = random.sample(available_minions, base_minion)
    demon = random.choice(available_demons)
    baron_in_play = any(m.name == "Baron" for m in minions)
    capo_crimini_in_play = any(m.name == "Capo Crimini" for m in minions)
    
    # Outsider count modifications
    outsider_modifier = 0
    town_modifier = 0
    
    # Baron adds +2 Outsiders, -2 Townsfolk
    if baron_in_play:
        outsider_modifier += 2
        town_modifier -= 2
    
    # Capo Crimini adds +1 or -1 Outsider (randomly chosen)
    if capo_crimini_in_play:
        capo_modifier = random.choice([-1, 1])
        outsider_modifier += capo_modifier
        town_modifier -= capo_modifier
    
    outsider_count = base_outsider + outsider_modifier
    town_count = base_town + town_modifier
    
    # Select Outsiders and Townsfolk
    outsiders = random.sample(available_outsiders, outsider_count) if outsider_count > 0 else []
    townsfolk = random.sample(available_townsfolk, town_count)
    # Build the role bag
    bag = townsfolk + outsiders + minions + [demon]
    random.shuffle(bag)
    # Assign roles to players (0-indexed seats)
    players = [Player(i, names[i], bag[i]) for i in range(n)]
    # Comment: Both names and roles are shuffled, so seat assignment is random each game.
    # Handle Drunk (secretly assign a Townsfolk role)
    drunk_fake_role = None
    for player in players:
        if player.role.name == "Drunk":
            # Drunk thinks they are a Townsfolk
            fake_role = random.choice([r for r in available_townsfolk if r not in bag])
            player.hidden_state["drunk_role"] = fake_role.name
            player.drunk = True
            drunk_fake_role = fake_role.name
    # Assign 3 bluffs to all demons (Townsfolk not in play, not the Drunk's fake role)
    # Only assign bluffs if there are 7+ players (Trouble Brewing rule)
    demons = [p for p in players if p.role.alignment is Alignment.DEMON]
    if len(players) >= 7 and demons:
        used_names = set(r.name for r in bag)
        if drunk_fake_role:
            used_names.add(drunk_fake_role)
        available_bluffs = [r for r in available_townsfolk if r.name not in used_names]
        bluffs = random.sample(available_bluffs, min(3, len(available_bluffs)))
        bluff_names = [r.name for r in bluffs]
        
        # Assign bluffs to all demons
        for demon in demons:
            demon.memory["bluffs"] = bluff_names
    
    # Create GameState
    gs = GameState(players, character_set=character_set)
    
    # Logging
    role_summary = f"Role bag: {[r.name for r in bag]}"
    seat_summary = ", ".join(f"Seat {p.seat}: {p.name} â€” {p.role.name}" for p in players)
    gs.log_secret("Setup complete â€“ roles assigned.")
    gs.log_secret(role_summary)
    gs.log_secret(seat_summary)
    # Log any Drunk players (who think they're something else)
    for p in players:
        if p.drunk:
            gs.log_secret(f"Drunk: {p.label()} thinks they are {p.hidden_state['drunk_role']}")
    # Log demon bluffs
    for demon in demons:
        if "bluffs" in demon.memory:
            gs.log_secret(f"{demon.role.name} bluffs: {demon.memory['bluffs']}")
    # Publicly announce all seats and roles (for debug/open games)
    public_seat_summary = ", ".join(f"Seat {p.seat}: {p.name}" for p in players)
    gs.log_public(f"[SEAT ASSIGNMENTS] {public_seat_summary}")
    
    # Print prompt/usage statistics if requested
    if print_stats:
        print_colored("\n=== PROMPT/USAGE STATISTICS ===", 'STORYTELLER')
        print_llm_input_stats()
    
    # Call demon_minion_info(gs) during setup to set up Lunatic and Drunk roles
    demon_minion_info(gs)
    
    return gs

# --- Main Game Loop ---
def run_game(gs: GameState):
    """
    Runs the full game loop: night, day, nominations, voting, execution, win check.
    """
    # Start with first night
    gs.phase = Phase.FIRST_NIGHT
    gs.set_phase_tick("Night 0")  # LLM: Set phase tick for logging
    
    # Main game loop
    while gs.phase != Phase.END:
        if gs.phase == Phase.FIRST_NIGHT:
            run_first_night(gs)
            gs.phase = Phase.DAY_DISCUSSION
            gs.set_phase_tick(f"Day {gs.day}")  # LLM: Set phase tick for logging
        elif gs.phase == Phase.NIGHT:
            # Check win condition before starting night
            if check_win_condition(gs):
                gs.phase = Phase.END
                continue
            print_colored(f"\n--- NIGHT {gs.day} ---", 'STORYTELLER')
            run_night(gs)
            gs.phase = Phase.DAY_DISCUSSION
            gs.set_phase_tick(f"Day {gs.day}")  # LLM: Set phase tick for logging
        elif gs.phase == Phase.DAY_DISCUSSION:
            # Check win condition before starting day discussion
            if check_win_condition(gs):
                gs.phase = Phase.END
                continue
            print_colored(f"\n--- DAY {gs.day} DISCUSSION ---", 'PUBLIC')
            gs.log_phase_start(f"day_{gs.day}_discussion")
            try:
                run_day_discussion(gs)
            except GameEndException:
                # Game was terminated early, immediately end the game by killing evil players
                gs.log_secret("Game terminated early by player - killing all evil players to end game")
                for player in gs.players:
                    if player.role.alignment in {Alignment.MINION, Alignment.DEMON} and player.alive:
                        player.alive = False
                        player.death_count += 1
                        player.hidden_state["died_night"] = "game_end"  # Track that they died due to game termination
                        gs.log_secret(f"Killed {player.label()} to end game early")
                gs.phase = Phase.END
                break
            gs.log_phase_end(f"day_{gs.day}_discussion")
            gs.phase = Phase.DAY_ACTIONS
            gs.set_phase_tick(f"Day Actions {gs.day}")  # LLM: Set phase tick for logging
        elif gs.phase == Phase.DAY_ACTIONS:
            # Check win condition before starting day actions
            if check_win_condition(gs):
                gs.phase = Phase.END
                continue
            print_colored(f"\n--- DAY {gs.day} ACTIONS ---", 'PUBLIC')
            gs.log_phase_start(f"day_{gs.day}_actions")
            try:
                run_day_actions(gs)
            except GameEndException:
                # Game was terminated early, immediately end the game by killing evil players
                gs.log_secret("Game terminated early by player - killing all evil players to end game")
                for player in gs.players:
                    if player.role.alignment in {Alignment.MINION, Alignment.DEMON} and player.alive:
                        player.alive = False
                        player.death_count += 1
                        player.hidden_state["died_night"] = "game_end"  # Track that they died due to game termination
                        gs.log_secret(f"Killed {player.label()} to end game early")
                gs.phase = Phase.END
                break
            gs.log_phase_end(f"day_{gs.day}_actions")
            gs.phase = Phase.NOMINATIONS
            gs.set_phase_tick(f"Nominations {gs.day}")  # LLM: Set phase tick for logging
        elif gs.phase == Phase.NOMINATIONS:
            # Check win condition before starting nominations
            if check_win_condition(gs):
                gs.phase = Phase.END
                continue
            print_colored(f"\n--- DAY {gs.day} NOMINATIONS ---", 'PUBLIC')
            gs.log_phase_start(f"day_{gs.day}_nominations")
            try:
                run_nominations(gs)
            except GameEndException:
                # Game was terminated early, immediately end the game by killing evil players
                gs.log_secret("Game terminated early by player - killing all evil players to end game")
                for player in gs.players:
                    if player.role.alignment in {Alignment.MINION, Alignment.DEMON} and player.alive:
                        player.alive = False
                        player.death_count += 1
                        player.hidden_state["died_night"] = "game_end"  # Track that they died due to game termination
                        gs.log_secret(f"Killed {player.label()} to end game early")
                gs.phase = Phase.END
                break
            gs.log_phase_end(f"day_{gs.day}_nominations")
            gs.phase = Phase.VOTING
            gs.set_phase_tick(f"Voting {gs.day}")  # LLM: Set phase tick for logging
        elif gs.phase == Phase.VOTING:
            # Check win condition before starting voting
            if check_win_condition(gs):
                gs.phase = Phase.END
                continue
            print_colored(f"\n--- DAY {gs.day} VOTING ---", 'PUBLIC')
            run_voting(gs)
            gs.phase = Phase.EXECUTION
            gs.set_phase_tick(f"Execution {gs.day}")  # LLM: Set phase tick for logging
        elif gs.phase == Phase.EXECUTION:
            # Check win condition before starting execution
            if check_win_condition(gs):
                gs.phase = Phase.END
                continue
            print_colored(f"\n--- DAY {gs.day} EXECUTION ---", 'PUBLIC')
            run_execution(gs)
            # Check win condition after execution, but don't override if phase is already END
            if gs.phase != Phase.END and check_win_condition(gs):
                gs.phase = Phase.END
            elif gs.phase != Phase.END:
                # Universal check: Any Moonchildren who died today and haven't used their ability yet
                for player in gs.players:
                    if (player.role.name == "Moonchild" and 
                        not player.alive and 
                        "moonchild_learned_death" not in player.memory and
                        "last_alive_day" in player.memory and 
                        player.memory["last_alive_day"] == gs.day):
                        player.memory["moonchild_learned_death"] = True
                        gs.log_secret(f"Moonchild {player.label()} learned they died today and will use their ability.")
                
                # Save interim log at the end of day 5
                if gs.day == 5:
                    save_interim_logs_to_xml(gs)
                gs.phase = Phase.NIGHT
    
    gs.log_public("Game Over!")

# --- Night/Day Phase Functions (Stubs) ---
def run_first_night(gs: GameState):
    """Run all first night abilities in the correct order."""
    gs.set_phase_tick("Night 0")  # LLM: Set phase tick for logging
    gs.log_secret("-- Dusk of the First Night (Night 0) --")
    
    # First: Give Minion/Demon info
    demon_minion_info(gs)
    
    # Assign Fortune Teller's red herring (before any abilities)
    assign_fortune_teller_red_herring(gs)
    
    # Official first night order:
    # 1. Poisoner
    # 2. Washerwoman
    # 3. Librarian
    # 4. Investigator
    # 5. Chef
    # 6. Empath
    # 7. Fortune Teller
    # 8. Butler
    # 9. Spy
    # NOTE: Imp does NOT kill on the first night (Night 0)
    # NOTE: Pukka DOES attack on the first night (Night 0)
    
    # 1. Poisoner acts first
    for player in gs.players:
        if player.role.name == "Poisoner" and player.alive:
            poisoner_ability(gs, player)
    
    # 2-9: Run other first night abilities in order
    ability_order = [
        ("Washerwoman", washerwoman_ability),
        ("Librarian", librarian_ability),
        ("Investigator", investigator_ability),
        ("Chef", chef_ability),
        ("Empath", empath_ability),
        ("Fortune Teller", fortune_teller_ability),
        ("Butler", butler_ability),
        ("Spy", spy_ability)
    ]
    
    for role_name, ability_fn in ability_order:
        for player in gs.players:
            if player.role.name == role_name and player.alive:
                ability_fn(gs, player)
    
    # Bad Moon Rising first night abilities
    bmr_first_night_order = [
        ("Grandparent", grandparent_ability),
        ("Capo Crimini", capo_crimini_ability)
    ]
    
    for role_name, ability_fn in bmr_first_night_order:
        for player in gs.players:
            if player.role.name == role_name and player.alive:
                ability_fn(gs, player)
    
    # Bad Moon Rising "Each night" abilities that should run on the first night
    bmr_each_night_order = [
        ("Sailor", sailor_ability),
        ("Housekeeper", housekeeper_ability),
        ("Devil's Advocate", devils_advocate_ability)
    ]
    
    for role_name, ability_fn in bmr_each_night_order:
        for player in gs.players:
            if player.role.name == role_name:
                # Special handling for roles that should always be woken up
                if role_name == "Sailor":
                    # Sailor should always be woken up (they cannot die and have "Each night" ability)
                    ability_fn(gs, player)
                elif player.alive:
                    # Other abilities only work if player is alive
                    ability_fn(gs, player)
    
    # BMR Demons that attack on the first night (Pukka)
    for player in gs.players:
        if player.role.name == "Pukka" and player.alive:
            run_pukka_ability(gs, player)
                
    # Poison wears off (decrement counters)
    for player in gs.players:
        if player.poisoned_turns > 0:
            player.poisoned_turns -= 1
            if player.poisoned_turns == 0:
                gs.log_secret(f"(Poison ends) {player.label()} is no longer poisoned.")
                # Check if this player was ever poisoned by Pukka (Pukka poison dominates)
                was_ever_pukka_poisoned = player.memory.get("was_ever_pukka_poisoned", False)
                if player.poisoned and was_ever_pukka_poisoned:
                    if player.alive:
                        gs.log_secret(f"{player.label()} dies from expired Pukka poison!")
                        success = attempt_kill_player(gs, player, "expired Pukka poison")
                        if success:
                            # Track this death for dawn announcement
                            if "night_deaths_this_night" not in gs.memory:
                                gs.memory["night_deaths_this_night"] = []
                            gs.memory["night_deaths_this_night"].append(player.seat)
                    else:
                        gs.log_secret(f"{player.label()} was already dead, Pukka poison expires harmlessly.")
                    # Clear the Pukka poison flag since it has now expired
                    player.memory["was_ever_pukka_poisoned"] = False
                elif player.poisoned:
                    gs.log_secret(f"{player.label()}'s poison expires harmlessly (not Pukka poison).")
    
    gs.log_secret("-- Dawn --")
    # Day 1 begins after first night (Night 0)
    gs.day = 1
    
    # Clear day death tracking for Zombuul ability
    gs.memory["killed_by_demon"] = None
    gs.memory["day_deaths"] = []
    
    gs.log_secret(f"[DEBUG] Transition to Day 1: phase={gs.phase}, day={gs.day}")
    gs.log_public(f"Day {gs.day} dawns â€“ discuss!")

def assign_fortune_teller_red_herring(gs: GameState):
    """Assign the Fortune Teller's red herring (good player who registers as demon)."""
    fortune_teller = next((p for p in gs.players if p.role.name == "Fortune Teller"), None)
    if not fortune_teller:
        return  # No Fortune Teller in play
    
    # Find good players (not the Fortune Teller)
    good_players = [p for p in gs.players 
                   if p is not fortune_teller and 
                   p.role.alignment in {Alignment.TOWNSFOLK, Alignment.OUTSIDER}]
    
    if good_players:
        red_herring = random.choice(good_players)
        # Store red herring in game state (not in Fortune Teller's memory)
        gs.memory["ft_red_herring"] = red_herring.seat
        gs.log_secret(f"Fortune Teller red herring: {red_herring.name} (Seat {red_herring.seat})")
    else:
        gs.log_secret("No suitable red herring for Fortune Teller found.")

def run_night(gs: GameState):
    """Run all regular night abilities in the correct order."""
    night_num = gs.day
    gs.set_phase_tick(f"Night {night_num}")  # LLM: Set phase tick for logging
    gs.log_secret(f"-- Dusk of Night {night_num} --")
    gs.log_secret(f"Start of night: phase={gs.phase}, day={gs.day}")
    
    # Check for drunkenness expiry at dusk
    check_drunkenness_expiry(gs)
    
    # Official night order (not for Bad Moon Rising)
    # 1. Poisoner
    # 2. Monk
    # 3. (Scarlet Woman - passive)
    # 4. Demon
    # 5. Ravenkeeper (only on death)
    # 6. Undertaker
    # 7. Empath
    # 8. Fortune Teller
    # 9. Butler
    # 10. Spy
    
    # Clear night memory and protections
    gs.memory["night_number"] = night_num
    for player in gs.players:
        # Clear Monk protection each night
        if "protected_by_monk" in player.hidden_state:
            del player.hidden_state["protected_by_monk"]
        # Clear Innkeeper protection each night
        if "protected_by_innkeeper" in player.hidden_state:
            del player.hidden_state["protected_by_innkeeper"]
        # Clear Gossip daily usage flag each night (so they can use it again tomorrow)
        if "gossip_used_today" in player.memory:
            del player.memory["gossip_used_today"]
        
        # Check for expired Devil's Advocate protections (stored in hidden state)
        if "devils_advocate_protection" in player.hidden_state:
            protection_data = player.hidden_state["devils_advocate_protection"]
            if protection_data["expires_after_day"] <= gs.day:
                # Protection has expired, restore player's ability to die
                player.can_die = True
                gs.log_secret(f"Devil's Advocate protection for {player.label()} has expired.")
                # Clear the expired protection data
                del player.hidden_state["devils_advocate_protection"]
    
    # Clear Goon targeting flags
    clear_goon_targeting(gs)
    
    # Process Gossip statements from today
    for player in gs.players:
        if player.role.name == "Gossip" and player.alive and "gossip_statement" in player.memory:
            statement_data = player.memory["gossip_statement"]
            if statement_data.get("day") == gs.day:  # Only process today's statements
                statement = statement_data["statement"]
                
                # Evaluate the statement
                is_true = evaluate_gossip_statement(gs, statement)
                
                # Store the result
                player.memory["gossip_statement"]["is_true"] = is_true
                player.memory["gossip_statement"]["evaluated"] = True
                
                gs.log_secret(f"Gossip {player.label()} statement '{statement}' evaluated as: {is_true}")
                
                # If true, mark for death tonight
                if is_true:
                    gs.memory["gossip_kill_target"] = player
                    gs.log_secret(f"Gossip {player.label()} made a true statement - will kill someone tonight")
    
    # 1. Poisoner
    for player in gs.players:
        if player.role.name == "Poisoner" and player.alive:
            poisoner_ability(gs, player)
    
    # 2. Monk
    for player in gs.players:
        if player.role.name == "Monk" and player.alive:
            monk_ability(gs, player)
    
    # 3. (Scarlet Woman - passive, handled in Imp kill)
    
    # 4. Demons - kills on all regular nights (Night 1+)
    # Check if demon is blocked by Exorcist
    demon_blocked = gs.memory.get("demon_blocked_tonight", False)
    if demon_blocked:
        gs.log_secret("Demon is blocked by Exorcist tonight - no demon kills.")
        # Clear the blocking flag for next night
        del gs.memory["demon_blocked_tonight"]
    else:
        demons = [p for p in gs.players if p.role.alignment == Alignment.DEMON and p.alive]
        for demon in demons:
            if demon.role.name == "Imp":
                run_imp_ability(gs, demon)
            # Note: BMR demons (Zombuul, Pukka, Shabaloth, Po) are handled in the BMR ability order below to maintain proper night sequence and prevent duplicate calls
    
    # 5. Ravenkeeper (activates on death this night)
    killed_player = gs.memory.get("killed_by_demon")
    if killed_player and killed_player.role.name == "Ravenkeeper":
        gs.log_secret(f"Ravenkeeper {killed_player.label()} was killed! Their ability activates.")
        ravenkeeper_ability(gs, killed_player)
    

    
    # 6. Undertaker
    for player in gs.players:
        if player.role.name == "Undertaker" and player.alive:
            undertaker_ability(gs, player)
    
    # 7-10: Run other night abilities in order
    ability_order = [
        ("Empath", empath_ability),
        ("Fortune Teller", fortune_teller_ability),
        ("Butler", butler_ability),
        ("Spy", spy_ability)
    ]
    
    for role_name, ability_fn in ability_order:
        for player in gs.players:
            if player.role.name == role_name:
                # Spy sees grimoire every night regardless of alive status
                if role_name == "Spy":
                    ability_fn(gs, player)
                # Other abilities only work if player is alive
                elif player.alive:
                    ability_fn(gs, player)
    
    # 11. Bad Moon Rising night abilities (in correct order)
    bmr_ability_order = [
        ("Minstrel", minstrel_ability),
        ("Sailor", sailor_ability),
        ("Innkeeper", innkeeper_ability),
        ("Courtier", courtier_ability),
        ("Gambler", gambler_ability),
        ("Devil's Advocate", devils_advocate_ability),
        ("Lunatic", handle_lunatic_night_action),
        ("Exorcist", exorcist_ability),
        ("Zombuul", run_zombuul_ability),
        ("Pukka", run_pukka_ability),
        ("Shabaloth", run_shabaloth_ability),
        ("Po", run_po_ability),
        ("Assassin", assassin_ability),
        ("Capo Crimini", capo_crimini_night_ability),
        ("Professor", professor_ability),
        ("Tinker", tinker_ability),
        ("Moonchild", moonchild_ability),
        ("Housekeeper", housekeeper_ability),
        ("Goon", goon_ability)
    ]
    
    # Run Bad Moon Rising abilities in order
    for role_name, ability_fn in bmr_ability_order:
        for player in gs.players:
            if player.role.name == role_name:
                # Special handling for roles that should always be woken up
                if role_name == "Sailor":
                    # Sailor should always be woken up (they cannot die and have "Each night" ability)
                    ability_fn(gs, player)
                elif role_name == "Lunatic":
                    # Handle Lunatic night action (they think they're killing someone)
                    if player.alive:
                        ability_fn(gs, player)
                elif player.alive:
                    # Other abilities only work if player is alive
                    ability_fn(gs, player)
    
    # Gossip kill (if they made a true statement today) - positioned after Professor, before Tinker
    gossip_kill_target = gs.memory.get("gossip_kill_target")
    if gossip_kill_target and gossip_kill_target.alive:  # Only kill if Gossip is still alive
        # Choose a random alive player to kill (excluding the Gossip themselves)
        potential_targets = [p for p in gs.players if p.alive and p != gossip_kill_target]
        if potential_targets:
            # Reroll once if the target would be the demon
            target = random.choice(potential_targets)
            if target.role.alignment == Alignment.DEMON:
                # Reroll to avoid killing the demon
                new_potential_targets = [p for p in potential_targets if p != target]
                if new_potential_targets:
                    target = random.choice(new_potential_targets)
                    gs.log_secret(f"Gossip kill rerolled to avoid killing the demon. New target: {target.label()}")
            
            success = attempt_kill_player(gs, target, "Gossip true statement")
            if success:
                gs.log_secret(f"Gossip {gossip_kill_target.label()} made a true statement - {target.label()} was killed!")
                gs.memory["killed_by_gossip"] = target
                # Track this death for dawn announcement
                if "night_deaths_this_night" not in gs.memory:
                    gs.memory["night_deaths_this_night"] = []
                gs.memory["night_deaths_this_night"].append(target.seat)
                gs.log_secret(f"Gossip kill successful: {target.label()} now has alive={target.alive}, last_alive_day={target.memory.get('last_alive_day', 'None')}")
            else:
                gs.log_secret(f"Gossip {gossip_kill_target.label()} made a true statement but {target.label()} could not be killed (protected)")
        
        # Clear the gossip kill target
        del gs.memory["gossip_kill_target"]
    
    # Poison wears off (decrement counters) - after all abilities are done
    for player in gs.players:
        if player.poisoned_turns > 0:
            player.poisoned_turns -= 1
            if player.poisoned_turns == 0:
                gs.log_secret(f"(Poison ends) {player.label()} is no longer poisoned.")
                # Check if this player was ever poisoned by Pukka (Pukka poison dominates)
                was_ever_pukka_poisoned = player.memory.get("was_ever_pukka_poisoned", False)
                if player.poisoned and was_ever_pukka_poisoned:
                    if player.alive:
                        gs.log_secret(f"{player.label()} dies from expired Pukka poison!")
                        success = attempt_kill_player(gs, player, "expired Pukka poison")
                        if success:
                            # Track this death for dawn announcement
                            if "night_deaths_this_night" not in gs.memory:
                                gs.memory["night_deaths_this_night"] = []
                            gs.memory["night_deaths_this_night"].append(player.seat)
                    else:
                        gs.log_secret(f"{player.label()} was already dead, Pukka poison expires harmlessly.")
                    # Clear the Pukka poison flag since it has now expired
                    player.memory["was_ever_pukka_poisoned"] = False
                elif player.poisoned:
                    gs.log_secret(f"{player.label()}'s poison expires harmlessly (not Pukka poison).")
    
    # Tinker random death chance (night)
    for player in gs.players:
        if player.role.name == "Tinker" and player.alive:
            # 15% chance per night (can be adjusted)
            if random.random() < 0.15:
                success = attempt_kill_player(gs, player, "Tinker random death")
                if success:
                    gs.log_secret(f"Tinker {player.label()} dies randomly during the night!")
                    # Track this death for dawn announcement
                    if "night_deaths_this_night" not in gs.memory:
                        gs.memory["night_deaths_this_night"] = []
                    gs.memory["night_deaths_this_night"].append(player.seat)
    
    # Process day action effects
    
    # Moonchild: If target was good, kill them
    for player in gs.players:
        if player.role.name == "Moonchild" and "moonchild_target" in player.memory:
            target_data = player.memory["moonchild_target"]
            if target_data["day"] == gs.day - 1:  # Yesterday's target
                target = next((p for p in gs.players if p.seat == target_data["target"]), None)
                if target and target.alive and target.role.alignment in {Alignment.TOWNSFOLK, Alignment.OUTSIDER}:
                    success = attempt_kill_player(gs, target, "Moonchild ability")
                    if success:
                        gs.log_secret(f"Moonchild {player.label()}'s target {target.label()} was good and dies!")
                        # This should not be public, I don't know why this was here. A death from moonchild should register at night as every other death. -- gs.log_public(f"{target.name} (Seat {target.seat}) was killed by the Moonchild's ability!")
                        # Track this death for dawn announcement
                        if "night_deaths_this_night" not in gs.memory:
                            gs.memory["night_deaths_this_night"] = []
                        gs.memory["night_deaths_this_night"].append(target.seat)
    
    # Report night deaths at dawn
    night_deaths = []
    if killed_player:
        # Diagnostic: If the killed player is still alive, log an error
        if killed_player.alive:
            gs.log_secret(f"[ERROR] Imp killed {killed_player.label()} but they are still alive!")
        else:
            night_deaths.append(killed_player)
    
    # Check for tracked night deaths (Gossip, Tinker, Moonchild, etc.)
    tracked_night_deaths = gs.memory.get("night_deaths_this_night", [])
    for seat in tracked_night_deaths:
        player = next((p for p in gs.players if p.seat == seat), None)
        if player and player not in night_deaths:
            night_deaths.append(player)
            gs.log_secret(f"Death announcement: {player.label()} died during night {gs.day} (tracked death)")
    
    # Clear the night deaths tracking for next night
    if "night_deaths_this_night" in gs.memory:
        del gs.memory["night_deaths_this_night"]
    
    # Check for any other night deaths (fallback to old method)
    # Only include players who died during this night phase, not those executed during the day
    executed_today = gs.memory.get("executed_today")
    for player in gs.players:
        if not player.alive and player not in night_deaths and player != executed_today:
            # Check if this player died during this night phase
            if "last_alive_day" in player.memory and player.memory["last_alive_day"] == gs.day:
                night_deaths.append(player)
                gs.log_secret(f"Death announcement: {player.label()} died during night {gs.day} (last_alive_day={player.memory['last_alive_day']})")
            elif not player.alive:
                gs.log_secret(f"Death announcement: {player.label()} is dead but no last_alive_day memory found")
    
    # Standardized morning death announcement
    if night_deaths:
        for dead_player in night_deaths:
            gs.log_public(f"{dead_player.name} (Seat {dead_player.seat}) died during the night!")
            
            # Check win condition immediately after each death
            if check_win_condition(gs):
                gs.phase = Phase.END
                return
    else:
        gs.log_public("No one died during the night.")
    
    # Announce resurrections at dawn
    resurrections = gs.memory.get("resurrections", [])
    if resurrections:
        for resurrection in resurrections:
            if resurrection["night"] == gs.day - 1:  # Only announce resurrections from last night
                resurrected_player = next((p for p in gs.players if p.seat == resurrection["player"]), None)
                if resurrected_player:
                    gs.log_public(f"{resurrected_player.name} (Seat {resurrected_player.seat}) has returned to life!")
                    gs.log_secret(f"Dawn announcement: {resurrected_player.label()} was resurrected by {resurrection['type']}")
        
        # Clear old resurrections
        gs.memory["resurrections"] = [r for r in resurrections if r["night"] >= gs.day - 1]
    
    # Universal check: Any Moonchildren who died and haven't used their ability yet
    for player in gs.players:
        if (player.role.name == "Moonchild" and 
            not player.alive and 
            "moonchild_learned_death" not in player.memory and
            "last_alive_day" in player.memory and 
            player.memory["last_alive_day"] == gs.day - 1):  # They died last night
            player.memory["moonchild_learned_death"] = True
            gs.log_secret(f"Moonchild {player.label()} learned they died and will use their ability.")
    
    gs.log_secret("-- Dawn --")
    # Increment day counter for next day
    gs.day += 1
    
    # Clear day death tracking for Zombuul ability
    gs.memory["killed_by_demon"] = None
    gs.memory["day_deaths"] = []
    
    gs.log_secret(f"Transition to Day {gs.day}: phase={gs.phase}, day={gs.day}")
    gs.log_public(f"Day {gs.day} dawns â€“ discuss!")
    # Check win condition after night deaths
    if check_win_condition(gs):
        gs.phase = Phase.END

def run_day_discussion(gs: GameState):
    """Players discuss what they know and form strategies."""
    gs.log_secret(f"-- Day {gs.day} Discussion --")
    
    # On Day 1, this is the first message so nobody has spoken yet
    if gs.day == 1:
        gs.log_public("Players discuss what they know... (nobody has had a chance to speak yet)")
    else:
        gs.log_public("Players discuss what they know...")
    
    all_players = gs.players  # All players, alive or dead
    for pass_no in (1, 2):
        for idx, player in enumerate(all_players):
            # Tinker random death chance (day) - only on second pass
            if pass_no == 1 and player.role.name == "Tinker" and player.alive:
                # 1% chance per player on first pass (can be adjusted)
                if random.random() < 0.01:
                    success = attempt_kill_player(gs, player, "Tinker random death")
                    if success:
                        gs.log_secret(f"Tinker {player.label()} dies randomly during the day!")
                        gs.log_public(f"{player.name} (Seat {player.seat}) died during the day!")
                        # Track this day death for Zombuul ability
                        if "day_deaths" not in gs.memory:
                            gs.memory["day_deaths"] = []
                        gs.memory["day_deaths"].append(player.seat)
                        # Check win condition immediately after Tinker death
                        if check_win_condition(gs):
                            gs.phase = Phase.END
                            return
            


            if is_human_player(player):
                print_llm_prompt_for_seat(player, f"[YOUR TURN] {player.name} (Seat {player.seat}), it's your turn to speak.", 'PROMPT')
                speech = input(f"What do you want to say? (pass {pass_no}): ").strip()
                
                # Check for early game termination
                if speech == "END END END END":
                    gs.log_public(f"{player.name}: I want to end the game now.")
                    gs.log_secret(f"Game terminated early by {player.label()}")
                    gs.phase = Phase.END
                    raise GameEndException("Game terminated early by player")
            elif is_llm_player(player):
                prompt = format_player_prompt(gs, player, "discussion")
                
                llm_response = call_gpt(prompt, label=f"Discussion (Seat {player.seat}) Pass {pass_no}")
                think = ""
                if "<think>" in llm_response.lower():
                    think_start = llm_response.lower().find("<think>") + 7
                    think_end = llm_response.lower().find("</think>")
                    if think_end > think_start:
                        think = llm_response[think_start:think_end].strip()
                player.scratchpad = think
                speech = parse_llm_response(llm_response, "discussion", player=player)
                player.scratchpad = ""
                if think:
                    gs.log_secret(f"[LLM <THINK>] {player.label()}: {think}")
            else:
                speech = f"I have nothing to share right now. (pass {pass_no})"
            # --- Detect Slayer trigger in public comment ---
            # Every Slayer shot attempt should get a public response to avoid revealing who is/isn't the Slayer
            import re
            slay_match = re.search(r'SLAYER_SHOT:\s*([A-Za-z]+)', speech, re.IGNORECASE)
            if slay_match:
                target_name = slay_match.group(1).strip()
                target = next((p for p in all_players if p.name.lower() == target_name.lower()), None)
                
                # Always attempt Slayer ability and give public response, regardless of player role/status
                if target:
                    before_alive = target.alive
                    slayer_ability(gs, player, target)
                    after_alive = target.alive
                    # Announce result: either it worked (target died) or it didn't (no effect)
                    if before_alive and not after_alive:
                        gs.log_public(f"âš¡ {player.name} attempts a Slayer shot on {target.name} (Seat {target.seat})... The shot is true! {target.name} was killed!")
                        # Check win condition immediately after successful Slayer shot
                        if check_win_condition(gs):
                            gs.phase = Phase.END
                            return
                    else:
                        gs.log_public(f"âš¡ {player.name} attempts a Slayer shot on {target.name} (Seat {target.seat})... Nothing happens.")
                else:
                    # Invalid target - still give public response
                    gs.log_public(f"âš¡ {player.name} attempts a Slayer shot on '{target_name}'... Nothing happens (invalid target).")
                
                # Still log the player's actual speech message
                gs.log_public(f"{player.name}: {speech}")
                gs.log_secret(f"{player.label()} (discussion pass {pass_no}): {speech}")
                continue  # Skip to next player
            
            # --- Detect Gossip statement in public comment ---
            # Look for {GOSSIP_CLAIM: statement} format
            gossip_match = re.search(r'\{GOSSIP_CLAIM:\s*(.*?)\}', speech, re.IGNORECASE)
            if gossip_match:
                statement = gossip_match.group(1).strip()
                
                # Only process if this player is actually the Gossip and hasn't used their ability today
                if player.role.name == "Gossip" and player.alive and not player.memory.get("gossip_used_today", False):
                    # Mark as used for today
                    player.memory["gossip_used_today"] = True
                    
                    # Store the statement (truth evaluation will happen at night)
                    player.memory["gossip_statement"] = {"statement": statement, "day": gs.day}
                    
                    gs.log_secret(f"Gossip {player.label()} makes statement: '{statement}'")
                    gs.log_public(f"ðŸ’¬ {player.name} makes a statement: '{statement}'")
                else:
                    # Either not the Gossip, or already used ability today - ignore silently
                    pass
                
                # Still log the player's actual speech message
                gs.log_public(f"{player.name}: {speech}")
                gs.log_secret(f"{player.label()} (discussion pass {pass_no}): {speech}")
                continue  # Skip to next player
            # Always log the speech to the public log before the next player acts
            gs.log_public(f"{player.name}: {speech}")
            gs.log_secret(f"{player.label()} (discussion pass {pass_no}): {speech}")

def run_nominations(gs: GameState):
    """Players nominate others for execution."""
    gs.log_secret(f"-- Day {gs.day} Nominations --")
    gs.log_public("Nominations begin...")
    # Clear nominations and execution memory at the start of nominations
    gs.memory["nominations"] = []  # Track nominations
    gs.memory["execution_nominee"] = None
    gs.memory["execution_votes"] = 0
    gs.memory["executed_today"] = None
    gs.memory["no_execution_today"] = False

    alive_players = [p for p in gs.players if p.alive]
    # Remove Zombuul who are "dead for targeting" from nomination eligibility
    nominating_players = [p for p in alive_players if not (p.role.name == "Zombuul" and p.hidden_state.get("zombuul_dead_for_targeting", False))]
    
    if len(nominating_players) < 2:
        return

    # Check if Bad Moon Rising characters are available (allows nominating dead players for Zombuul's second death)
    bmr_available = gs.character_set in [2, 3]  # 2=Bad Moon Rising, 3=Both
    
    for nominator in nominating_players:
        gs.log_secret(f"Nomination phase: {nominator.label()} (LLM: {is_llm_player(nominator)}, Human: {is_human_player(nominator)})")
        # Allow nominating dead players if Bad Moon Rising characters are available, otherwise only alive players
        if bmr_available:
            options = [p for p in gs.players if p is not nominator]
        else:
            options = [p for p in alive_players if p is not nominator]
        if not options:
            gs.log_secret(f"Nomination phase: {nominator.label()} has no valid options")
            continue
        if is_human_player(nominator):
            while True:
                print_llm_prompt_for_seat(nominator, f"[YOUR TURN] {nominator.name} (Seat {nominator.seat}), it's your turn to nominate.", 'PROMPT')
                if bmr_available:
                    print_llm_prompt_for_seat(nominator, f"Available players: {', '.join(f'{p.name} (Seat {p.seat}){" [DEAD]" if not p.alive else ""}' for p in options)}", 'PUBLIC')
                else:
                    print_llm_prompt_for_seat(nominator, f"Alive players: {', '.join(f'{p.name} (Seat {p.seat})' for p in options)}", 'PUBLIC')
                choice = input(f"Enter seat number or name to nominate (or PASS): ").strip().lower()
                
                # Check for early game termination
                if choice == "end end end end":
                    gs.log_public(f"{nominator.name}: I want to end the game now.")
                    gs.log_secret(f"Game terminated early by {nominator.label()}")
                    gs.phase = Phase.END
                    raise GameEndException("Game terminated early by player")
                
                # --- Slayer trigger ---
                if choice.startswith('slayer_shot '):
                    target_name = choice[10:].strip()
                    target = next((p for p in options if p.name.lower() == target_name.lower()), None)
                    
                    # Always attempt Slayer ability and give public response, regardless of player role/status
                    if target:
                        before_alive = target.alive
                        slayer_ability(gs, nominator, target)
                        after_alive = target.alive
                        # Announce result: either it worked (target died) or it didn't (no effect)
                        if before_alive and not after_alive:
                            gs.log_public(f"âš¡ {nominator.name} attempts a Slayer shot on {target.name} (Seat {target.seat})... The shot is true! {target.name} was killed!")
                            # Check win condition immediately after successful Slayer shot
                            if check_win_condition(gs):
                                gs.phase = Phase.END
                                return
                        else:
                            gs.log_public(f"âš¡ {nominator.name} attempts a Slayer shot on {target.name} (Seat {target.seat})... Nothing happens.")
                    else:
                        # Invalid target - still give public response
                        gs.log_public(f"âš¡ {nominator.name} attempts a Slayer shot on '{target_name}'... Nothing happens (invalid target).")
                    
                    # Log the Slayer attempt for the storyteller
                    gs.log_secret(f"Slayer attempt: {nominator.label()} tried to shoot {target_name}")
                    continue  # Skip normal nomination for this pass
                if choice in ("pass", "none", "no", ""):
                    nominee = None
                    break
                nominee = None
                try:
                    seat_num = int(choice)
                    # All seat numbers are now 0-indexed
                    seat_idx = seat_num
                    nominee = next((p for p in options if p.seat == seat_idx), None)
                except ValueError:
                    matches = [p for p in options if p.name.lower() == choice]
                    if not matches:
                        matches = [p for p in options if p.name.lower().startswith(choice)]
                    if len(matches) == 1:
                        nominee = matches[0]
                    elif len(matches) > 1:
                        print_colored(f"Ambiguous name. Matches: {', '.join(p.name for p in matches)}. Please be more specific.", 'ERROR')
                        continue
                if nominee is None:
                    print_colored("Invalid nomination. Please enter a valid seat number or player name.", 'ERROR')
                    continue
                break
            if not nominee:
                continue
        elif is_llm_player(nominator):
            prompt = format_player_prompt(gs, nominator, "nomination", options=options)
            print_llm_prompt_for_seat(nominator, f"Prompting LLM for nomination (Seat {nominator.seat})", 'PROMPT')
            # Explicitly log the nomination prompt
            prompt_content = '\n'.join([f"{m['role'].upper()}: {m['content']}" for m in prompt])
            gs.log_llm_prompt(nominator, "nomination", prompt_content, label=f"Nomination (Seat {nominator.seat})")
            llm_response = call_gpt(prompt, label=f"Nomination (Seat {nominator.seat})")
            think = ""
            if "<think>" in llm_response.lower():
                think_start = llm_response.lower().find("<think>") + 7
                think_end = llm_response.lower().find("</think>")
                if think_end > think_start:
                    think = llm_response[think_start:think_end].strip()
            nominator.scratchpad = think
            nominee_seat = parse_llm_response(llm_response, "nomination", options=options, player=nominator)
            nominator.scratchpad = ""
            gs.log_secret(f"LLM nomination response for {nominator.label()}: {llm_response}")
            gs.log_secret(f"Parsed nominee_seat: {nominee_seat}")
            if nominee_seat == "PASS":
                gs.log_secret(f"LLM {nominator.label()} chose to PASS nomination")
                continue
            nominee = next((p for p in options if p.seat == nominee_seat), None)
            if not nominee:
                gs.log_secret(f"LLM {nominator.label()} nomination failed - invalid nominee_seat: {nominee_seat}")
                continue
        else:
            if random.random() < 0.3:  # Increased from 0.5 to 0.3 (70% chance to nominate)
                continue
            nominee = random.choice(options)
        # Prevent multiple nominations for the same nominee in a single round
        # Only allow a player to be nominated once per day
        if any(n["nominee"] == nominee for n in gs.memory["nominations"]):
            # Comment: This prevents duplicate nominations for the same player in a single round
            continue
        nomination = f"{nominator.name} nominates {nominee.name} for execution."
        gs.memory["nominations"].append({"nominator": nominator, "nominee": nominee})
        gs.log_public(nomination)
        gs.log_secret(f"Nomination: {nomination}")
        if nominee.role.name == "Virgin" and nominator.role.alignment is Alignment.TOWNSFOLK and is_sober_trustworthy(nominee):
            gs.log_secret(f"Virgin ability check: nominee={nominee.name}, nominator={nominator.name}, nominator_alignment={nominator.role.alignment}, virgin_sober={is_sober_trustworthy(nominee)}")
            if not nominee.memory.get("was_nominated", False):
                nominee.memory["was_nominated"] = True
                virgin_trigger = f"The Virgin's ability activates! {nominator.name} is executed immediately!"
                gs.log_public(virgin_trigger)
                gs.log_secret(f"Virgin ability: {virgin_trigger}")
                nominator.alive = False
                nominator.hidden_state["died_night"] = "day"  # Track that they died during the day (not eligible for Shabaloth regurgitation)
                gs.memory["executed_today"] = nominator
                # Check win condition after Virgin execution
                if check_win_condition(gs):
                    gs.phase = Phase.END
                    return

def run_voting(gs: GameState):
    """Players vote on nominations."""
    gs.log_secret(f"-- Day {gs.day} Voting --")
    gs.log_public("Players vote on the nominations...")
    nominations = gs.memory.get("nominations", [])
    if not nominations:
        no_nominations = "No valid nominations to vote on."
        gs.log_public(no_nominations)
        gs.log_secret(f"Voting: {no_nominations}")
        gs.memory["no_execution_today"] = True
        gs.memory["execution_nominee"] = None
        gs.memory["execution_votes"] = 0
        return
    
    alive_players = [p for p in gs.players if p.alive]
    # Remove Zombuul who are "dead for targeting" from voting eligibility
    voting_players = [p for p in alive_players if not (p.role.name == "Zombuul" and p.hidden_state.get("zombuul_dead_for_targeting", False))]
    votes = {i: [] for i in range(len(nominations))}  # nomination index -> list of voters
    
    # --- FAST VOTING: Collect pre-registered votes from LLM players ---
    if FAST_LLM_VOTING:
        nominees = [n["nominee"] for n in nominations]
        llm_players = [p for p in voting_players if is_llm_player(p) and not is_human_player(p)]
        
        # Collect all LLM votes at once
        for llm_player in llm_players:
            prompt = format_player_prompt(gs, llm_player, "fast_voting", options={"nominees": nominees})
            # Explicitly log the fast voting prompt
            prompt_content = '\n'.join([f"{m['role'].upper()}: {m['content']}" for m in prompt])
            gs.log_llm_prompt(llm_player, "fast_voting", prompt_content, label=f"Fast Voting (Seat {llm_player.seat})")
            llm_response = call_gpt(prompt, label=f"Fast Voting (Seat {llm_player.seat})")
            
            # Parse the response to get YES votes
            yes_votes = parse_llm_response(llm_response, "fast_voting", options=nominees, player=llm_player)
            
            # Store the votes in player memory for later use
            llm_player.memory["fast_votes"] = yes_votes
            
            # Log the votes for debugging
            yes_names = [p.name for p in nominees if p.seat in yes_votes]
            gs.log_secret(f"Fast voting: {llm_player.label()} pre-registered YES votes for: {', '.join(yes_names) if yes_names else 'none'}")
    
    # --- REGULAR VOTING: Process votes in order ---
    for idx, nomination in enumerate(nominations):
        nominee = nomination["nominee"]
        nominator = nomination["nominator"]
        
        for voter in voting_players:
            # --- Dead players should not vote (ghost vote logic can be added here in the future) ---
            if not voter.alive:
                # TODO: Implement ghost vote logic here if desired
                continue
            
            # --- Butler logic: only vote if master is voting ---
            butler_info = voter.memory.get("butler")
            if butler_info and "master" in butler_info.get("data", {}):
                master_seat = butler_info["data"]["master"]
                master = next((p for p in alive_players if p.seat == master_seat), None)
                if master and master not in votes[idx]:
                    # Butler votes NO by default when master hasn't voted yet
                    vote = "NO"
                    gs.log_public(f"{voter.name} votes {vote} on {nominee.name}") # It should not reveal that the player is the butler.
                    gs.log_secret(f"{voter.label()} votes {vote} on {nominee.name} (Butler - master hasn't voted yet)")
                    continue
            
            # --- Get vote based on player type ---
            if is_human_player(voter):
                # Human players vote individually as normal
                print_llm_prompt_for_seat(voter, f"[YOUR TURN] {voter.name} (Seat {voter.seat}), vote on {nominee.name} (Seat {nominee.seat}).", 'PROMPT')
                vote = input(f"Vote YES or NO: ").strip().upper()
            elif is_llm_player(voter) and FAST_LLM_VOTING:
                # LLM players use pre-registered votes
                yes_votes = voter.memory.get("fast_votes", [])
                vote = "YES" if nominee.seat in yes_votes else "NO"
            elif is_llm_player(voter):
                # LLM players without fast voting vote individually as normal
                prompt = format_player_prompt(gs, voter, "voting", options={"nominee": nominee, "nominator": nominator})
                # Explicitly log the voting prompt
                prompt_content = '\n'.join([f"{m['role'].upper()}: {m['content']}" for m in prompt])
                gs.log_llm_prompt(voter, "voting", prompt_content, label=f"Voting (Seat {voter.seat}) for {nominee.name}")
                llm_response = call_gpt(prompt, label=f"Voting (Seat {voter.seat}) for {nominee.name}")
                think = ""
                if "<think>" in llm_response.lower():
                    think_start = llm_response.lower().find("<think>") + 7
                    think_end = llm_response.lower().find("</think>")
                    if think_end > think_start:
                        think = llm_response[think_start:think_end].strip()
                voter.scratchpad = think
                vote = parse_llm_response(llm_response, "voting", player=voter, options={"nominee": nominee, "nominator": nominator})
                # --- Diagnostic: Log if LLM votes to execute themselves ---
                if nominee and voter.seat == nominee.seat and vote == "YES":
                    gs.log_secret(f"[WARNING] LLM {voter.label()} voted to execute themselves. Prompt: {prompt}\nResponse: {llm_response}")
                voter.scratchpad = ""
            else:
                # Random players
                vote = "YES" if random.random() < 0.5 else "NO"
            
            # --- Log the vote ---
            if nominee:
                gs.log_public(f"{voter.name} votes {vote} on {nominee.name}")
                gs.log_secret(f"{voter.label()} votes {vote} on {nominee.name}")
            
            # --- Record YES votes ---
            if vote == "YES":
                votes[idx].append(voter)
    
    # --- Log the number of votes for each nominee ---
    for idx, nomination in enumerate(nominations):
        nominee = nomination["nominee"]
        num_votes = len(votes[idx])
        gs.log_public(f"{nominee.name} received {num_votes} vote(s).")
    
    # --- Determine who (if anyone) is executed ---
    max_votes = 0
    executed_nominee = None
    tie = False
    for idx, voters in votes.items():
        if len(voters) > max_votes:
            max_votes = len(voters)
            executed_nominee = nominations[idx]["nominee"]
            tie = False
        elif len(voters) == max_votes and max_votes > 0:
            tie = True
    
    majority = math.ceil(len(voting_players) / 2)
    gs.log_secret(f"Voting debug: max_votes={max_votes}, majority={majority}, tie={tie}, nominee={executed_nominee.name if executed_nominee else 'None'}")
    if executed_nominee and max_votes >= majority and not tie and executed_nominee.alive:
        gs.memory["execution_nominee"] = executed_nominee
        gs.memory["execution_votes"] = max_votes
        gs.memory["no_execution_today"] = False
        gs.log_secret(f"Voting: {executed_nominee.name} receives {max_votes} votes and will be executed.")
        gs.log_public(f"{executed_nominee.name} (Seat {executed_nominee.seat}) receives {max_votes} votes and will be executed.")
    else:
        if tie:
            no_execution = f"There was a tie for execution (multiple nominees received {max_votes} votes)."
        elif executed_nominee and not executed_nominee.alive:
            no_execution = f"{executed_nominee.name} received enough votes but is already dead."
        else:
            no_execution = f"No nomination received enough votes (majority required: {majority})."
        gs.log_public(no_execution)
        gs.log_secret(f"Voting: {no_execution}")
        gs.memory["no_execution_today"] = True
        gs.memory["execution_nominee"] = None
        gs.memory["execution_votes"] = 0

def run_execution(gs: GameState):
    """Execute the nominated player with the most votes."""
    gs.log_secret(f"-- Day {gs.day} Execution --")
    executed = None
    alive_players = [p for p in gs.players if p.alive]
    if not alive_players:
        no_players = "No one is alive to be executed."
        gs.log_public(no_players)
        gs.log_secret(f"Execution: {no_players}")
        gs.memory["no_execution_today"] = True
        gs.memory["executed_today"] = None
        if check_win_condition(gs):
            gs.phase = Phase.END
        else:
            gs.phase = Phase.NIGHT
        return
    
    execution_nominee = gs.memory.get("execution_nominee")
    execution_votes = gs.memory.get("execution_votes", 0)
    
    # Debug logging
    gs.log_secret(f"Execution debug: nominee={execution_nominee.name if execution_nominee else 'None'}, votes={execution_votes}, alive={execution_nominee.alive if execution_nominee else 'N/A'}")
    if execution_nominee and execution_nominee.alive:
        # Check if execution can be prevented
        execution_failure_message = f"{execution_nominee.name} (Seat {execution_nominee.seat}) was executed... but the execution mysteriously failed."
        if not execution_nominee.can_die:
            gs.log_secret(f"{execution_nominee.label()} cannot be executed (protected by ability).")
            no_execution = execution_failure_message
            gs.memory["no_execution_today"] = True
            gs.memory["executed_today"] = None
            gs.log_public(no_execution)
            gs.log_secret(f"Execution prevented: {no_execution}")
        # Check for Pacifist protection (good players might not die when executed)
        elif execution_nominee.role.alignment in {Alignment.TOWNSFOLK, Alignment.OUTSIDER}:
            pacifists = [p for p in gs.players if p.role.name == "Pacifist" and p.alive]
            if pacifists and random.random() < 0.5:  # 50% chance for Pacifist to prevent execution
                gs.log_secret(f"Pacifist prevents execution of good player {execution_nominee.label()}.")
                no_execution = execution_failure_message
                gs.memory["no_execution_today"] = True
                gs.memory["executed_today"] = None
                gs.log_public(no_execution)
                gs.log_secret(f"Pacifist execution prevented: {no_execution}")
            else:
                executed = execution_nominee
                executed.death_count += 1
        else:
            executed = execution_nominee
            executed.death_count += 1
        
        # Now handle the execution logic for any player that wasn't protected
        if executed:
            gs.log_secret(f"Execution proceeding for {executed.label()} (death_count={executed.death_count})")
            
            # Handle special execution mechanics first
            execution_prevented = False
            if executed.role.name == "Fool" and executed.death_count == 1:
                gs.log_secret(f"Fool {executed.label()} was executed for the first time but doesn't actually die!")
                execution_prevented = True
            elif executed.role.name == "Zombuul" and executed.death_count == 1:
                gs.log_secret(f"Zombuul {executed.label()} was executed for the first time but continues living (registers as dead)!")
                # Zombuul stays alive for win condition purposes but registers as dead for targeting
                executed.hidden_state["zombuul_dead_for_targeting"] = True
                # Don't set execution_prevented - they register as executed but don't die
            
            # Handle execution prevention
            if execution_prevented:
                no_execution = f"{executed.name} (Seat {executed.seat}) was executed... but the execution mysteriously failed."
                gs.memory["no_execution_today"] = True
                gs.memory["executed_today"] = None
                gs.log_public(no_execution)
                gs.log_secret(f"Execution prevented: {no_execution}")
            else:
                # Handle actual death (for most players, including Zombuul on second death)
                if executed.role.name == "Zombuul" and executed.death_count == 2:
                    gs.log_secret(f"Zombuul {executed.label()} was executed for the second time and actually dies!")
                    executed.alive = False
                elif executed.role.name != "Zombuul" or executed.death_count > 1:
                    # Normal execution (or Zombuul after first death)
                    executed.alive = False
                
                # Common execution logic for all executed players
                if executed.alive == False:  # Only track death timing if they actually died
                    executed.hidden_state["died_night"] = "day"  # Track that they died during the day
                
                # Set game state
                gs.memory["executed_today"] = executed
                gs.memory["no_execution_today"] = False
                
                # Track day deaths for Zombuul ability
                if "day_deaths" not in gs.memory:
                    gs.memory["day_deaths"] = []
                gs.memory["day_deaths"].append(executed.seat)
                
                # Log execution
                execution = f"{executed.name} (Seat {executed.seat}) was executed today with {execution_votes} vote(s)."
                gs.log_public(execution)
                gs.log_secret(f"Execution: {execution}")
                
                # Check win condition immediately after execution
                if check_win_condition(gs):
                    gs.phase = Phase.END
                    return
                
                # Check for Saint execution
                if executed.role.name == "Saint":
                    saint_trigger = "The Saint was executed! Good team loses!"
                    gs.log_public(saint_trigger)
                    gs.log_secret(f"Saint ability: {saint_trigger}")
                    gs.phase = Phase.END
                    return
                
                # Check for Minstrel trigger (when a Minion dies by execution)
                if executed.role.alignment == Alignment.MINION:
                    minstrels = [p for p in gs.players if p.role.name == "Minstrel" and p.alive]
                    for minstrel in minstrels:
                        # Make all other players (except Travellers) drunk until dusk tomorrow
                        for other_player in gs.players:
                            if other_player != minstrel and other_player.alive:
                                mark_drunk(other_player, gs.day + 1)
                        gs.log_secret(f"Minstrel {minstrel.label()} makes all other players drunk until dusk tomorrow.")
                
                # Check for Mastermind trigger (when Demon actually dies by execution)
                # Note: Zombuul doesn't actually die on first execution, so Mastermind shouldn't trigger
                if (executed.role.alignment == Alignment.DEMON and 
                    (executed.role.name != "Zombuul" or executed.death_count > 1)):
                    masterminds = [p for p in gs.players if p.role.name == "Mastermind" and p.alive]
                    for mastermind in masterminds:
                        gs.memory["mastermind_triggered"] = True
                        gs.memory["mastermind_demon_executed_day"] = gs.day
                        gs.log_secret(f"Mastermind {mastermind.label()} triggers - game continues for 1 more day.")
                        # DO NOT announce publicly - Mastermind ability is completely hidden
                
                # Check for Mastermind win condition (if Mastermind triggered and someone is executed on a subsequent day)
                # Only check if this is NOT the same day the demon was executed
                if (gs.memory.get("mastermind_triggered") and 
                    executed and 
                    gs.memory.get("mastermind_demon_executed_day") != gs.day):
                    masterminds = [p for p in gs.players if p.role.name == "Mastermind" and p.alive]
                    for mastermind in masterminds:
                        gs.log_secret("Win condition: Evil team wins (Mastermind)")
                        gs.phase = Phase.END
                        return
                

    else:
        no_execution = "No one was executed today."
        gs.memory["no_execution_today"] = True
        gs.memory["executed_today"] = None
        gs.log_public(no_execution)
        gs.log_secret(f"Execution: {no_execution}")
        gs.log_secret(f"Execution debug: No execution because nominee={execution_nominee.name if execution_nominee else 'None'}, alive={execution_nominee.alive if execution_nominee else 'N/A'}")
    if check_win_condition(gs):
        gs.phase = Phase.END
    else:
        gs.phase = Phase.NIGHT

# --- LLM Hooks (Stubs) ---
def llm_prompt_player(player: Player, prompt: str, grimoire: str) -> str:
    """
    Placeholder for LLM-driven player action. Replace with actual LLM call.
    """
    # TODO: Integrate with OpenAI, local LLM, etc.
    return ""

# --- TODOs ---
# - Fill in role list and bag logic
# - Implement all role abilities (night/day)
# - Poison/drunk enforcement throughout
# - LLM prompt structure for all actions
# - Win condition checks
# - Modularize further as needed

# --- Night Ability Implementations ---

def washerwoman_ability(gs: GameState, player: Player):
    """Washerwoman learns 1 of 2 players is a particular Townsfolk."""
    gs.log_action_start("washerwoman_ability", player)
    
    others = [q for q in gs.players if q is not player]
    def normal_fn():
        # Only show true Townsfolk (not Spy, Minion, Outsider, Demon)
        town_players = [q for q in others if ((q.role.alignment is Alignment.TOWNSFOLK) and (q.role.name != "Spy"))]
        if not town_players:
            gs.log_secret(f"[DIAGNOSTIC] Washerwoman found no valid Townsfolk to reveal.")
            return None
        real_town = random.choice(town_players)
        decoy = random.choice([q for q in others if q is not real_town])
        players_to_show = [real_town, decoy]
        random.shuffle(players_to_show)
        msg = f"You see that one of {players_to_show[0].name} (Seat {players_to_show[0].seat}) or {players_to_show[1].name} (Seat {players_to_show[1].seat}) is the {real_town.role.name}."
        if is_human_player(player):
            print_colored(f"[PRIVATE] {player.name} (Seat {player.seat}) is told: {msg}", 'PRIVATE')
        gs.log_secret(f"[PRIVATE] {player.label()} is told: {msg}")
        return {"pair": (players_to_show[0].seat, players_to_show[1].seat), "reveal": real_town.role.name}
    def drunk_fn():
        if len(others) < 2:
            return None
        pair = random.sample(others, 2)
        random_townsfolk = random.choice(TOWNSFOLK).name
        msg = f"You see that one of {pair[0].name} (Seat {pair[0].seat}) or {pair[1].name} (Seat {pair[1].seat}) is the {random_townsfolk}."
        if is_human_player(player):
            print_colored(f"[PRIVATE] {player.name} (Seat {player.seat}) is told: {msg}", 'PRIVATE')
        gs.log_secret(f"[PRIVATE] {player.label()} is told: {msg}")
        return {"pair": (pair[0].seat, pair[1].seat), "reveal": random_townsfolk}
    result = resolve_ability(player, normal_fn, drunk_fn)
    if result:
        player.memory["washerwoman"] = result
        pair_seats = result["pair"]
        reveal_role = result["reveal"]
        gs.log_secret(f"Washerwoman â†’ {player.label()} sees {reveal_role} among seats {pair_seats}.")
        gs.log_action_end("washerwoman_ability", f"Learned {reveal_role} among seats {pair_seats}", player)
    else:
        gs.log_secret(f"Washerwoman â†’ {player.label()} ability failed (no valid targets).")
        gs.log_action_end("washerwoman_ability", "Failed - no valid targets", player)

def librarian_ability(gs: GameState, player: Player):
    """Librarian learns 1 of 2 players is a particular Outsider (or none)."""
    others = [q for q in gs.players if q is not player]
    def normal_fn():
        # Only show true Outsiders (not Townsfolk, Minion, Demon, or Slayer)
        outsider_players = [q for q in others if q.role.alignment is Alignment.OUTSIDER]
        if outsider_players:
            real_outsider = random.choice(outsider_players)
            other_player = random.choice([q for q in others if q is not real_outsider])
            players_to_show = [real_outsider, other_player]
            random.shuffle(players_to_show)
            msg = f"You see that one of {players_to_show[0].name} (Seat {players_to_show[0].seat}) or {players_to_show[1].name} (Seat {players_to_show[1].seat}) is the {real_outsider.role.name}."
            if is_human_player(player):
                print_colored(f"[PRIVATE] {player.name} (Seat {player.seat}) is told: {msg}", 'PRIVATE')
            gs.log_secret(f"[PRIVATE] {player.label()} is told: {msg}")
            return {"pair": (players_to_show[0].seat, players_to_show[1].seat), "reveal": real_outsider.role.name}
        else:
            # If no Outsiders in play, always tell the Librarian there are no Outsiders
            msg = f"You learn that there are no Outsiders in play."
            if is_human_player(player):
                print_colored(f"[PRIVATE] {player.name} (Seat {player.seat}) is told: {msg}", 'PRIVATE')
            gs.log_secret(f"[PRIVATE] {player.label()} is told: {msg}")
            return {"pair": None, "reveal": None}
    def drunk_fn():
        # Drunk: show a random pair of seats, but only ever reveal a random Outsider (never a non-Outsider)
        if len(others) < 2:
            return None
        random_players = random.sample(others, 2)
        if random.random() < 0.5:
            reveal = None
            msg = f"You see that neither {random_players[0].name} (Seat {random_players[0].seat}) nor {random_players[1].name} (Seat {random_players[1].seat}) is an Outsider."
        else:
            reveal = random.choice(OUTSIDERS).name
            msg = f"You see that one of {random_players[0].name} (Seat {random_players[0].seat}) or {random_players[1].name} (Seat {random_players[1].seat}) is the {reveal}."
        if is_human_player(player):
            print_colored(f"[PRIVATE] {player.name} (Seat {player.seat}) is told: {msg}", 'PRIVATE')
        gs.log_secret(f"[PRIVATE] {player.label()} is told: {msg}")
        return {"pair": (random_players[0].seat, random_players[1].seat), "reveal": reveal}
    result = resolve_ability(player, normal_fn, drunk_fn)
    if result:
        player.memory["librarian"] = result
        pair_seats = result["pair"]
        reveal_role = result["reveal"]
        if reveal_role:
            gs.log_secret(f"Librarian â†’ {player.label()} sees Outsider {reveal_role} among seats {pair_seats}.")
        else:
            gs.log_secret(f"Librarian â†’ {player.label()} sees no Outsiders in play.")
    else:
        gs.log_secret(f"Librarian â†’ {player.label()} ability failed (no valid targets).")

def investigator_ability(gs: GameState, player: Player):
    """Investigator learns 1 of 2 players is a particular Minion."""
    others = [q for q in gs.players if q is not player]
    def normal_fn():
        minion_players = [q for q in others if q.role.alignment is Alignment.MINION]
        if not minion_players:
            return None
        minion = random.choice(minion_players)
        other = random.choice([q for q in others if q is not minion])
        players_to_show = [minion, other]
        random.shuffle(players_to_show)
        msg = f"You see that one of {players_to_show[0].name} (Seat {players_to_show[0].seat}) or {players_to_show[1].name} (Seat {players_to_show[1].seat}) is the {minion.role.name}."
        if is_human_player(player):
            print_colored(f"[PRIVATE] {player.name} (Seat {player.seat}) is told: {msg}", 'PRIVATE')
        gs.log_secret(f"[PRIVATE] {player.label()} is told: {msg}")
        return {"pair": (players_to_show[0].seat, players_to_show[1].seat), "reveal": minion.role.name}
    def drunk_fn():
        if len(others) < 2:
            return None
        pair = random.sample(others, 2)
        random_minion = random.choice(MINIONS).name
        msg = f"You see that one of {pair[0].name} (Seat {pair[0].seat}) or {pair[1].name} (Seat {pair[1].seat}) is the {random_minion}."
        if is_human_player(player):
            print_colored(f"[PRIVATE] {player.name} (Seat {player.seat}) is told: {msg}", 'PRIVATE')
        gs.log_secret(f"[PRIVATE] {player.label()} is told: {msg}")
        return {"pair": (pair[0].seat, pair[1].seat), "reveal": random_minion}
    result = resolve_ability(player, normal_fn, drunk_fn)
    if result:
        player.memory["investigator"] = result
        pair_seats = result["pair"]
        reveal_role = result["reveal"]
        gs.log_secret(f"Investigator â†’ {player.label()} sees Minion {reveal_role} among seats {pair_seats}.")
    else:
        gs.log_secret(f"Investigator â†’ {player.label()} ability failed (no valid targets).")

def chef_ability(gs: GameState, player: Player):
    """Chef learns how many pairs of evil players there are."""
    def normal_fn():
        evil_players = [p for p in gs.players if (p.role.alignment in {Alignment.MINION, Alignment.DEMON} or recluse_registers_as_evil_or_minion_or_demon(p))]
        pair_count = 0
        for i in range(len(gs.players)):
            if gs.players[i] in evil_players and gs.players[(i+1) % len(gs.players)] in evil_players:
                pair_count += 1
        msg = f"You learn there are {pair_count} pairs of evil players sitting next to each other."
        if is_human_player(player):
            print_colored(f"[PRIVATE] {player.name} (Seat {player.seat}) is told: {msg}", 'PRIVATE')
        gs.log_secret(f"[PRIVATE] {player.label()} is told: {msg}")
        return {"evil_pairs": pair_count}
    def drunk_fn():
        evil_count = sum(1 for p in gs.players if p.role.alignment in {Alignment.MINION, Alignment.DEMON})
        max_possible = min(len(gs.players) // 2, evil_count)
        random_count = random.randint(0, max_possible)
        msg = f"You learn there are {random_count} pairs of evil players sitting next to each other."
        if is_human_player(player):
            print_colored(f"[PRIVATE] {player.name} (Seat {player.seat}) is told: {msg}", 'PRIVATE')
        gs.log_secret(f"[PRIVATE] {player.label()} is told: {msg}")
        return {"evil_pairs": random_count}
    result = resolve_ability(player, normal_fn, drunk_fn)
    if result:
        player.memory["chef"] = result
        pairs = result["evil_pairs"]
        gs.log_secret(f"Chef â†’ {player.label()} learns {pairs} evil pair(s).")
    else:
        gs.log_secret(f"Chef â†’ {player.label()} ability failed.")

def empath_ability(gs: GameState, player: Player):
    """Empath learns how many of their 2 alive neighbors are evil."""
    def normal_fn():
        alive_players = [p for p in gs.players if p.alive]
        if len(alive_players) <= 1:
            msg = f"You have no living neighbors."
            if is_human_player(player):
                print_colored(f"[PRIVATE] {player.name} (Seat {player.seat}) is told: {msg}", 'PRIVATE')
            gs.log_secret(f"[PRIVATE] {player.label()} is told: {msg}")
            return {"evil_count": 0, "neighbors": (None, None)}
        player_index = alive_players.index(player)
        left_neighbor = alive_players[(player_index - 1) % len(alive_players)]
        right_neighbor = alive_players[(player_index + 1) % len(alive_players)]
        evil_count = sum(1 for p in [left_neighbor, right_neighbor] if (p.role.alignment in {Alignment.MINION, Alignment.DEMON} or recluse_registers_as_evil_or_minion_or_demon(p)))
        msg = f"You sense {evil_count} evil neighbor(s) ({left_neighbor.name} (Seat {left_neighbor.seat}), {right_neighbor.name} (Seat {right_neighbor.seat}))."
        if is_human_player(player):
            print_colored(f"[PRIVATE] {player.name} (Seat {player.seat}) is told: {msg}", 'PRIVATE')
        gs.log_secret(f"[PRIVATE] {player.label()} is told: {msg}")
        return {"evil_count": evil_count, "neighbors": (left_neighbor.seat, right_neighbor.seat)}
    def drunk_fn():
        alive_players = [p for p in gs.players if p.alive]
        if len(alive_players) <= 1:
            msg = f"You have no living neighbors."
            if is_human_player(player):
                print_colored(f"[PRIVATE] {player.name} (Seat {player.seat}) is told: {msg}", 'PRIVATE')
            gs.log_secret(f"[PRIVATE] {player.label()} is told: {msg}")
            return {"evil_count": 0, "neighbors": (None, None)}
        player_index = alive_players.index(player)
        left_neighbor = alive_players[(player_index - 1) % len(alive_players)]
        right_neighbor = alive_players[(player_index + 1) % len(alive_players)]
        random_count = random.randint(0, 2)
        msg = f"You sense {random_count} evil neighbor(s) ({left_neighbor.name} (Seat {left_neighbor.seat}), {right_neighbor.name} (Seat {right_neighbor.seat}))."
        if is_human_player(player):
            print_colored(f"[PRIVATE] {player.name} (Seat {player.seat}) is told: {msg}", 'PRIVATE')
        gs.log_secret(f"[PRIVATE] {player.label()} is told: {msg}")
        return {"evil_count": random_count, "neighbors": (left_neighbor.seat, right_neighbor.seat)}
    result = resolve_ability(player, normal_fn, drunk_fn)
    if result:
        player.memory["empath"] = result
        count = result["evil_count"]
        neighbors = result["neighbors"]
        if None in neighbors:
            gs.log_secret(f"Empath â†’ {player.label()} detects {count} evil neighbors (not enough players alive).")
        else:
            gs.log_secret(f"Empath â†’ {player.label()} detects {count} evil neighbor(s) (seats {neighbors}).")
    else:
        gs.log_secret(f"Empath â†’ {player.label()} ability failed.")

def fortune_teller_ability(gs: GameState, player: Player):
    """Fortune Teller chooses 2 players: learns if either is a Demon."""
    others = [p for p in gs.players if p is not player]
    def normal_fn():
        # Always prompt human Fortune Teller for their action
        if is_human_player(player) and len(others) >= 2:
            print_colored(f"[YOUR TURN] {player.name} (Seat {player.seat}), choose TWO players to check.", 'PROMPT')
            print_colored(f"Other players: {', '.join(f'{p.name} (Seat {p.seat})' for p in others)}", 'PUBLIC')
            while True:
                choice = input(f"Enter two seat numbers or names, separated by space: ").strip().lower()
                if choice == "" or choice == "pass":
                    return None
                tokens = choice.split()
                if len(tokens) != 2:
                    print_colored("Please enter exactly two players.", 'ERROR')
                    continue
                targets = []
                for token in tokens:
                    target = None
                    try:
                        seat_num = int(token)
                        # All seat numbers are 0-indexed
                        if 0 <= seat_num <= len(gs.players)-1:
                            target = next((p for p in others if p.seat == seat_num), None)
                    except ValueError:
                        matches = [p for p in others if p.name.lower() == token]
                        if not matches:
                            matches = [p for p in others if p.name.lower().startswith(token)]
                        if len(matches) == 1:
                            target = matches[0]
                        elif len(matches) > 1:
                            print_colored(f"Ambiguous name. Matches: {', '.join(p.name for p in matches)}. Please be more specific.", 'ERROR')
                            break
                    if target is None:
                        print_colored("Invalid target. Please enter valid seat numbers (0-indexed) or player names.", 'ERROR')
                        break
                    targets.append(target)
                if len(targets) != 2:
                    continue
                break
        elif is_llm_player(player) and len(others) >= 2:
            prompt = format_player_prompt(gs, player, "target_selection", options=others)
            print_llm_prompt_for_seat(player, f"Prompting LLM for Fortune Teller (Seat {player.seat}) target_selection", 'PROMPT')
            # Explicitly log the Fortune Teller prompt
            prompt_content = '\n'.join([f"{m['role'].upper()}: {m['content']}" for m in prompt])
            gs.log_llm_prompt(player, "fortune_teller_target_selection", prompt_content, label=f"Fortune Teller (Seat {player.seat}) target_selection")
            llm_response = call_gpt(prompt, label=f"Fortune Teller (Seat {player.seat}) target_selection")
            words = llm_response.strip().split()
            # Parse seat numbers as 0-indexed
            seats = []
            for word in words:
                if word.isdigit():
                    seat_num = int(word)
                    if 0 <= seat_num <= len(gs.players)-1:
                        seats.append(seat_num)  # Keep as 0-indexed
            if len(seats) < 2:
                targets = random.sample(others, 2)
            else:
                targets = [next((p for p in others if p.seat == s), random.choice(others)) for s in seats[:2]]
        else:
            if len(others) < 2:
                return None
            targets = random.sample(others, 2)
        is_demon = any((p.role.alignment is Alignment.DEMON or recluse_registers_as_evil_or_minion_or_demon(p) == "demon") for p in targets)
        red_herring_seat = gs.memory.get("ft_red_herring")
        red_herring_selected = red_herring_seat is not None and any(p.seat == red_herring_seat for p in targets)
        result_demon = is_demon or red_herring_selected
        msg = f"You checked {targets[0].name} (Seat {targets[0].seat}) and {targets[1].name} (Seat {targets[1].seat}). Demon result: {'YES' if result_demon else 'NO'}"
        if is_human_player(player):
            print_colored(f"[PRIVATE] {player.name} (Seat {player.seat}) is told: {msg}", 'PRIVATE')
        gs.log_secret(f"[PRIVATE] {player.label()} is told: {msg}")
        return {"type": "fortune_teller", "data": {"targets": (targets[0].seat, targets[1].seat), "result": result_demon}}
    def drunk_fn():
        # Always prompt human Fortune Teller for their action
        if is_human_player(player) and len(others) >= 2:
            print_colored(f"[YOUR TURN] {player.name} (Seat {player.seat}), choose TWO players to check.", 'PROMPT')
            print_colored(f"Other players: {', '.join(f'{p.name} (Seat {p.seat})' for p in others)}", 'PUBLIC')
            while True:
                choice = input(f"Enter two seat numbers or names, separated by space: ").strip().lower()
                if choice == "" or choice == "pass":
                    return None
                tokens = choice.split()
                if len(tokens) != 2:
                    print_colored("Please enter exactly two players.", 'ERROR')
                    continue
                targets = []
                for token in tokens:
                    target = None
                    try:
                        seat_num = int(token)
                        # All seat numbers are 0-indexed
                        if 0 <= seat_num <= len(gs.players)-1:
                            target = next((p for p in others if p.seat == seat_num), None)
                    except ValueError:
                        matches = [p for p in others if p.name.lower() == token]
                        if not matches:
                            matches = [p for p in others if p.name.lower().startswith(token)]
                        if len(matches) == 1:
                            target = matches[0]
                        elif len(matches) > 1:
                            print_colored(f"Ambiguous name. Matches: {', '.join(p.name for p in matches)}. Please be more specific.", 'ERROR')
                            break
                    if target is None:
                        print_colored("Invalid target. Please enter valid seat numbers (0-indexed) or player names.", 'ERROR')
                        break
                    targets.append(target)
                if len(targets) != 2:
                    continue
                break
        elif is_llm_player(player) and len(others) >= 2:
            prompt = format_player_prompt(gs, player, "target_selection", options=others)
            print_llm_prompt_for_seat(player, f"Prompting LLM for Drunk Fortune Teller (Seat {player.seat}) target_selection", 'PROMPT')
            llm_response = call_gpt(prompt, label=f"Fortune Teller (Seat {player.seat}) target_selection (drunk)")
            words = llm_response.strip().split()
            # Parse seat numbers as 0-indexed
            seats = []
            for word in words:
                if word.isdigit():
                    seat_num = int(word)
                    if 0 <= seat_num <= len(gs.players)-1:
                        seats.append(seat_num)  # Keep as 0-indexed
            if len(seats) < 2:
                targets = random.sample(others, 2)
            else:
                targets = [next((p for p in others if p.seat == s), random.choice(others)) for s in seats[:2]]
        else:
            if len(others) < 2:
                return None
            targets = random.sample(others, 2)
        random_result = random.choice([True, False])
        msg = f"You checked {targets[0].name} (Seat {targets[0].seat}) and {targets[1].name} (Seat {targets[1].seat}). Demon result: {'YES' if random_result else 'NO'}"
        if is_human_player(player):
            print_colored(f"[PRIVATE] {player.name} (Seat {player.seat}) is told: {msg}", 'PRIVATE')
        gs.log_secret(f"[PRIVATE] {player.label()} is told: {msg}")
        return {"type": "fortune_teller", "data": {"targets": (targets[0].seat, targets[1].seat), "result": random_result}}
    result = resolve_ability(player, normal_fn, drunk_fn)
    if result:
        # Add night information to the stored result
        result["data"]["night"] = gs.day
        player.memory["fortune_teller"] = result  # Store under correct key
        targets = result["data"]["targets"]
        demon_result = result["data"]["result"]
        gs.log_secret(f"Fortune Teller â†’ {player.label()} checks seats {targets}. Demon result: {'YES' if demon_result else 'NO'}.")
    else:
        gs.log_secret(f"Fortune Teller â†’ {player.label()} ability failed.")

def monk_ability(gs: GameState, player: Player):
    # Ensure Monk cannot protect themselves (enforced for all input types)
    others = [p for p in gs.players if p.alive and p is not player]
    if not others:
        gs.log_secret(f"Monk  {player.label()} ability failed (no valid targets).")
        return
    
    # Get target selection (same for both drunk and normal)
    if is_human_player(player):
        print_llm_prompt_for_seat(player, f"[YOUR TURN] {player.name} (Seat {player.seat}), choose a player to protect (not yourself).", 'PROMPT')
        print_llm_prompt_for_seat(player, f"Other living players: {', '.join(f'{p.name} (Seat {p.seat})' for p in others)}", 'PUBLIC')
        while True:
            choice = input(f"Enter seat number or name to protect: ").strip().lower()
            target = None
            try:
                seat_num = int(choice)
                target = next((p for p in others if p.seat == seat_num), None)
            except ValueError:
                matches = [p for p in others if p.name.lower() == choice]
                if not matches:
                    matches = [p for p in others if p.name.lower().startswith(choice)]
                if len(matches) == 1:
                    target = matches[0]
            if target is None or target is player:
                print_colored("Invalid choice. Please enter a valid seat number (0-indexed) or player name (not yourself).", 'ERROR')
                continue
            break
    elif is_llm_player(player):
        prompt = format_player_prompt(gs, player, "target_selection", options=others)
        print_llm_prompt_for_seat(player, f"Prompting LLM for Monk (Seat {player.seat}) target_selection", 'PROMPT')
        # Explicitly log the Monk prompt
        prompt_content = '\n'.join([f"{m['role'].upper()}: {m['content']}" for m in prompt])
        gs.log_llm_prompt(player, "monk_target_selection", prompt_content, label=f"Monk (Seat {player.seat}) target_selection")
        llm_response = call_gpt(prompt, label=f"Monk (Seat {player.seat}) target_selection")
        think = ""
        if "<think>" in llm_response.lower():
            think_start = llm_response.lower().find("<think>") + 7
            think_end = llm_response.lower().find("</think>")
            if think_end > think_start:
                think = llm_response[think_start:think_end].strip()
        player.scratchpad = think
        seat = parse_llm_response(llm_response, "target_selection", options=others)
        player.scratchpad = ""
        target = next((p for p in others if p.seat == seat and p is not player), None)
        if target is None:
            target = random.choice(others)
    
    # Set message (same for both drunk and normal)
    msg = f"You protect {target.name} (Seat {target.seat}) from the Demon tonight."
    
    # Handle drunk vs normal with minimal branching
    if player.drunk:
        # Drunk: don't actually protect anyone
        gs.log_secret(f"[PRIVATE] {player.label()} is told: {msg} (drunk - no actual protection)")
    else:
        # Normal: actually protect the target
        target.hidden_state["protected_by_monk"] = True
        gs.log_secret(f"[PRIVATE] {player.label()} is told: {msg}")
    
    if is_human_player(player):
        print_colored(f"[PRIVATE] {player.name} (Seat {player.seat}) is told: {msg}", 'PRIVATE')
    
    # Store result with night information
    player.memory["monk"] = {"type": "monk", "data": {"target": target.seat, "night": gs.day}}
    gs.log_secret(f"Monk â†’ {player.label()} protects player in seat {target.seat} from the Demon tonight.")

def undertaker_ability(gs: GameState, player: Player):
    """Undertaker learns the role of the character who died by execution during the day."""
    executed_player = gs.memory.get("executed_today")
    def normal_fn():
        if not executed_player:
            msg = f"You learn that no one was executed today."
            if is_human_player(player):
                print_llm_prompt_for_seat(player, f"[PRIVATE] {player.name} (Seat {player.seat}) is told: {msg}", 'PRIVATE')
            gs.log_secret(f"[PRIVATE] {player.label()} is told: {msg}")
            return {"role": None}
        # Recluse may register as a different role
        role_name = executed_player.role.name
        if executed_player.role.name == "Recluse":
            # Randomly register as Minion, Demon, or Outsider
            role_name = random.choice(["Minion", "Demon", "Outsider"])
        msg = f"You learn that {executed_player.name} was executed today and their role was {role_name}."
        if is_human_player(player):
            print_llm_prompt_for_seat(player, f"[PRIVATE] {player.name} (Seat {player.seat}) is told: {msg}", 'PRIVATE')
        gs.log_secret(f"[PRIVATE] {player.label()} is told: {msg}")
        return {"role": role_name}
    def drunk_fn():
        # Create a list of roles excluding "Undertaker" to prevent drunk undertaker from getting "undertaker" as reading
        non_undertaker_roles = [r for r in TB_ROLES if r.name != "Undertaker"]
        
        if not executed_player:
            msg = f"You learn that no one was executed today."
            if is_human_player(player):
                print_llm_prompt_for_seat(player, f"[PRIVATE] {player.name} (Seat {player.seat}) is told: {msg}", 'PRIVATE')
            gs.log_secret(f"[PRIVATE] {player.label()} is told: {msg}")
            return {"role": random.choice(non_undertaker_roles).name}
        random_role = random.choice(non_undertaker_roles).name
        msg = f"You learn that {executed_player.name} was executed today and their role was {random_role}."
        if is_human_player(player):
            print_llm_prompt_for_seat(player, f"[PRIVATE] {player.name} (Seat {player.seat}) is told: {msg}", 'PRIVATE')
        gs.log_secret(f"[PRIVATE] {player.label()} is told: {msg}")
        return {"role": random_role}
    result = resolve_ability(player, normal_fn, drunk_fn)
    if result:
        player.memory["undertaker"] = result
        role = result["role"]
        if role:
            gs.log_secret(f"Undertaker â†’ {player.label()} learns a {role} died by execution today.")
        else:
            gs.log_secret(f"Undertaker â†’ {player.label()} learns no one was executed today.")
    else:
        gs.log_secret(f"Undertaker â†’ {player.label()} ability failed.")

def ravenkeeper_ability(gs: GameState, player: Player):
    """Ravenkeeper chooses a player when they die at night: learns their character."""
    # Include all other players (the Ravenkeeper can choose anyone, even if they're dead)
    others = [p for p in gs.players if p is not player]
    
    if not others:
        gs.log_secret(f"Ravenkeeper â†’ {player.label()} ability failed (no valid targets).")
        return
    
    # Get target selection (same for both drunk and normal)
    if is_human_player(player):
        print_llm_prompt_for_seat(player, f"[YOUR TURN] {player.name} (Seat {player.seat}), you died tonight! Choose a player to learn their role.", 'PROMPT')
        print_llm_prompt_for_seat(player, f"All other players: {', '.join(f'{p.name} (Seat {p.seat})' for p in others)}", 'PUBLIC')
        while True:
            choice = input(f"Enter seat number or name to learn their role: ").strip().lower()
            target = None
            try:
                seat_num = int(choice)
                target = next((p for p in others if p.seat == seat_num), None)
            except ValueError:
                matches = [p for p in others if p.name.lower() == choice]
                if not matches:
                    matches = [p for p in others if p.name.lower().startswith(choice)]
                if len(matches) == 1:
                    target = matches[0]
            if target is None:
                print_colored("Invalid choice. Please enter a valid seat number or player name.", 'ERROR')
                continue
            break
    elif is_llm_player(player) and others:
        prompt = format_player_prompt(gs, player, "target_selection", options=others)
        print_llm_prompt_for_seat(player, f"Prompting LLM for Ravenkeeper (Seat {player.seat}) target_selection", 'PROMPT')
        # Explicitly log the Ravenkeeper prompt
        prompt_content = '\n'.join([f"{m['role'].upper()}: {m['content']}" for m in prompt])
        gs.log_llm_prompt(player, "ravenkeeper_target_selection", prompt_content, label=f"Ravenkeeper (Seat {player.seat}) target_selection")
        llm_response = call_gpt(prompt, label=f"Ravenkeeper (Seat {player.seat}) target_selection")
        think = ""
        if "<think>" in llm_response.lower():
            think_start = llm_response.lower().find("<think>") + 7
            think_end = llm_response.lower().find("</think>")
            if think_end > think_start:
                think = llm_response[think_start:think_end].strip()
        player.scratchpad = think
        seat = parse_llm_response(llm_response, "target_selection", options=others)
        player.scratchpad = ""
        target = next((p for p in others if p.seat == seat), random.choice(others))
    else:
        target = random.choice(others)
    
    # Handle drunk vs normal with minimal branching
    if player.drunk:
        # Drunk: show random role instead of actual role
        role_name = random.choice(TB_ROLES).name
    else:
        # Normal: show actual role
        role_name = target.role.name
    
    # Set message (same for both drunk and normal)
    msg = f"You learn that {target.name} (Seat {target.seat}) is the {role_name}."
    
    # Log the message
    if player.drunk:
        gs.log_secret(f"[PRIVATE] {player.label()} is told: {msg} (drunk - random role)")
    else:
        gs.log_secret(f"[PRIVATE] {player.label()} is told: {msg}")
    
    if is_human_player(player):
        print_llm_prompt_for_seat(player, f"[PRIVATE] {msg}", 'PRIVATE')
    
    # Store result with night information
    player.memory["ravenkeeper"] = {"type": "ravenkeeper", "data": {"target": target.seat, "role": role_name, "night": gs.day}}
    gs.log_secret(f"Ravenkeeper â†’ {player.label()} learns player in seat {target.seat} is a {role_name}.")

def check_win_condition(gs: GameState):
    """Check if either team has won the game."""
    alive_players = [p for p in gs.players if p.alive]
    
    # For win condition purposes, Zombuul who are "dead for targeting" but still alive count as alive (but not for things like vote count)
    # This prevents the game from ending when Zombuul is killed for the first time
    effective_alive_players = alive_players.copy()
    for player in gs.players:
        if (player.role.name == "Zombuul" and 
            player.hidden_state.get("zombuul_dead_for_targeting", False) and 
            player.alive):
            # Zombuul is "dead for targeting" but still alive for win condition purposes
            effective_alive_players.append(player)
    
    alive_demon = any(p.alive and p.role.alignment is Alignment.DEMON for p in gs.players)
    
    # Count good and evil players (using effective alive players for Zombuul)
    good_count = sum(1 for p in effective_alive_players 
                    if p.role.alignment in {Alignment.TOWNSFOLK, Alignment.OUTSIDER})
    evil_count = sum(1 for p in effective_alive_players 
                   if p.role.alignment in {Alignment.MINION, Alignment.DEMON})
    
    gs.log_secret(f"Win condition check: {len(effective_alive_players)} effective alive, {good_count} good, {evil_count} evil, demon alive: {alive_demon}")
    
    # Check win conditions
    if not alive_demon:
        # If Scarlet Woman effect might trigger
        scarlet = next((p for p in gs.players 
                      if p.role.name == "Scarlet Woman" and p.alive), None)
        if scarlet and len(effective_alive_players) >= 5:
            # Convert Scarlet Woman to Imp
            scarlet.role = ROLE_BY_NAME["Imp"]
            gs.log_secret("The Scarlet Woman becomes the Imp!")
            # Optionally update Imp/minion memory here
            return False  # No win yet
        else:
            # Check if Mastermind has triggered
            if gs.memory.get("mastermind_triggered"):
                # Mastermind extends the game - don't end yet
                gs.log_secret("Mastermind has triggered - game continues despite Demon death")
                return False
            else:
                gs.log_public("The Demon is dead! Good team wins!")
                print_colored("The Demon is dead! Good team wins!", 'PUBLIC')
                gs.log_secret("Win condition: Good team wins (demon dead)")
                return True  # Good team wins
    
    # Evil wins immediately if less than 3 players alive and Demon is alive
    if len(effective_alive_players) < 3 and alive_demon:
        gs.log_public(f"Only {len(effective_alive_players)} players remain alive and the Demon is still alive! Evil team wins!")
        print_colored(f"Only {len(effective_alive_players)} players remain alive and the Demon is still alive! Evil team wins!", 'PUBLIC')
        gs.log_secret("Win condition: Evil team wins (less than 3 players alive)")
        return True
    
    # Evil wins if they outnumber good players (not when they equal them)
    if evil_count > good_count:
        gs.log_public("Evil players outnumber good players! Evil team wins!")
        print_colored("Evil players outnumber good players! Evil team wins!", 'PUBLIC')
        gs.log_secret("Win condition: Evil team wins (evil outnumbers good)")
        return True
    
    # Check if Mayor is active (3 players alive and no execution)
    if len(effective_alive_players) == 3 and gs.memory.get("no_execution_today"):
        mayor = next((p for p in effective_alive_players if p.role.name == "Mayor"), None)
        if mayor:
            gs.log_public("The Mayor has saved the town! Good team wins!")
            print_colored("The Mayor has saved the town! Good team wins!", 'PUBLIC')
            gs.log_secret("Win condition: Good team wins (Mayor saves town)")
            return True
    
    gs.log_secret("Win condition: No win condition met")
    return False  # No win condition met

# --- Helper Functions for LLM Prompts ---

def get_game_snapshot(gs: GameState, for_player=None):
    """
    Return a formatted string representation of the current game state.
    This will be useful for generating LLM prompts.
    
    Args:
        gs: The current GameState
        for_player: If provided, includes private info for this player
        
    Returns:
        A string representation of the game state
    """
    lines = []
    lines.append(f"=== BLOOD ON THE CLOCKTOWER - DAY {gs.day} ===")
    
    # Player status with clear alive/dead distinction
    alive_players = [p for p in gs.players if p.alive]
    dead_players = [p for p in gs.players if not p.alive]
    
    # Handle Zombuul who are "dead for targeting" but still alive for win conditions
    zombuul_dead_for_targeting = [p for p in gs.players 
                                 if p.role.name == "Zombuul" and 
                                 p.hidden_state.get("zombuul_dead_for_targeting", False) and 
                                 p.alive]
    
    lines.append(f"\nALIVE PLAYERS ({len(alive_players)}):")
    for p in alive_players:
        lines.append(f"  Seat {p.seat}: {p.name}")
    
    if zombuul_dead_for_targeting:
        lines.append(f"\nZOMBUUL DEAD FOR TARGETING ({len(zombuul_dead_for_targeting)}):")
        for p in zombuul_dead_for_targeting:
            lines.append(f"  Seat {p.seat}: {p.name} (Zombuul - registers as dead for targeting)")
    
    if dead_players:
        lines.append(f"\nDEAD PLAYERS ({len(dead_players)}):")
        for p in dead_players:
            lines.append(f"  Seat {p.seat}: {p.name}")
    
    # Summary of current state
    effective_alive = len(alive_players) + len(zombuul_dead_for_targeting)
    lines.append(f"\nCURRENT STATE:")
    lines.append(f"  * {effective_alive} players effectively alive, {len(dead_players)} players dead")
    lines.append(f"  * Day {gs.day}")
    
    # Recent events
    lines.append("\nRECENT EVENTS:")
    
    # Last execution
    executed = gs.memory.get("executed_today")
    if executed:
        lines.append(f"  * {executed.name} (Seat {executed.seat}) was executed yesterday")
    elif gs.memory.get("no_execution_today", False):
        lines.append(f"  * No one was executed yesterday")
        
    # Last night death
    killed = gs.memory.get("killed_by_demon")
    if killed:
        lines.append(f"  * {killed.name} (Seat {killed.seat}) died during the night")
    
    # Private info for specific player
    if for_player:
        lines.append(f"\nPRIVATE INFO FOR {for_player.name} (Seat {for_player.seat}):")
        # Use effective role to prevent information leakage (e.g., Drunk should see their fake role)
        role_name, ability_desc, alignment = get_effective_role(for_player)
        lines.append(f"  Role: {role_name} ({alignment.value})")
        lines.append(f"  Ability: {ability_desc}")
        
        # Show any night info this player has received
        if for_player.memory:
            lines.append("\n  Night Information:")
            for key, value in for_player.memory.items():
                if key != "protected_by_monk" and key != "was_nominated" and key != "ft_red_herring":
                    # Format seat numbers as 0-indexed in displays
                    formatted_value = format_memory_for_display(key, value)
                    lines.append(f"  * {key}: {formatted_value}")
    
    return "\n".join(lines)

def format_memory_for_display(key, value):
    """Helper function to format memory values for display with 0-indexed seats."""
    if isinstance(value, dict):
        result = {}
        for k, v in value.items():
            if k in ['pair', 'targets', 'neighbors'] and isinstance(v, tuple):
                # Seat numbers are already 0-indexed
                result[k] = v
            elif k in ['target', 'master'] and isinstance(v, int):
                # Seat numbers are already 0-indexed
                result[k] = v
            elif k == 'night':
                # Format night information clearly
                result[k] = f"Night {v}"
            else:
                result[k] = v
        return str(result)
    elif isinstance(value, list) and all(isinstance(item, dict) for item in value):
        # For lists of dicts (like fortune_teller results)
        formatted_list = []
        for item in value:
            formatted_list.append(format_memory_for_display('item', item))
        return str(formatted_list)
    elif isinstance(value, tuple):
        # Seat numbers are already 0-indexed
        return str(value)
    elif isinstance(value, list) and all(isinstance(x, int) for x in value):
        # Seat numbers are already 0-indexed
        return str(value)
    else:
        return str(value)

# Helper to check if a player should use LLM (for test mode or full LLM mode)
def is_llm_player(player):
    if PER_SEAT_USE_LLM is not None:
        return PER_SEAT_USE_LLM[player.seat]  # Direct 0-indexed access
    return USE_LLM

def is_human_player(player):
    if PER_SEAT_IS_HUMAN is not None:
        return PER_SEAT_IS_HUMAN[player.seat]  # Direct 0-indexed access
    return False

def sanitize_for_pdf(text):
    """Replace common Unicode punctuation with ASCII equivalents and remove/replace other non-latin1 chars."""
    replacements = {
        '\u2013': '-',  # en dash
        '\u2014': '-',  # em dash
        '\u2018': "'",  # left single quote
        '\u2019': "'",  # right single quote
        '\u201c': '"',  # left double quote
        '\u201d': '"',  # right double quote
        '\u2026': '...',  # ellipsis
        '\u2022': '*',  # bullet
        '\u00a0': ' ',  # non-breaking space
    }
    for uni, asc in replacements.items():
        text = text.replace(uni.encode('utf-8').decode('unicode_escape'), asc)
    # Remove/replace any remaining non-latin1 chars
    return text.encode('latin-1', 'replace').decode('latin-1')

def save_logs_to_xml(gs: GameState, filename=None):
    """Save game logs in structured XML format for easy analysis and navigation."""
    if filename is None:
        timestamp = datetime.now().strftime('%Y%m%d_%H%M%S')
        filename = f"botc_game_log_{timestamp}.xml"
    
    # Create XML content
    xml_content = []
    xml_content.append('<?xml version="1.0" encoding="UTF-8"?>')
    xml_content.append('<game_log>')
    
    # Add metadata
    xml_content.append('  <metadata>')
    xml_content.append(f'    <date>{datetime.now().strftime("%Y-%m-%d %H:%M:%S")}</date>')
    xml_content.append(f'    <player_count>{len(gs.players)}</player_count>')
    xml_content.append('    <players>')
    for player in gs.players:
        role_name, _, alignment = get_actual_role_info(player)
        xml_content.append(f'      <player seat="{player.seat}" name="{player.name}" role="{role_name}" alignment="{alignment.value}"/>')
    xml_content.append('    </players>')
    
    # Add LLM statistics
    xml_content.append('    <llm_statistics>')
    total_prompts = sum(stats["count"] for stats in LLM_INPUT_STATS.values())
    total_words = sum(stats["total_words"] for stats in LLM_INPUT_STATS.values())
    xml_content.append(f'      <total_prompts>{total_prompts}</total_prompts>')
    xml_content.append(f'      <total_words>{total_words}</total_words>')
    if total_prompts > 0:
        xml_content.append(f'      <average_words_per_prompt>{total_words // total_prompts}</average_words_per_prompt>')
        xml_content.append('      <breakdown_by_action_type>')
        for action_type, stats in sorted(LLM_INPUT_STATS.items()):
            if stats["count"] > 0:
                avg_words = stats["total_words"] // stats["count"]
                xml_content.append(f'        <action_type name="{action_type}" count="{stats["count"]}" total_words="{stats["total_words"]}" average_words="{avg_words}"/>')
        xml_content.append('      </breakdown_by_action_type>')
    xml_content.append('    </llm_statistics>')
    xml_content.append('  </metadata>')
    
    # Add structured log entries in chronological order
    xml_content.append('  <log_entries>')
    for entry in gs.xml_log:
        attrs = ' '.join([f'{k}="{v}"' for k, v in entry["attributes"].items() if v is not None])
        if attrs:
            xml_content.append(f'    <{entry["type"]} id="{entry["id"]}" phase="{entry["phase"]}" day="{entry["day"]}" {attrs}>')
        else:
            xml_content.append(f'    <{entry["type"]} id="{entry["id"]}" phase="{entry["phase"]}" day="{entry["day"]}">')
        
        # Escape XML content
        content = entry["content"].replace('&', '&amp;').replace('<', '&lt;').replace('>', '&gt;').replace('"', '&quot;').replace("'", '&apos;')
        xml_content.append(f'      {content}')
        xml_content.append(f'    </{entry["type"]}>')
    xml_content.append('  </log_entries>')
    
    # Add legacy logs for backward compatibility
    xml_content.append('  <legacy_logs>')
    xml_content.append('    <public_log>')
    for log in gs.public_log:
        msg = log["msg"].replace('&', '&amp;').replace('<', '&lt;').replace('>', '&gt;').replace('"', '&quot;').replace("'", '&apos;')
        xml_content.append(f'      <entry phase_tick_id="{log["phase_tick_id"]}">{msg}</entry>')
    xml_content.append('    </public_log>')
    xml_content.append('    <storyteller_log>')
    for log in gs.storyteller_log:
        msg = log.replace('&', '&amp;').replace('<', '&lt;').replace('>', '&gt;').replace('"', '&quot;').replace("'", '&apos;')
        xml_content.append(f'      <entry>{msg}</entry>')
    xml_content.append('    </storyteller_log>')
    xml_content.append('  </legacy_logs>')
    
    xml_content.append('</game_log>')
    
    # Write to file
    try:
        with open(filename, 'w', encoding='utf-8') as f:
            f.write('\n'.join(xml_content))
        print_colored(f"Game log saved to {filename}", 'STORYTELLER')
        print_colored("You can open this XML file in any text editor or XML viewer for easy navigation.", 'STORYTELLER')
        print_colored("Each prompt, response, and action is a separate collapsible element.", 'STORYTELLER')
    except Exception as e:
        print_colored(f"Error saving XML log: {e}", 'ERROR')

def save_interim_logs_to_xml(gs: GameState, filename=None):
    """Save an interim copy of game logs at the end of day 5."""
    if filename is None:
        timestamp = datetime.now().strftime('%Y%m%d_%H%M%S')
        filename = f"botc_game_log_{timestamp}_day5interim.xml"
    
    # Create XML content
    xml_content = []
    xml_content.append('<?xml version="1.0" encoding="UTF-8"?>')
    xml_content.append('<game_log>')
    
    # Add metadata
    xml_content.append('  <metadata>')
    xml_content.append(f'    <date>{datetime.now().strftime("%Y-%m-%d %H:%M:%S")}</date>')
    xml_content.append(f'    <player_count>{len(gs.players)}</player_count>')
    xml_content.append('    <players>')
    for player in gs.players:
        role_name, _, alignment = get_actual_role_info(player)
        xml_content.append(f'      <player seat="{player.seat}" name="{player.name}" role="{role_name}" alignment="{alignment.value}"/>')
    xml_content.append('    </players>')
    
    # Add LLM statistics
    xml_content.append('    <llm_statistics>')
    total_prompts = sum(stats["count"] for stats in LLM_INPUT_STATS.values())
    total_words = sum(stats["total_words"] for stats in LLM_INPUT_STATS.values())
    xml_content.append(f'      <total_prompts>{total_prompts}</total_prompts>')
    xml_content.append(f'      <total_words>{total_words}</total_words>')
    if total_prompts > 0:
        xml_content.append(f'      <average_words_per_prompt>{total_words // total_prompts}</average_words_per_prompt>')
        xml_content.append('      <breakdown_by_action_type>')
        for action_type, stats in sorted(LLM_INPUT_STATS.items()):
            if stats["count"] > 0:
                avg_words = stats["total_words"] // stats["count"]
                xml_content.append(f'        <action_type name="{action_type}" count="{stats["count"]}" total_words="{stats["total_words"]}" average_words="{avg_words}"/>')
        xml_content.append('      </breakdown_by_action_type>')
    xml_content.append('    </llm_statistics>')
    xml_content.append('  </metadata>')
    
    # Add structured log entries in chronological order
    xml_content.append('  <log_entries>')
    for entry in gs.xml_log:
        attrs = ' '.join([f'{k}="{v}"' for k, v in entry["attributes"].items() if v is not None])
        if attrs:
            xml_content.append(f'    <{entry["type"]} id="{entry["id"]}" phase="{entry["phase"]}" day="{entry["day"]}" {attrs}>')
        else:
            xml_content.append(f'    <{entry["type"]} id="{entry["id"]}" phase="{entry["phase"]}" day="{entry["day"]}">')
        
        # Escape XML content
        content = entry["content"].replace('&', '&amp;').replace('<', '&lt;').replace('>', '&gt;').replace('"', '&quot;').replace("'", '&apos;')
        xml_content.append(f'      {content}')
        xml_content.append(f'    </{entry["type"]}>')
    xml_content.append('  </log_entries>')
    
    # Add legacy logs for backward compatibility
    xml_content.append('  <legacy_logs>')
    xml_content.append('    <public_log>')
    for log in gs.public_log:
        msg = log["msg"].replace('&', '&amp;').replace('<', '&lt;').replace('>', '&gt;').replace('"', '&quot;').replace("'", '&apos;')
        xml_content.append(f'      <entry phase_tick_id="{log["phase_tick_id"]}">{msg}</entry>')
    xml_content.append('    </public_log>')
    xml_content.append('    <storyteller_log>')
    for log in gs.storyteller_log:
        msg = log.replace('&', '&amp;').replace('<', '&lt;').replace('>', '&gt;').replace('"', '&quot;').replace("'", '&apos;')
        xml_content.append(f'      <entry>{msg}</entry>')
    xml_content.append('    </storyteller_log>')
    xml_content.append('  </legacy_logs>')
    
    xml_content.append('</game_log>')
    
    # Write to file
    try:
        with open(filename, 'w', encoding='utf-8') as f:
            f.write('\n'.join(xml_content))
        print_colored(f"Interim game log saved to {filename}", 'STORYTELLER')
        print_colored("This is a preliminary copy at the end of Day 5.", 'STORYTELLER')
    except Exception as e:
        print_colored(f"Error saving interim XML log: {e}", 'ERROR')

# def save_logs_to_pdf(gs: GameState, filename=None):
#     """Legacy PDF logging function - kept for backward compatibility."""
#     if filename is None:
#         timestamp = datetime.now().strftime('%Y%m%d_%H%M%S')
#         filename = f"botc_game_log_{timestamp}.pdf"
#     try:
#         from fpdf import FPDF
#     except ImportError:
#         print_colored("fpdf not installed. Please install with: pip install fpdf", 'ERROR')
#         return
#     pdf = FPDF()
#     pdf.add_page()
#     pdf.set_font("Arial", size=10)
#     pdf.cell(0, 10, "Blood on the Clocktower Game Log", ln=True)
    
#     # Add LLM Input Statistics
#     pdf.cell(0, 10, "LLM Input Statistics:", ln=True)
#     total_prompts = sum(stats["count"] for stats in LLM_INPUT_STATS.values())
#     total_words = sum(stats["total_words"] for stats in LLM_INPUT_STATS.values())
    
#     if total_prompts > 0:
#         pdf.cell(0, 8, f"Total LLM prompts: {total_prompts}", ln=True)
#         pdf.cell(0, 8, f"Total words input: {total_words:,}", ln=True)
#         pdf.cell(0, 8, f"Average words per prompt: {total_words // total_prompts:,}", ln=True)
#         pdf.cell(0, 8, "Breakdown by action type:", ln=True)
        
#         for action_type, stats in sorted(LLM_INPUT_STATS.items()):
#             if stats["count"] > 0:
#                 avg_words = stats["total_words"] // stats["count"]
#                 pdf.cell(0, 6, f"  {action_type}: {stats['count']} prompts, {stats['total_words']:,} words total, {avg_words:,} avg", ln=True)
#     else:
#         pdf.cell(0, 8, "No LLM prompts were used in this game.", ln=True)
    
#     pdf.cell(0, 10, "Public Log:", ln=True)
#     for log in gs.public_log:
#         msg = sanitize_for_pdf(f"[PUBLIC] {log['msg']}")
#         pdf.multi_cell(0, 8, msg)
#     pdf.cell(0, 10, "Storyteller Log:", ln=True)
#     for log in gs.storyteller_log:
#         msg = sanitize_for_pdf(f"[STORYTELLER] {log}")
#         pdf.multi_cell(0, 8, msg)
#     pdf.output(filename)
#     print_colored(f"Game log saved to {filename}", 'STORYTELLER')

def demon_minion_info(gs: GameState):
    """Give the Imp and Minions their starting information (first night only)."""
    # Find all demons (including Bad Moon Rising demons)
    demons = [p for p in gs.players if p.role.alignment == Alignment.DEMON]
    minions = [p for p in gs.players if p.role.alignment is Alignment.MINION]
    in_play_names = {p.role.name for p in gs.players}
    
    # Select bluff candidates based on character set
    if gs.character_set == 1:  # Trouble Brewing only
        available_roles = TB_ROLES
    elif gs.character_set == 2:  # Bad Moon Rising only
        available_roles = BMR_ROLES
    else:  # Both character sets
        available_roles = ALL_ROLES
    
    all_bluff_candidates = [r.name for r in available_roles if r.alignment in {Alignment.TOWNSFOLK, Alignment.OUTSIDER} and r.name not in in_play_names]
    bluffs = random.sample(all_bluff_candidates, min(3, len(all_bluff_candidates)))
    
    # Handle each demon
    for demon in demons:
        if demon.role.name == "Imp":
            # Only assign bluffs if not already set (avoid overwriting setup bluffs)
            if "bluffs" not in demon.memory:
                demon.memory["bluffs"] = bluffs
            demon.memory["minions"] = [f"{p.name} (Seat {p.seat})" for p in minions]
            minion_str = ', '.join(f"{p.name} (Seat {p.seat})" for p in minions) if minions else "None"
            bluff_str = ', '.join(demon.memory["bluffs"]) if "bluffs" in demon.memory else "None"
            msg = f"As the Imp, your minions are: {minion_str}. Your three bluff roles are: {bluff_str}."
            if is_human_player(demon):
                print_colored(f"[PRIVATE] {msg}", 'PRIVATE')
            gs.log_secret(f"[PRIVATE] {demon.label()} (Imp) is told: {msg}")
        else:
            # Bad Moon Rising demons
            demon.memory["minions"] = [f"{p.name} (Seat {p.seat})" for p in minions]
            minion_str = ', '.join(f"{p.name} (Seat {p.seat})" for p in minions) if minions else "None"
            msg = f"As the {demon.role.name}, your minions are: {minion_str}."
            if is_human_player(demon):
                print_colored(f"[PRIVATE] {msg}", 'PRIVATE')
            gs.log_secret(f"[PRIVATE] {demon.label()} ({demon.role.name}) is told: {msg}")
    
    # Handle minions
    for minion in minions:
        # Find the demon (prioritize Imp if multiple demons exist)
        demon = next((d for d in demons if d.role.name == "Imp"), None) or (demons[0] if demons else None)
        minion.memory["demon"] = f"{demon.name} (Seat {demon.seat})" if demon else None
        minion.memory["other_minions"] = [f"{p.name} (Seat {p.seat})" for p in minions if p is not minion]
        demon_str = f"{demon.name} (Seat {demon.seat})" if demon else "None"
        other_minion_str = ', '.join(f"{p.name} (Seat {p.seat})" for p in minions if p is not minion) or "None"
        msg = f"As a minion, the Demon is {demon_str}. Other minions: {other_minion_str}."
        if is_human_player(minion):
            print_colored(f"[PRIVATE] {msg}", 'PRIVATE')
        gs.log_secret(f"[PRIVATE] {minion.label()} (Minion) is told: {msg}")
    
    # Handle Lunatic (they think they're the Demon)
    lunatic = next((p for p in gs.players if p.role.name == "Lunatic"), None)
    if lunatic:
        # Determine what demon type the Lunatic thinks they are
        # They should think they're the same demon type as the real demon
        real_demon = next((d for d in demons), None)
        if real_demon:
            fake_demon_type = real_demon.role.name
        else:
            # Fallback if no real demon (shouldn't happen)
            fake_demon_type = "Imp"
        
        # Create fake minions (random players, which may or may not be the actual minions)
        # Exclude the Lunatic from being minions
        potential_minions = [p for p in gs.players if p != lunatic]
        num_minions = len(minions)  # Same number as real minions
        minion_players = random.sample(potential_minions, min(num_minions, len(potential_minions)))
        minion_names = [f"{p.name} (Seat {p.seat})" for p in minion_players]
        
        # Store the fake demon info
        lunatic.hidden_state["lunatic_demon_info"] = {
            "fake_demon_type": fake_demon_type
        }
        
        # Give Lunatic the same message format as the real demon would get
        # All demons get bluffs if there are 7+ players (Trouble Brewing rule)
        if len(gs.players) >= 7:
            # Only assign bluffs if not already set (avoid overwriting setup bluffs)
            if "bluffs" not in lunatic.memory:
                lunatic.memory["bluffs"] = bluffs
            lunatic.memory["minions"] = minion_names
            minion_str = ', '.join(minion_names) if minion_names else "None"
            bluff_str = ', '.join(lunatic.memory["bluffs"]) if "bluffs" in lunatic.memory else "None"
            msg = f"As the {fake_demon_type}, your minions are: {minion_str}. Your three bluff roles are: {bluff_str}."
        else:
            # No bluffs for smaller games
            lunatic.memory["minions"] = minion_names
            minion_str = ', '.join(minion_names) if minion_names else "None"
            msg = f"As the {fake_demon_type}, your minions are: {minion_str}."
        
        if is_human_player(lunatic):
            print_colored(f"[PRIVATE] {msg}", 'PRIVATE')
        gs.log_secret(f"[PRIVATE] {lunatic.label()} (Lunatic) thinks they are the {fake_demon_type} and is told: {msg}")
        
        # Give minions fake info about Lunatic (they think Lunatic is the Demon)
        for minion in minions:
            minion.memory["demon"] = f"{lunatic.name} (Seat {lunatic.seat})"
            gs.log_secret(f"Minion {minion.label()} thinks Demon is: {lunatic.name} (Seat {lunatic.seat})")

def butler_ability(gs: GameState, player: Player):
    """Butler chooses a player (not self): they are their master for the next day."""
    others = [p for p in gs.players if p.alive and p is not player]
    if not others:
        gs.log_secret(f"Butler â†’ {player.label()} ability failed (no valid targets).")
        return
    
    # Get target selection (same for both drunk and normal)
    if is_human_player(player):
        print_llm_prompt_for_seat(player, f"[YOUR TURN] {player.name} (Seat {player.seat}), choose your master (not yourself).", 'PROMPT')
        print_llm_prompt_for_seat(player, f"Other living players: {', '.join(f'{p.name} (Seat {p.seat})' for p in others)}", 'PUBLIC')
        while True:
            choice = input(f"Enter seat number or name for your master: ").strip().lower()
            target = None
            try:
                seat_num = int(choice)
                target = next((p for p in others if p.seat == seat_num), None)
            except ValueError:
                matches = [p for p in others if p.name.lower() == choice]
                if not matches:
                    matches = [p for p in others if p.name.lower().startswith(choice)]
                if len(matches) == 1:
                    target = matches[0]
            if target is None or target is player:
                print_colored("Invalid choice. Please enter a valid seat number (0-indexed) or player name (not yourself).", 'ERROR')
                continue
            break
    elif is_llm_player(player):
        prompt = format_player_prompt(gs, player, "target_selection", options=others)
        print_llm_prompt_for_seat(player, f"Prompting LLM for Butler (Seat {player.seat}) target_selection", 'PROMPT')
        # Explicitly log the Butler prompt
        prompt_content = '\n'.join([f"{m['role'].upper()}: {m['content']}" for m in prompt])
        gs.log_llm_prompt(player, "butler_target_selection", prompt_content, label=f"Butler (Seat {player.seat}) target_selection")
        llm_response = call_gpt(prompt, label=f"Butler (Seat {player.seat}) target_selection")
        seat = parse_llm_response(llm_response, "target_selection", options=others)
        target = next((p for p in others if p.seat == seat), random.choice(others))
    else:
        target = random.choice(others)
    
    # Set message (same for both drunk and normal)
    msg = f"You have chosen {target.name} (Seat {target.seat}) as your master for tomorrow. You may only vote if they are voting too."
    
    # Handle drunk vs normal with minimal branching
    if player.drunk:
        # Drunk: same message but no actual effect
        gs.log_secret(f"[PRIVATE] {player.label()} is told: {msg} (drunk - no actual effect)")
    else:
        # Normal: same message and actual effect
        gs.log_secret(f"[PRIVATE] {player.label()} is told: {msg}")
    
    if is_human_player(player):
        print_llm_prompt_for_seat(player, f"[PRIVATE] {msg}", 'PRIVATE')
    
    # Store result with night information
    player.memory["butler"] = {"type": "butler", "data": {"master": target.seat, "night": gs.day}}
    gs.log_secret(f"Butler â†’ {player.label()} chooses master seat {target.seat}.")

def spy_ability(gs: GameState, player: Player):
    """Spy sees the Grimoire each night."""
    # For now, just log that the Spy sees the grimoire (full info)
    grimoire = get_game_snapshot(gs, for_player=player)
    msg = f"As the Spy, you see the Grimoire (all roles and states):\n{grimoire}"
    if is_human_player(player):
        print_llm_prompt_for_seat(player, f"[PRIVATE] {msg}", 'PRIVATE')
    gs.log_secret(f"[PRIVATE] {player.label()} (Spy) is told: {msg}")

def poisoner_ability(gs: GameState, player: Player):
    """Poisoner chooses a player to poison each night."""
    others = [p for p in gs.players if p.alive and p is not player]
    if not others:
        gs.log_secret(f"Poisoner â†’ {player.label()} ability failed (no valid targets).")
        return
    
    # Get target selection (same for both drunk and normal)
    if is_human_player(player):
        print_llm_prompt_for_seat(player, f"[YOUR TURN] {player.name} (Seat {player.seat}), choose a player to poison.", 'PROMPT')
        print_llm_prompt_for_seat(player, f"Other living players: {', '.join(f'{p.name} (Seat {p.seat})' for p in others)}", 'PUBLIC')
        while True:
            choice = input(f"Enter seat number or name to poison: ").strip().lower()
            target = None
            try:
                seat_num = int(choice)
                target = next((p for p in others if p.seat == seat_num), None)
            except ValueError:
                matches = [p for p in others if p.name.lower() == choice]
                if not matches:
                    matches = [p for p in others if p.name.lower().startswith(choice)]
                if len(matches) == 1:
                    target = matches[0]
            if target is None:
                print_colored("Invalid choice. Please enter a valid seat number or player name.", 'ERROR')
                continue
            break
    elif is_llm_player(player):
        prompt = format_player_prompt(gs, player, "target_selection", options=others)
        print_llm_prompt_for_seat(player, f"Prompting LLM for Poisoner (Seat {player.seat}) target_selection", 'PROMPT')
        # Explicitly log the Poisoner prompt
        prompt_content = '\n'.join([f"{m['role'].upper()}: {m['content']}" for m in prompt])
        gs.log_llm_prompt(player, "poisoner_target_selection", prompt_content, label=f"Poisoner (Seat {player.seat}) target_selection")
        llm_response = call_gpt(prompt, label=f"Poisoner (Seat {player.seat}) target_selection")
        seat = parse_llm_response(llm_response, "target_selection", options=others)
        target = next((p for p in others if p.seat == seat), random.choice(others))
    else:
        target = random.choice(others)
    
    # Set message (same for both drunk and normal)
    msg = f"You have poisoned {target.name} (Seat {target.seat}) for tonight and tomorrow day."
    
    # Handle drunk vs normal with minimal branching
    if player.drunk:
        # Drunk: same message but no actual poisoning
        gs.log_secret(f"[PRIVATE] {player.label()} is told: {msg} (drunk - no actual poisoning)")
    else:
        # Normal: actually poison the target
        mark_poisoned(target, nights=1)
        gs.log_secret(f"[PRIVATE] {player.label()} is told: {msg}")
    
    if is_human_player(player):
        print_llm_prompt_for_seat(player, f"[PRIVATE] {msg}", 'PRIVATE')
    
    # Store result with night information
    player.memory["poisoner"] = {"type": "poisoner", "data": {"target": target.seat, "night": gs.day}}
    gs.log_secret(f"Poisoner â†’ {player.label()} poisons seat {target.seat}.")

def run_imp_ability(gs: GameState, player: Player):
    """Imp chooses a player to kill each night (except first night)."""
    # Only allow targeting living players
    others = [p for p in gs.players if p.alive and p is not player]
    if not others:
        gs.log_secret(f"Imp â†’ {player.label()} ability failed (no valid targets).")
        return
    
    # Get target selection (same for both drunk and normal)
    if is_human_player(player):
        print_llm_prompt_for_seat(player, f"[YOUR TURN] {player.name} (Seat {player.seat}), choose a player to kill.", 'PROMPT')
        print_llm_prompt_for_seat(player, f"Other living players: {', '.join(f'{p.name} (Seat {p.seat})' for p in others)}", 'PUBLIC')
        while True:
            choice = input(f"Enter seat number or name to kill: ").strip().lower()
            target = None
            try:
                seat_num = int(choice)
                target = next((p for p in others if p.seat == seat_num), None)
            except ValueError:
                matches = [p for p in others if p.name.lower() == choice]
                if not matches:
                    matches = [p for p in others if p.name.lower().startswith(choice)]
                if len(matches) == 1:
                    target = matches[0]
            if target is None:
                print_colored("Invalid choice. Please enter a valid seat number or player name.", 'ERROR')
                continue
            break
        
        # Log the target selection
        gs.log_target_selection(player, "imp_kill", target)
    elif is_llm_player(player):
        prompt = format_player_prompt(gs, player, "target_selection", options=others)
        prompt.append({
            "role": "system",
            "content": "IMPORTANT: You are the Demon. You should generally avoid targeting your own teammates (other evil players). Focus on eliminating good players to help your team win."
        })
        print_llm_prompt_for_seat(player, f"Prompting LLM for Imp (Seat {player.seat}) target_selection", 'PROMPT')
        # Explicitly log the Imp prompt
        prompt_content = '\n'.join([f"{m['role'].upper()}: {m['content']}" for m in prompt])
        gs.log_llm_prompt(player, "imp_target_selection", prompt_content, label=f"Imp (Seat {player.seat}) target_selection")
        llm_response = call_gpt(prompt, label=f"Imp (Seat {player.seat}) target_selection")
        seat = parse_llm_response(llm_response, "target_selection", options=others)
        target = next((p for p in others if p.seat == seat), random.choice(others))
        
        # Log the target selection
        gs.log_target_selection(player, "imp_kill", target)
    else:
        target = random.choice(others)
        # Log the target selection
        gs.log_target_selection(player, "imp_kill", target)
    
    msg = f"You have chosen to kill {target.name} (Seat {target.seat}) tonight."
    
    # Handle drunk vs normal with minimal branching
    if player.drunk:
        # Drunk: same message but no actual kill
        gs.log_secret(f"[PRIVATE] {player.label()} is told: {msg} (drunk - no actual kill)")
        success = False
    else:
        # Normal: actually try to kill the target
        # --- Only allow killing living players ---
        if not target.alive:
            gs.log_secret(f"[ERROR] Imp {player.label()} tried to kill dead player {target.label()}. Action ignored.")
            success = False
        # --- Monk protection: if target is protected, Imp's kill fails ---
        elif target.hidden_state.get("protected_by_monk"):
            gs.memory["killed_by_demon"] = None
            gs.log_secret(f"Imp tried to kill {target.label()}, but they were protected by the Monk.")
            success = False
        # Soldier logic: immune to demon kills and poison unless drunk
        elif target.role.name == "Soldier" and is_sober_trustworthy(target):
            gs.memory["killed_by_demon"] = None
            if DEBUG_ALL_LOGS:
                gs.log_secret(f"Imp tried to kill Soldier {target.label()} but failed (immune).")
            success = False
        else:
            # --- Mark the target as dead immediately to prevent double-kill ---
            target.alive = False
            gs.memory["killed_by_demon"] = target
            success = True
        
        gs.log_secret(f"[PRIVATE] {player.label()} is told: {msg}")
    
    if is_human_player(player):
        print_llm_prompt_for_seat(player, f"[PRIVATE] {msg}", 'PRIVATE')
    
    # Store result with night information
    player.memory["imp"] = {"type": "imp", "data": {"target": target.seat, "night": gs.day, "success": success}}
    gs.log_secret(f"Imp â†’ {player.label()} kills seat {target.seat}. Success: {success}.")

# --- Passive/Edge/Placeholder Abilities for All Roles ---
def slayer_ability(gs: GameState, player: Player, target=None):
    """Slayer: Once per game, during the day, publicly choose a player: if they are the Demon, they die."""
    # Internal validation - log warnings to storyteller but don't reveal info publicly
    if player.role.name != "Slayer":
        gs.log_secret(f"[WARNING] Non-Slayer {player.label()} tried to use Slayer ability.")
        return False
    if not player.alive:
        gs.log_secret(f"[WARNING] Dead Slayer {player.label()} tried to use Slayer ability.")
        return False
    if player.memory.get("slayer_used", False):
        gs.log_secret(f"[WARNING] Slayer {player.label()} tried to use ability again.")
        return False
    if not target:
        gs.log_secret(f"[WARNING] Slayer {player.label()} tried to use ability with no target.")
        return False
    
    # Valid Slayer attempt - mark as used
    player.memory["slayer_used"] = True
    gs.log_secret(f"Slayer {player.label()} attempts shot on {target.label()}")
    
    # Check if shot succeeds (target is Demon and Slayer is sober/trustworthy)
    if target.role.alignment is Alignment.DEMON and is_sober_trustworthy(player):
        target.alive = False
        target.hidden_state["died_night"] = "day"  # Track that they died during the day (not eligible for Shabaloth regurgitation)
        gs.log_secret(f"Slayer shot SUCCESS: {player.label()} killed Demon {target.label()}")
        gs.memory["executed_today"] = target
        # Track this day death for Zombuul ability
        if "day_deaths" not in gs.memory:
            gs.memory["day_deaths"] = []
        gs.memory["day_deaths"].append(target.seat)
        # Check win condition after Slayer kills Demon
        if check_win_condition(gs):
            gs.phase = Phase.END
        return True
    else:
        if target.role.alignment is not Alignment.DEMON:
            gs.log_secret(f"Slayer shot FAILED: {player.label()} shot {target.label()} but they were not the Demon (they are {target.role.name})")
        else:
            gs.log_secret(f"Slayer shot FAILED: {player.label()} shot {target.label()} but the Slayer was not sober/trustworthy")
        return False

def soldier_ability(gs: GameState, player: Player):
    gs.log_secret(f"Soldier â†’ {player.label()} ability is passive.")
def virgin_ability(gs: GameState, player: Player):
    gs.log_secret(f"Virgin â†’ {player.label()} ability is handled during nominations.")
def mayor_ability(gs: GameState, player: Player):
    gs.log_secret(f"Mayor â†’ {player.label()} ability is passive or handled at win check.")
def saint_ability(gs: GameState, player: Player):
    gs.log_secret(f"Saint â†’ {player.label()} ability is handled during execution.")
def recluse_ability(gs: GameState, player: Player):
    gs.log_secret(f"Recluse â†’ {player.label()} ability is passive (registers as evil/minion/demon randomly).")
def drunk_ability(gs: GameState, player: Player):
    gs.log_secret(f"Drunk â†’ {player.label()} ability is passive (thinks they are a Townsfolk).")
def scarlet_woman_ability(gs: GameState, player: Player):
    gs.log_secret(f"Scarlet Woman â†’ {player.label()} ability is handled when the Imp dies.")
def baron_ability(gs: GameState, player: Player):
    gs.log_secret(f"Baron â†’ {player.label()} ability is handled at setup (adds Outsiders).")

# --- Helper for Recluse registration ---
def recluse_registers_as_evil_or_minion_or_demon(player):
    """Returns True if the Recluse should register as evil/minion/demon for info roles (randomly)."""
    if player.role.name != "Recluse":
        return False
    # 2/3 chance to register as evil, 1/3 as minion, 1/3 as demon
    roll = random.random()
    if roll < 1/3:
        return "minion" # This and other responses are correct; it should not return "true" -- but it is important that all uses of this function recognize this is not supposed to return a boolean.
    elif roll < 2/3:
        return "demon"
    else:
        return "evil"

# --- Debug/Testing Mode ---
DEBUG_ALL_LOGS = False  # Set to True to print all logs and LLM prompts for testing

# --- Override log_secret and log_public to print if DEBUG_ALL_LOGS ---
# (Patch GameState methods)
GameState._orig_log_secret = GameState.log_secret
GameState._orig_log_public = GameState.log_public

def log_secret_debug(self, m):
    self.storyteller_log.append(m)
    if DEBUG_ALL_LOGS:
        print_colored(m, 'STORYTELLER')
GameState.log_secret = log_secret_debug

def log_public_debug(self, m):
    self.public_log.append({"msg": m, "phase_tick_id": self.phase_tick_id})
    print_colored(m, 'PUBLIC')
    if DEBUG_ALL_LOGS:
        print_colored(m, 'PUBLIC')
GameState.log_public = log_public_debug

class GameEndException(Exception):
    """Exception to signal early game termination"""
    pass

# --- Bad Moon Rising Character Abilities ---

# First Night Abilities
def grandparent_ability(gs: GameState, player: Player):
    """Grandparent learns a good player and character. If the Demon kills them, you die too."""
    gs.log_action_start("grandparent_ability", player)
    
    def normal_fn():
        # Find good players (Townsfolk and Outsiders)
        good_players = [p for p in gs.players if p.role.alignment in {Alignment.TOWNSFOLK, Alignment.OUTSIDER}]
        if not good_players:
            return None
        
        target = random.choice(good_players)
        msg = f"You know that {target.name} (Seat {target.seat}) is the {target.role.name}."
        if is_human_player(player):
            print_colored(f"[PRIVATE] {player.name} (Seat {player.seat}) is told: {msg}", 'PRIVATE')
        gs.log_secret(f"[PRIVATE] {player.label()} is told: {msg}")
        
        # Store the target for death trigger
        player.memory["grandparent_target"] = {"target": target.seat, "night": gs.day}
        return {"target": target.seat, "role": target.role.name}
    
    def drunk_fn():
        # Drunk Grandparent gets false information
        random_player = random.choice(gs.players)
        random_role = random.choice(TOWNSFOLK + OUTSIDERS).name
        msg = f"You know that {random_player.name} (Seat {random_player.seat}) is the {random_role}."
        if is_human_player(player):
            print_colored(f"[PRIVATE] {player.name} (Seat {player.seat}) is told: {msg}", 'PRIVATE')
        gs.log_secret(f"[PRIVATE] {player.label()} is told: {msg}")
        return {"target": random_player.seat, "role": random_role}
    
    result = resolve_ability(player, normal_fn, drunk_fn)
    if result:
        player.memory["grandparent"] = result
    gs.log_action_end("grandparent_ability", f"Learned {result['role']} in seat {result['target']}" if result else "Failed", player)

def capo_crimini_ability(gs: GameState, player: Player):
    """Capo Crimini learns which Outsiders are in play. If 1 died today, choose a player tonight: they die."""
    gs.log_action_start("capo_crimini_ability", player)
    
    def normal_fn():
        # Find all Outsiders in play
        outsiders_in_play = [p for p in gs.players if p.role.alignment == Alignment.OUTSIDER]
        outsider_names = [p.role.name for p in outsiders_in_play]
        
        msg = f"You know that the following Outsiders are in play: {', '.join(outsider_names)}."
        if is_human_player(player):
            print_colored(f"[PRIVATE] {player.name} (Seat {player.seat}) is told: {msg}", 'PRIVATE')
        gs.log_secret(f"[PRIVATE] {player.label()} is told: {msg}")
        
        return {"outsiders": outsider_names}
    
    def drunk_fn():
        # Drunk Capo gets false information
        random_outsiders = random.sample([r.name for r in OUTSIDERS], random.randint(0, 2))
        msg = f"You know that the following Outsiders are in play: {', '.join(random_outsiders) if random_outsiders else 'none'}."
        if is_human_player(player):
            print_colored(f"[PRIVATE] {player.name} (Seat {player.seat}) is told: {msg}", 'PRIVATE')
        gs.log_secret(f"[PRIVATE] {player.label()} is told: {msg}")
        return {"outsiders": random_outsiders}
    
    result = resolve_ability(player, normal_fn, drunk_fn)
    if result:
        player.memory["capo_crimini"] = result
    gs.log_action_end("capo_crimini_ability", f"Learned Outsiders: {result['outsiders']}" if result else "Failed", player)

# Passive Abilities (no night action needed)
def tinker_ability(gs: GameState, player: Player):
    """Tinker might die at any time."""
    # This is handled by random death chance during night phase
    pass

def herbalist_ability(gs: GameState, player: Player):
    """If both your alive neighbours are good, they can't die."""
    # This is handled by checking neighbors during death attempts
    pass

def pacifist_ability(gs: GameState, player: Player):
    """Executed good players might not die."""
    # This is handled during execution phase
    pass

def fool_ability(gs: GameState, player: Player):
    """The first time you die, you don't."""
    # This is handled by attempt_kill_player function
    pass

def minstrel_ability(gs: GameState, player: Player):
    """When a Minion dies by execution, all other players (except Travellers) are drunk until dusk tomorrow."""
    # This is handled during execution phase
    pass

def mastermind_ability(gs: GameState, player: Player):
    """If the Demon dies by execution (ending the game), play for 1 more day. If a player is then executed, their team loses."""
    # This is handled during execution phase
    pass

def get_sailor_choice(gs: GameState, player: Player, targets):
    """Helper function to get Sailor choice (common for both normal and drunk)"""
    if is_human_player(player):
        effective_role_name = get_effective_role_name(player)
        print_colored(f"[PRIVATE] {player.name} (Seat {player.seat}), you are the {effective_role_name}.", 'PRIVATE')
        print_colored(f"[PRIVATE] Each night, choose a living player. Either you or they will become drunk until dusk (this is random and unknown to you). You cannot die.", 'PRIVATE')
        print_colored(f"[PRIVATE] Choose a player to target:", 'PRIVATE')
        
        # Show available targets
        for i, target in enumerate(targets, 1):
            print_colored(f"[PRIVATE] {i}. {target.name} (Seat {target.seat})", 'PRIVATE')
        
        while True:
            try:
                choice = int(input(f"[PRIVATE] Enter your choice (1-{len(targets)}): ").strip())
                if 1 <= choice <= len(targets):
                    target = targets[choice - 1]
                    break
                else:
                    print_colored(f"[PRIVATE] Please enter a number between 1 and {len(targets)}.", 'PRIVATE')
            except ValueError:
                print_colored(f"[PRIVATE] Please enter a valid number.", 'PRIVATE')
        

    else:
        # LLM player - use LLM to make choice
        prompt = format_player_prompt(gs, player, "target_selection")
        effective_role_name = get_effective_role_name(player)
        prompt.append({
            "role": "system",
            "content": f"You are the {effective_role_name}. Each night, choose a living player. Either you or they will become drunk until dusk (this is random and unknown to you). Available targets: {', '.join(f'{t.name} (Seat {t.seat})' for t in targets)}"
        })
        
        llm_response = call_gpt(prompt, label=f"Sailor targeting (Seat {player.seat})")
        target_name = parse_llm_response(llm_response, "targeting", options=[t.name for t in targets], player=player)
        
        # Find the target
        target = next((t for t in targets if t.name.lower() == target_name.lower()), None)
        if not target:
            # Fallback to random choice if LLM fails
            target = random.choice(targets)
    
    return {"target": target}

# Night Abilities
def sailor_ability(gs: GameState, player: Player):
    """Each night, choose a living player. Either you or they will become drunk until dusk (this is random and unknown to you). You can not die."""
    gs.log_action_start("sailor_ability", player)
    
    # Sailor cannot die normally (permanent protection, except when they become drunk, or if they are killed by assassin)
    player.can_die = False
    
    def normal_fn():
        targets = get_targetable_players(gs, allow_dead=False, exclude_self=player)
        if not targets:
            gs.log_secret(f"Sailor {player.label()} has no valid targets.")
            return None
        
        # Get player choice (common logic for both normal and drunk)
        choice_result = get_sailor_choice(gs, player, targets)
        if choice_result is None:
            return None
        
        target = choice_result["target"]
        
        # Handle Goon targeting
        handle_goon_targeting(gs, player, target)
        
        # Apply drunkenness randomly (Sailor doesn't know who becomes drunk)
        actual_drunk_choice = random.choice([1, 2])  # 1 = Sailor, 2 = Target
        
        if actual_drunk_choice == 1:
            # Sailor becomes drunk
            mark_drunk(player, gs.day + 1)  # Drunk until dusk tomorrow
            gs.log_secret(f"Sailor {player.label()} becomes drunk until dusk tomorrow (random choice).")
        else:
            # Target becomes drunk
            mark_drunk(target, gs.day + 1)  # Drunk until dusk tomorrow
            gs.log_secret(f"Sailor {player.label()} makes {target.label()} drunk until dusk tomorrow (random choice).")
        
        # Sailor is told they chose someone but doesn't know who actually became drunk
        msg = f"You choose {target.name} (Seat {target.seat})."
        
        if is_human_player(player):
            print_colored(f"[PRIVATE] {player.name} (Seat {player.seat}) is told: {msg}", 'PRIVATE')
        
        return {"target": target.seat, "sailor_drunk": (actual_drunk_choice == 1)}
    
    def drunk_fn():
        # Drunk Sailor thinks their ability works but it actually doesn't, and they are not told anything different.
        # They should be able to choose targets as normal, but their ability has no effect
        targets = get_targetable_players(gs, allow_dead=False, exclude_self=player)
        if not targets:
            return None
        
        # Get player choice (common logic for both normal and drunk)
        choice_result = get_sailor_choice(gs, player, targets)
        if choice_result is None:
            return None
        
        target = choice_result["target"]
        
        # Drunk Sailor's ability has no effect, but they think it does
        # They are not told that their ability failed
        gs.log_secret(f"Drunk Sailor {player.label()} targets {target.label()}, but their ability has no effect (they are drunk/poisoned).")
        
        # Do NOT mark anyone as drunk (ability has no effect)
        
        # Create message for player (they think their ability worked)
        msg = f"You choose {target.name} (Seat {target.seat})."
        
        if is_human_player(player):
            print_colored(f"[PRIVATE] {player.name} (Seat {player.seat}) is told: {msg}", 'PRIVATE')
        
        return {"target": target.seat, "sailor_drunk": False}
    
    result = resolve_ability(player, normal_fn, drunk_fn)
    if result:
        player.memory["sailor"] = {"type": "sailor", "data": {"target": result["target"], "night": gs.day}}
    gs.log_action_end("sailor_ability", f"Targeted seat {result['target']}" if result else "Failed", player)

def housekeeper_ability(gs: GameState, player: Player):
    """Each night, choose 2 alive players (not yourself): you learn how many woke tonight due to their ability."""
    gs.log_action_start("housekeeper_ability", player)
    
    def normal_fn():
        targets = get_targetable_players(gs, allow_dead=False, exclude_self=player)
        if len(targets) < 2:
            gs.log_secret(f"Housekeeper {player.label()} needs 2 targets but only {len(targets)} available.")
            return None
        
        # Prompt human player for choice
        if is_human_player(player):
            effective_role_name = get_effective_role_name(player)
            print_colored(f"[PRIVATE] {player.name} (Seat {player.seat}), you are the {effective_role_name}.", 'PRIVATE')
            print_colored(f"[PRIVATE] Each night, choose 2 alive players (not yourself): you learn how many woke tonight due to their ability.", 'PRIVATE')
            print_colored(f"[PRIVATE] Choose 2 players to target:", 'PRIVATE')
            
            # Show available targets
            for i, target in enumerate(targets, 1):
                print_colored(f"[PRIVATE] {i}. {target.name} (Seat {target.seat})", 'PRIVATE')
            
            selected_targets = []
            for choice_num in [1, 2]:
                while True:
                    try:
                        choice = int(input(f"[PRIVATE] Enter your {choice_num}{'st' if choice_num == 1 else 'nd'} choice (1-{len(targets)}): ").strip())
                        if 1 <= choice <= len(targets):
                            target = targets[choice - 1]
                            if target not in selected_targets:
                                selected_targets.append(target)
                                break
                            else:
                                print_colored(f"[PRIVATE] You already chose {target.name}. Please choose a different player.", 'PRIVATE')
                        else:
                            print_colored(f"[PRIVATE] Please enter a number between 1 and {len(targets)}.", 'PRIVATE')
                    except ValueError:
                        print_colored(f"[PRIVATE] Please enter a valid number.", 'PRIVATE')
        else:
            # LLM player - use LLM to make choice
            prompt = format_player_prompt(gs, player, "target_selection")
            effective_role_name = get_effective_role_name(player)
            prompt.append({
                "role": "system",
                "content": f"You are the {effective_role_name}. Each night, choose 2 alive players (not yourself): you learn how many woke tonight due to their ability. Available targets: {', '.join(f'{t.name} (Seat {t.seat})' for t in targets)}"
            })
            
            llm_response = call_gpt(prompt, label=f"Housekeeper targeting (Seat {player.seat})")
            target_names = parse_llm_response(llm_response, "targeting", options=[t.name for t in targets], player=player)
            
            # Parse LLM response for two targets
            if isinstance(target_names, str):
                # Try to extract two names from the response
                words = target_names.split()
                selected_targets = []
                for word in words:
                    if len(selected_targets) >= 2:
                        break
                    target = next((t for t in targets if t.name.lower() == word.lower()), None)
                    if target and target not in selected_targets:
                        selected_targets.append(target)
            
            if len(selected_targets) < 2:
                # Fallback to random choice if LLM fails
                selected_targets = random.sample(targets, 2)
        
        # Count how many of these players have night abilities that would wake them
        woke_count = 0
        for target in selected_targets:
            if target.role.other_nights or target.role.name in ["Empath", "Fortune Teller", "Monk", "Undertaker", "Butler", "Spy"]:
                woke_count += 1
        
        msg = f"You choose {selected_targets[0].name} (Seat {selected_targets[0].seat}) and {selected_targets[1].name} (Seat {selected_targets[1].seat}). {woke_count} of them woke tonight due to their ability."
        if is_human_player(player):
            print_colored(f"[PRIVATE] {player.name} (Seat {player.seat}) is told: {msg}", 'PRIVATE')
        gs.log_secret(f"[PRIVATE] {player.label()} is told: {msg}")
        
        return {"targets": (selected_targets[0].seat, selected_targets[1].seat), "woke_count": woke_count}
    
    def drunk_fn():
        # Drunk Housekeeper gets false information
        targets = get_targetable_players(gs, allow_dead=False, exclude_self=player)
        if len(targets) < 2:
            return None
        
        selected_targets = random.sample(targets, 2)
        false_woke_count = random.randint(0, 2)
        
        msg = f"You choose {selected_targets[0].name} (Seat {selected_targets[0].seat}) and {selected_targets[1].name} (Seat {selected_targets[1].seat}). {false_woke_count} of them woke tonight due to their ability."
        if is_human_player(player):
            print_colored(f"[PRIVATE] {player.name} (Seat {player.seat}) is told: {msg}", 'PRIVATE')
        gs.log_secret(f"[PRIVATE] {player.label()} is told: {msg}")
        
        return {"targets": (selected_targets[0].seat, selected_targets[1].seat), "woke_count": false_woke_count}
    
    result = resolve_ability(player, normal_fn, drunk_fn)
    if result:
        player.memory["housekeeper"] = {"type": "housekeeper", "data": {"targets": result["targets"], "woke_count": result["woke_count"], "night": gs.day}}
    gs.log_action_end("housekeeper_ability", f"Targeted seats {result['targets']}, {result['woke_count']} woke" if result else "Failed", player)

def exorcist_ability(gs: GameState, player: Player):
    """Each night*, choose a player (different to last night): the Demon, if chosen, learns who you are then doesn't wake tonight."""
    gs.log_action_start("exorcist_ability", player)
    
    def normal_fn():
        # Check if we can use ability (different target from last night)
        last_target = player.memory.get("exorcist_last_target")
        targets = get_targetable_players(gs, allow_dead=False, exclude_self=player)
        
        # Filter out last night's target if it exists
        if last_target is not None:
            targets = [t for t in targets if t.seat != last_target]
        
        if not targets:
            gs.log_secret(f"Exorcist {player.label()} has no valid targets (different from last night).")
            return None
        
        # Prompt human player for choice
        if is_human_player(player):
            effective_role_name = get_effective_role_name(player)
            print_colored(f"[PRIVATE] {player.name} (Seat {player.seat}), you are the {effective_role_name}.", 'PRIVATE')
            print_colored(f"[PRIVATE] Each night*, choose a player (different to last night): the Demon, if chosen, learns who you are then doesn't wake tonight.", 'PRIVATE')
            if last_target is not None:
                print_colored(f"[PRIVATE] You cannot choose the same player as last night (Seat {last_target}).", 'PRIVATE')
            print_colored(f"[PRIVATE] Choose a player to target:", 'PRIVATE')
            
            # Show available targets
            for i, target in enumerate(targets, 1):
                print_colored(f"[PRIVATE] {i}. {target.name} (Seat {target.seat})", 'PRIVATE')
            
            while True:
                try:
                    choice = int(input(f"[PRIVATE] Enter your choice (1-{len(targets)}): ").strip())
                    if 1 <= choice <= len(targets):
                        target = targets[choice - 1]
                        break
                    else:
                        print_colored(f"[PRIVATE] Please enter a number between 1 and {len(targets)}.", 'PRIVATE')
                except ValueError:
                    print_colored(f"[PRIVATE] Please enter a valid number.", 'PRIVATE')
        else:
            # LLM player - use LLM to make choice
            prompt = format_player_prompt(gs, player, "target_selection")
            effective_role_name = get_effective_role_name(player)
            prompt.append({
                "role": "system",
                "content": f"You are the {effective_role_name}. Each night*, choose a player (different to last night): the Demon, if chosen, learns who you are then doesn't wake tonight. Available targets: {', '.join(f'{t.name} (Seat {t.seat})' for t in targets)}"
            })
            
            # Add information about last night's target if it exists
            if last_target is not None:
                prompt.append({
                    "role": "system",
                    "content": f"IMPORTANT: You cannot choose the same player as last night (Seat {last_target})."
                })
            
            llm_response = call_gpt(prompt, label=f"Exorcist targeting (Seat {player.seat})")
            target_name = parse_llm_response(llm_response, "targeting", options=[t.name for t in targets], player=player)
            
            # Find the target
            target = next((t for t in targets if t.name.lower() == target_name.lower()), None)
            if not target:
                # Fallback to random choice if LLM fails
                target = random.choice(targets)
        
        # Handle Goon targeting
        handle_goon_targeting(gs, player, target)
        
        # Store this target for next night
        player.memory["exorcist_last_target"] = target.seat
        
        # Check if target is the Demon
        if target.role.alignment == Alignment.DEMON:
            # Demon learns about Exorcist and doesn't wake tonight
            target.memory["exorcist_revealed"] = {"exorcist_seat": player.seat, "night": gs.day}
            gs.memory["demon_blocked_tonight"] = True
            gs.log_secret(f"Exorcist {player.label()} targets Demon {target.label()}, Demon learns about Exorcist and is blocked tonight.")
        else:
            gs.log_secret(f"Exorcist {player.label()} targets {target.label()}, no effect.")
        
        # Exorcist is not told whether they targeted the demon or not
        msg = f"You choose {target.name} (Seat {target.seat}). If that player is the demon, they will learn who you are but they will not be able to kill tonight."
        
        if is_human_player(player):
            print_colored(f"[PRIVATE] {player.name} (Seat {player.seat}) is told: {msg}", 'PRIVATE')
        
        return {"target": target.seat, "was_demon": target.role.alignment == Alignment.DEMON}
    
    def drunk_fn():
        # Drunk Exorcist makes random choice but doesn't actually block Demon
        # Check if we can use ability (different target from last night)
        last_target = player.memory.get("exorcist_last_target")
        targets = get_targetable_players(gs, allow_dead=False, exclude_self=player)
        
        # Filter out last night's target if it exists
        if last_target is not None:
            targets = [t for t in targets if t.seat != last_target]
        
        if not targets:
            gs.log_secret(f"Drunk Exorcist {player.label()} has no valid targets (different from last night).")
            return None
        
        target = random.choice(targets)
        
        # Store this target for next night
        player.memory["exorcist_last_target"] = target.seat
        
        # Drunk Exorcist is also not told whether they targeted the demon or not
        msg = f"You choose {target.name} (Seat {target.seat}). If that player is the demon, they will learn who you are but they will not be able to kill tonight."
        gs.log_secret(f"Drunk Exorcist {player.label()} targets {target.label()}, no effect.")
        
        if is_human_player(player):
            print_colored(f"[PRIVATE] {player.name} (Seat {player.seat}) is told: {msg}", 'PRIVATE')
        
        return {"target": target.seat, "was_demon": False}
    
    result = resolve_ability(player, normal_fn, drunk_fn)
    if result:
        # Store both the last target (for restriction) and the full data (for memory display)
        player.memory["exorcist_last_target"] = result["target"]
        player.memory["exorcist"] = {"type": "exorcist", "data": {"target": result["target"], "was_demon": result["was_demon"], "night": gs.day}}
    gs.log_action_end("exorcist_ability", f"Targeted seat {result['target']}" if result else "Failed", player)

def get_innkeeper_choice(gs: GameState, player: Player, targets):
    """Helper function to get Innkeeper choice (common for both normal and drunk)"""
    if is_human_player(player):
        effective_role_name = get_effective_role_name(player)
        print_colored(f"[PRIVATE] {player.name} (Seat {player.seat}), you are the {effective_role_name}.", 'PRIVATE')
        print_colored(f"[PRIVATE] Each night*, choose 2 players: they cannot die tonight, but 1 is drunk until dusk.", 'PRIVATE')
        print_colored(f"[PRIVATE] You do not know which one becomes drunk - this is determined randomly.", 'PRIVATE')
        print_colored(f"[PRIVATE] WARNING: If you choose yourself, you might become drunk, losing your ability and protection. This also will meant the other player is not protected.", 'PRIVATE')
        print_colored(f"[PRIVATE] Choose 2 players to target:", 'PRIVATE')
        
        # Show available targets
        for i, target in enumerate(targets, 1):
            print_colored(f"[PRIVATE] {i}. {target.name} (Seat {target.seat})", 'PRIVATE')
        
        selected_targets = []
        for choice_num in [1, 2]:
            while True:
                try:
                    choice = int(input(f"[PRIVATE] Enter your {choice_num}{'st' if choice_num == 1 else 'nd'} choice (1-{len(targets)}): ").strip())
                    if 1 <= choice <= len(targets):
                        target = targets[choice - 1]
                        if target not in selected_targets:
                            selected_targets.append(target)
                            break
                        else:
                            print_colored(f"[PRIVATE] You already chose {target.name}. Please choose a different player.", 'PRIVATE')
                    else:
                        print_colored(f"[PRIVATE] Please enter a number between 1 and {len(targets)}.", 'PRIVATE')
                except ValueError:
                    print_colored(f"[PRIVATE] Please enter a valid number.", 'PRIVATE')
        
        # Randomly choose which player becomes drunk (Innkeeper doesn't know)
        drunk_target = random.choice(selected_targets)
    else:
        # LLM player - use LLM to make choice
        prompt = format_player_prompt(gs, player, "target_selection")
        effective_role_name = get_effective_role_name(player)
        prompt.append({
            "role": "system",
            "content": f"You are the {effective_role_name}. Each night*, choose 2 players: they cannot die tonight, but 1 is drunk until dusk. You do not know which one becomes drunk - this is determined randomly. WARNING: If you choose yourself, you might become drunk, losing your ability and protection. This also will meant the other player is not protected. Available targets: {', '.join(f'{t.name} (Seat {t.seat})' for t in targets)}"
        })
        
        llm_response = call_gpt(prompt, label=f"Innkeeper targeting (Seat {player.seat})")
        target_names = parse_llm_response(llm_response, "targeting", options=[t.name for t in targets], player=player)
        
        # Parse LLM response for two targets
        if isinstance(target_names, str):
            # Try to extract two names from the response
            words = target_names.split()
            selected_targets = []
            for word in words:
                if len(selected_targets) >= 2:
                    break
                target = next((t for t in targets if t.name.lower() == word.lower()), None)
                if target and target not in selected_targets:
                    selected_targets.append(target)
        
        if len(selected_targets) < 2:
            # Fallback to random choice if LLM fails
            selected_targets = random.sample(targets, 2)
        
        # LLM also decides which becomes drunk
        drunk_target = random.choice(selected_targets)  # Fallback for LLM
    
    return {"selected_targets": selected_targets, "drunk_target": drunk_target}

def innkeeper_ability(gs: GameState, player: Player):
    """Each night*, choose 2 players: they can not die tonight, but 1 is drunk until dusk."""
    gs.log_action_start("innkeeper_ability", player)
    
    def normal_fn():
        targets = get_targetable_players(gs, allow_dead=False, exclude_self=False)  # Allow self-targeting
        if len(targets) < 2:
            gs.log_secret(f"Innkeeper {player.label()} needs 2 targets but only {len(targets)} available.")
            return None
        
        # Get player choice (common logic for both normal and drunk)
        choice_result = get_innkeeper_choice(gs, player, targets)
        if choice_result is None:
            return None
        
        selected_targets = choice_result["selected_targets"]
        drunk_target = choice_result["drunk_target"]
        mark_drunk(drunk_target, gs.day + 1)  # Drunk until dusk tomorrow
        
        # Protect both targets from death tonight
        for target in selected_targets:
            target.hidden_state["protected_by_innkeeper"] = True
        
        msg = f"You choose {selected_targets[0].name} (Seat {selected_targets[0].seat}) and {selected_targets[1].name} (Seat {selected_targets[1].seat}). They cannot die tonight, but one of them is drunk until dusk tomorrow. You do not know which one becomes drunk."
        if is_human_player(player):
            print_colored(f"[PRIVATE] {player.name} (Seat {player.seat}) is told: {msg}", 'PRIVATE')
        gs.log_secret(f"[PRIVATE] {player.label()} is told: {msg}")
        
        return {"targets": (selected_targets[0].seat, selected_targets[1].seat), "drunk_target": drunk_target.seat}
    
    def drunk_fn():
        # Drunk Innkeeper thinks their ability works but it actually doesn't, and they are not told anything different.
        # They should be able to choose targets as normal, but their ability has no effect
        targets = get_targetable_players(gs, allow_dead=False, exclude_self=False)  # Allow self-targeting
        if len(targets) < 2:
            return None
        
        # Get player choice (common logic for both normal and drunk)
        choice_result = get_innkeeper_choice(gs, player, targets)
        if choice_result is None:
            return None
        
        selected_targets = choice_result["selected_targets"]
        drunk_target = choice_result["drunk_target"]
        
        # Drunk Innkeeper's ability has no effect, but they think it does
        # They are not told that their ability failed
        gs.log_secret(f"Drunk Innkeeper {player.label()} targets {selected_targets[0].label()} and {selected_targets[1].label()}, makes {drunk_target.label()} drunk, but their ability has no effect (they are drunk/poisoned).")
        
        # Do NOT mark targets as protected (ability has no effect)
        # Do NOT mark anyone as drunk (ability has no effect)
        
        # Create message for player (they think their ability worked)
        msg = f"You choose {selected_targets[0].name} (Seat {selected_targets[0].seat}) and {selected_targets[1].name} (Seat {selected_targets[1].seat}). They cannot die tonight, but one of them is drunk until dusk tomorrow. You do not know which one becomes drunk."
        
        if is_human_player(player):
            print_colored(f"[PRIVATE] {player.name} (Seat {player.seat}) is told: {msg}", 'PRIVATE')
        
        return {"targets": (selected_targets[0].seat, selected_targets[1].seat), "drunk_target": drunk_target.seat}
    
    result = resolve_ability(player, normal_fn, drunk_fn)
    if result:
        player.memory["innkeeper"] = {"type": "innkeeper", "data": {"targets": result["targets"], "night": gs.day}}
    gs.log_action_end("innkeeper_ability", f"Protected seats {result['targets']}, drunk seat {result['drunk_target']}" if result else "Failed", player)

def get_gambler_choice(gs: GameState, player: Player, targets):
    """Helper function to get Gambler choice (common for both normal and drunk)"""
    if is_human_player(player):
        effective_role_name = get_effective_role_name(player)
        print_colored(f"[PRIVATE] {player.name} (Seat {player.seat}), you are the {effective_role_name}.", 'PRIVATE')
        print_colored(f"[PRIVATE] Each night*, choose a player & guess their character: if you guess wrong, you die.", 'PRIVATE')
        print_colored(f"[PRIVATE] You should probably only guess people who have publicly claimed to be a specific role. Guessing randomly is very risky and likely to kill you.", 'PRIVATE')
        print_colored(f"[PRIVATE] Choose a player to target:", 'PRIVATE')
        
        # Show available targets
        for i, target in enumerate(targets, 1):
            print_colored(f"[PRIVATE] {i}. {target.name} (Seat {target.seat})", 'PRIVATE')
        
        while True:
            try:
                choice = int(input(f"[PRIVATE] Enter your choice (1-{len(targets)}): ").strip())
                if 1 <= choice <= len(targets):
                    target = targets[choice - 1]
                    break
                else:
                    print_colored(f"[PRIVATE] Please enter a number between 1 and {len(targets)}.", 'PRIVATE')
            except ValueError:
                print_colored(f"[PRIVATE] Please enter a valid number.", 'PRIVATE')
        
        # Ask for role guess
        print_colored(f"[PRIVATE] What role do you think {target.name} is?", 'PRIVATE')
        # Determine which character sets to include based on gs.character_set
        # 1 = Trouble Brewing, 2 = Bad Moon Rising, 3 = Both
        include_tb = gs.character_set in [1, 3]
        include_bmr = gs.character_set in [2, 3]
        
        # Get available roles based on character set
        available_roles = []
        if include_tb:
            available_roles.extend([r.name for r in TB_ROLES])
        if include_bmr:
            available_roles.extend([r.name for r in BMR_ROLES])
        
        for i, role in enumerate(available_roles, 1):
            print_colored(f"[PRIVATE] {i}. {role}", 'PRIVATE')
        
        while True:
            try:
                role_choice = int(input(f"[PRIVATE] Enter your guess (1-{len(available_roles)}): ").strip())
                if 1 <= role_choice <= len(available_roles):
                    guessed_role = available_roles[role_choice - 1]
                    break
                else:
                    print_colored(f"[PRIVATE] Please enter a number between 1 and {len(available_roles)}.", 'PRIVATE')
            except ValueError:
                print_colored(f"[PRIVATE] Please enter a valid number.", 'PRIVATE')
    else:
        # LLM player - use LLM to make choice
        prompt = format_player_prompt(gs, player, "target_selection")
        effective_role_name = get_effective_role_name(player)
        prompt.append({
            "role": "system",
            "content": f"You are the {effective_role_name}. Each night*, choose a player & guess their character: if you guess wrong, you die. IMPORTANT: You should probably only guess people who have publicly claimed to be a specific role. Guessing randomly is very risky and likely to kill you. Again, it is EXTREMELY HIGHLY advised that you ONLY guess roles that people have publicly claimed a specific role in the public discussion log, or else you are very likely going to die aimlessly. Available targets: {', '.join(f'{t.name} (Seat {t.seat})' for t in targets)}"
        })
        
        llm_response = call_gpt(prompt, label=f"Gambler targeting (Seat {player.seat})")
        target_name = parse_llm_response(llm_response, "targeting", options=[t.name for t in targets], player=player)
        
        # Find the target
        target = next((t for t in targets if t.name.lower() == target_name.lower()), None)
        if not target:
            # Fallback to random choice if LLM fails
            target = random.choice(targets)
        
        # LLM also guesses a role
        # Determine which character sets to include based on gs.character_set
        # 1 = Trouble Brewing, 2 = Bad Moon Rising, 3 = Both
        include_tb = gs.character_set in [1, 3]
        include_bmr = gs.character_set in [2, 3]
        
        # Get available roles based on character set
        available_roles = []
        if include_tb:
            available_roles.extend([r.name for r in TB_ROLES])
        if include_bmr:
            available_roles.extend([r.name for r in BMR_ROLES])
        
        guessed_role = random.choice(available_roles)  # Fallback for LLM
    
    return {"target": target, "guessed_role": guessed_role}

def gambler_ability(gs: GameState, player: Player):
    """Each night*, choose a player & guess their character: if you guess wrong, you die."""
    gs.log_action_start("gambler_ability", player)
    
    def normal_fn():
        targets = get_targetable_players(gs, allow_dead=False, exclude_self=player)
        if not targets:
            gs.log_secret(f"Gambler {player.label()} has no valid targets.")
            return None
        
        # Get player choice (common logic for both normal and drunk)
        choice_result = get_gambler_choice(gs, player, targets)
        if choice_result is None:
            return None
        
        target = choice_result["target"]
        guessed_role = choice_result["guessed_role"]
        
        # Check if guess is correct (case-insensitive)
        correct = (target.role.name.lower() == guessed_role.lower())
        
        if correct:
            msg = f"You choose {target.name} (Seat {target.seat}) and guess they are the {guessed_role}. Your guess is correct!"
            gs.log_secret(f"Gambler {player.label()} correctly guesses {target.label()} is {guessed_role}.")
        else:
            msg = f"You choose {target.name} (Seat {target.seat}) and guess they are the {guessed_role}. Your guess is wrong - you die!"
            gs.log_secret(f"Gambler {player.label()} incorrectly guesses {target.label()} is {guessed_role}, Gambler dies.")
            # Kill the Gambler
            attempt_kill_player(gs, player, "Gambler ability")
        
        if is_human_player(player):
            print_colored(f"[PRIVATE] {player.name} (Seat {player.seat}) is told: {msg}", 'PRIVATE')
        
        return {"target": target.seat, "guessed_role": guessed_role, "correct": correct}
    
    def drunk_fn():
        # Drunk Gambler thinks their ability works but it actually doesn't, and they are not told anything different.
        # They should be able to choose targets as normal, but their ability has no effect
        targets = get_targetable_players(gs, allow_dead=False, exclude_self=player)
        if not targets:
            return None
        
        # Get player choice (common logic for both normal and drunk)
        choice_result = get_gambler_choice(gs, player, targets)
        if choice_result is None:
            return None
        
        target = choice_result["target"]
        guessed_role = choice_result["guessed_role"]
        
        # Drunk Gambler's ability has no effect, but they think it does
        # They are not told that their ability failed
        gs.log_secret(f"Drunk Gambler {player.label()} targets {target.label()} and guesses {guessed_role}, but their ability has no effect (they are drunk/poisoned).")
        
        # Do NOT kill the Gambler (ability has no effect)
        
        # Create message for player (they think their ability worked)
        correct = (target.role.name.lower() == guessed_role.lower())
        if correct:
            msg = f"You choose {target.name} (Seat {target.seat}) and guess they are the {guessed_role}. Your guess is correct!"
        else:
            msg = f"You choose {target.name} (Seat {target.seat}) and guess they are the {guessed_role}. Your guess is wrong - you die!"
        
        if is_human_player(player):
            print_colored(f"[PRIVATE] {player.name} (Seat {player.seat}) is told: {msg}", 'PRIVATE')
        
        return {"target": target.seat, "guessed_role": guessed_role, "correct": correct}
    
    result = resolve_ability(player, normal_fn, drunk_fn)
    if result:
        player.memory["gambler"] = {"type": "gambler", "data": {"target": result["target"], "guessed_role": result["guessed_role"], "correct": result["correct"], "night": gs.day}}
    gs.log_action_end("gambler_ability", f"Targeted seat {result['target']}, guessed {result['guessed_role']}, {'correct' if result['correct'] else 'incorrect'}" if result else "Failed", player)

def get_courtier_choice(gs: GameState, player: Player):
    """Helper function to get Courtier choice (common for both normal and drunk)"""
    # Determine which character sets to include based on gs.character_set
    # 1 = Trouble Brewing, 2 = Bad Moon Rising, 3 = Both
    include_tb = gs.character_set in [1, 3]
    include_bmr = gs.character_set in [2, 3]
    
    # Get available roles based on character set
    available_roles = []
    if include_tb:
        available_roles.extend([r.name for r in TB_ROLES])
    if include_bmr:
        available_roles.extend([r.name for r in BMR_ROLES])
    
    if is_human_player(player):
        effective_role_name = get_effective_role_name(player)
        print_colored(f"[PRIVATE] {player.name} (Seat {player.seat}), you are the {effective_role_name}.", 'PRIVATE')
        print_colored(f"[PRIVATE] Once per game, at night, choose a character: they are drunk for 3 nights & 3 days.", 'PRIVATE')
        print_colored(f"[PRIVATE] STRATEGIC ADVICE: Consider carefully whether you should use this ability immediately.", 'PRIVATE')
        print_colored(f"[PRIVATE] You may want to wait to figure out which demon is likely in play, then use it on that demon. This could also be useful for ruling out the presence of a given demon.", 'PRIVATE')
        print_colored(f"[PRIVATE] You should almost NEVER use this on a good player (Townsfolk/Outsider) unless you have a very compelling reason.", 'PRIVATE')
        print_colored(f"[PRIVATE] Choose a character role to target, or choose to pass:", 'PRIVATE')
        
        for i, role in enumerate(available_roles, 1):
            print_colored(f"[PRIVATE] {i}. {role}", 'PRIVATE')
        print_colored(f"[PRIVATE] {len(available_roles) + 1}. Pass (save ability for later)", 'PRIVATE')
        
        while True:
            try:
                choice = int(input(f"[PRIVATE] Enter your choice (1-{len(available_roles) + 1}): ").strip())
                if 1 <= choice <= len(available_roles):
                    chosen_role = available_roles[choice - 1]
                    break
                elif choice == len(available_roles) + 1:
                    # Choose to pass
                    chosen_role = None
                    break
                else:
                    print_colored(f"[PRIVATE] Please enter a number between 1 and {len(available_roles) + 1}.", 'PRIVATE')
            except ValueError:
                print_colored(f"[PRIVATE] Please enter a valid number.", 'PRIVATE')
    else:
        # LLM player - use LLM to make choice
        prompt = format_player_prompt(gs, player, "target_selection")
        effective_role_name = get_effective_role_name(player)
        prompt.append({
            "role": "system",
            "content": f"You are the {effective_role_name}. Once per game, at night, choose a character: they are drunk for 3 nights & 3 days. STRATEGIC ADVICE: Consider carefully whether you should use this ability immediately. You may want to wait to figure out which demon is likely in play, then use it on that demon (or use it to rule out the presence of a possible demon). You should almost NEVER use this on a good player (Townsfolk/Outsider) unless you have a very compelling reason -- and you will almost never have a compelling reason, so in general you SHOULD NEVER USE THIS AGAINST A TOWNSFOLK. AGAIN, DO NOT USE THIS AGAINST TOWNSFOLK. DO NOT USE THIS AGAINST TOWNSFOLK!! You can also choose to pass and save your ability for a later night. If you have no idea what minions or demon are in play, you may want to wait, although sometimes it might be worth guessing. Available roles in this game: {', '.join(available_roles)}. You can also choose to pass."
        })
        
        llm_response = call_gpt(prompt, label=f"Courtier targeting (Seat {player.seat})")
        chosen_role = parse_llm_response(llm_response, "targeting", options=available_roles + ["pass"], player=player)
        
        # Fallback to random choice if LLM fails, but allow passing
        if not chosen_role:
            chosen_role = random.choice(available_roles + ["pass"])
        elif chosen_role.lower() == "pass":
            chosen_role = None
        elif chosen_role not in available_roles:
            chosen_role = random.choice(available_roles)
    
    return {"chosen_role": chosen_role}

def courtier_ability(gs: GameState, player: Player):
    """Once per game, at night, choose a character: they are drunk for 3 nights & 3 days."""
    gs.log_action_start("courtier_ability", player)
    
    # Check if already used
    if "courtier_used" in player.memory:
        gs.log_secret(f"Courtier {player.label()} has already used their ability.")
        gs.log_action_end("courtier_ability", "Already used", player)
        return
    
    def normal_fn():
        # Get player choice (common logic for both normal and drunk)
        choice_result = get_courtier_choice(gs, player)
        if choice_result is None:
            return None
        
        chosen_role = choice_result["chosen_role"]
        
        # Check if player chose to pass
        if chosen_role is None:
            msg = "You choose to pass and save your ability for later."
            gs.log_secret(f"Courtier {player.label()} chooses to pass and save their ability.")
            
            if is_human_player(player):
                print_colored(f"[PRIVATE] {player.name} (Seat {player.seat}) is told: {msg}", 'PRIVATE')
            
            # Do NOT mark ability as used - they can use it later
            return {"chosen_role": None, "affected_players": []}
        
        # Find all players with that role
        players_with_role = [p for p in gs.players if p.role.name == chosen_role]
        
        if not players_with_role:
            msg = f"You choose the {chosen_role}. If they are in play (and if you are not drunk/poisoned), that character will be drunk for 3 days and 3 nights."
            gs.log_secret(f"Courtier {player.label()} chooses {chosen_role} but no one has that role.")
        else:
            # Make all players with that role drunk for 3 nights + 3 days
            for target in players_with_role:
                mark_drunk(target, gs.day + 3)  # Drunk for 3 nights + 3 days
            
            target_names = [p.name for p in players_with_role]
            msg = f"You choose the {chosen_role}. {', '.join(target_names)} are drunk for 3 nights and 3 days."
            gs.log_secret(f"Courtier {player.label()} makes {', '.join(target_names)} drunk for 3 nights and 3 days.")
        
        # Mark ability as used
        player.memory["courtier_used"] = True
        
        if is_human_player(player):
            print_colored(f"[PRIVATE] {player.name} (Seat {player.seat}) is told: {msg}", 'PRIVATE')
        
        return {"chosen_role": chosen_role, "affected_players": [p.seat for p in players_with_role]}
    
    def drunk_fn(): # At some point parts of this should just be merged with the normal_fn function above, because the messages to the player should be exactly the same, and only private information about whether it actually happened/etc. should be different.
        # Drunk Courtier thinks their ability works but it actually doesn't, and they are not told anything different.
        # They should be able to choose targets as normal, but their ability has no effect
        # Get player choice (common logic for both normal and drunk)
        choice_result = get_courtier_choice(gs, player)
        if choice_result is None:
            return None
        
        chosen_role = choice_result["chosen_role"]
        
        # Check if player chose to pass
        if chosen_role is None:
            msg = "You choose to pass and save your ability for later."
            gs.log_secret(f"Drunk Courtier {player.label()} chooses to pass and save their ability (ability has no effect).")
            
            if is_human_player(player):
                print_colored(f"[PRIVATE] {player.name} (Seat {player.seat}) is told: {msg}", 'PRIVATE')
            
            # Do NOT mark ability as used - they can use it later
            return {"chosen_role": None, "affected_players": []}
        
        players_with_role = [p for p in gs.players if p.role.name == chosen_role]
        
        # Drunk Courtier's ability has no effect, but they think it does
        # They are not told that their ability failed
        gs.log_secret(f"Drunk Courtier {player.label()} chooses {chosen_role}, but their ability has no effect (they are drunk/poisoned).")
        
        # Do NOT mark anyone as drunk (ability has no effect)
        
        # Create message for player (they think their ability worked)
        if not players_with_role:
            msg = f"You choose the {chosen_role}. If they are in play (and if you are not drunk/poisoned), that character will be drunk for 3 days and 3 nights." 
        else:
            target_names = [p.name for p in players_with_role]
            msg = f"You choose the {chosen_role}. {', '.join(target_names)} are drunk for 3 nights and 3 days."
        
        # Mark ability as used (even though it had no effect)
        player.memory["courtier_used"] = True
        
        if is_human_player(player):
            print_colored(f"[PRIVATE] {player.name} (Seat {player.seat}) is told: {msg}", 'PRIVATE')
        
        return {"chosen_role": chosen_role, "affected_players": [p.seat for p in players_with_role]}
    
    result = resolve_ability(player, normal_fn, drunk_fn)
    if result:
        if result["chosen_role"] is not None:
            player.memory["courtier"] = {"type": "courtier", "data": {"chosen_role": result["chosen_role"], "affected_players": result["affected_players"], "night": gs.day}}
            gs.log_action_end("courtier_ability", f"Chose {result['chosen_role']}, affected {len(result['affected_players'])} players", player)
        else:
            gs.log_action_end("courtier_ability", "Chose to pass, saved ability for later", player)
    else:
        gs.log_action_end("courtier_ability", "Failed", player)

def get_professor_choice(gs: GameState, player: Player, dead_players):
    """Helper function to get Professor choice (common for both normal and drunk)"""
    if is_human_player(player):
        effective_role_name = get_effective_role_name(player)
        print_colored(f"[PRIVATE] {player.name} (Seat {player.seat}), you are the {effective_role_name}.", 'PRIVATE')
        print_colored(f"[PRIVATE] Once per game, you can choose a dead player. If they are a Townsfolk, they are resurrected.", 'PRIVATE')
        print_colored(f"[PRIVATE] You can also choose to target no-one tonight, by choosing 'no-one'. This saves your ability for a future usage.", 'PRIVATE')
        print_colored(f"[PRIVATE] Choose a dead player to target, or choose 'no-one':", 'PRIVATE')
        
        # Show available targets
        for i, target in enumerate(dead_players, 1):
            print_colored(f"[PRIVATE] {i}. {target.name} (Seat {target.seat})", 'PRIVATE')
        print_colored(f"[PRIVATE] {len(dead_players) + 1}. choose 'no-one' by choosing the last/appropriate option.", 'PRIVATE')
        
        while True:
            try:
                choice = int(input(f"[PRIVATE] Enter your choice (1-{len(dead_players) + 1}). The last option is to choose no-one: ").strip())
                if 1 <= choice <= len(dead_players):
                    target = dead_players[choice - 1]
                    break
                elif choice == len(dead_players) + 1:
                    # Choose no-one
                    target = None
                    break
                else:
                    print_colored(f"[PRIVATE] Please enter a number between 1 and {len(dead_players) + 1}. The last option is to choose no-one.", 'PRIVATE')
            except ValueError:
                print_colored(f"[PRIVATE] Please enter a valid number.", 'PRIVATE')
    else:
        # LLM player - use LLM to make choice
        prompt = format_player_prompt(gs, player, "target_selection")
        effective_role_name = get_effective_role_name(player)
        prompt.append({
            "role": "system",
            "content": f"You are the {effective_role_name}. Once per game, you can choose a dead player. If they are a Townsfolk, they are resurrected. You can also choose to target no-one tonight, and save the ability for a future night. Available dead players: {', '.join(f'{t.name} (Seat {t.seat})' for t in dead_players)}. You can also choose no-one."
        })
        
        llm_response = call_gpt(prompt, label=f"Professor targeting (Seat {player.seat})")
        target_name = parse_llm_response(llm_response, "targeting", options=[t.name for t in dead_players] + ["no-one"], player=player)
        
        # Find the target
        if target_name and target_name.lower() != "no-one":
            target = next((t for t in dead_players if t.name.lower() == target_name.lower()), None)
            if not target:
                # Fallback to random choice if LLM fails
                target = random.choice(dead_players)
        else:
            target = None
    
    return {"target": target, "target_name": target_name if target is None else target.name}

def professor_ability(gs: GameState, player: Player):
    """Once per game, at night*, choose a dead player: if they are a Townsfolk, they are resurrected."""
    gs.log_action_start("professor_ability", player)
    
    # Check if already used
    if "professor_used" in player.memory:
        gs.log_secret(f"Professor {player.label()} has already used their ability.")
        gs.log_action_end("professor_ability", "Already used", player)
        return
    
    def normal_fn():
        # Find dead players (or players that appear to be dead, which should not be marked any differently from actually dead players)
        dead_players = [p for p in gs.players if not p.alive]
        if not dead_players:
            gs.log_secret(f"Professor {player.label()} has no dead players to resurrect.")
            return None
        
        # Get player choice (common logic for both normal and drunk)
        choice_result = get_professor_choice(gs, player, dead_players)
        if choice_result is None:
            return None
        
        target = choice_result["target"]
        target_name = choice_result["target_name"]
        
        # Handle choosing no-one
        if target is None:
            gs.log_secret(f"Professor {player.label()} chooses to target no-one tonight.")
            # Do NOT mark ability as used - they can still use it later
            # player.memory["professor_used"] = True  # REMOVED - ability remains available
            
            if is_human_player(player):
                print_colored(f"[PRIVATE] You choose to target no-one tonight. Your ability is still usable for this game.", 'PRIVATE')
            
            return {"target": None, "was_townsfolk": False, "resurrected": False}
        
        # Provide better targeting information
        targeting_desc = get_targeting_description(allow_dead=True)
        gs.log_secret(f"Professor {player.label()} can target {targeting_desc}.")
        
        # Check if target is a Townsfolk
        if target.role.alignment == Alignment.TOWNSFOLK:
            # Resurrect the player but don't announce yet
            gs.log_secret(f"Professor {player.label()} resurrecting {target.label()} - before: alive={target.alive}, last_alive_day={target.memory.get('last_alive_day', 'None')}")
            target.alive = True
            target.death_count = 0  # Reset death count
            # Clear death-related memory since they're no longer dead
            if "last_alive_day" in target.memory:
                del target.memory["last_alive_day"]
            # Clear death night tracking since they're no longer dead from that death
            if "died_night" in target.hidden_state:
                del target.hidden_state["died_night"]
            gs.log_secret(f"Professor {player.label()} resurrects Townsfolk {target.label()} - after: alive={target.alive}, last_alive_day={target.memory.get('last_alive_day', 'None')}")
            
            # Track resurrection for dawn announcement
            if "resurrections" not in gs.memory:
                gs.memory["resurrections"] = []
            gs.memory["resurrections"].append({
                "player": target.seat,
                "type": "Professor",
                "night": gs.day
            })
        else:
            gs.log_secret(f"Professor {player.label()} targets {target.label()} but they are not a Townsfolk.")
        
        # Mark ability as used
        player.memory["professor_used"] = True
        
        # Create message for player
        msg = f"You choose {target.name} (Seat {target.seat}). You are not told whether or not they are a Townsfolk."
        
        if is_human_player(player):
            print_colored(f"[PRIVATE] {player.name} (Seat {player.seat}) is told: {msg}", 'PRIVATE')
        
        return {"target": target.seat, "was_townsfolk": target.role.alignment == Alignment.TOWNSFOLK, "resurrected": target.alive}
    
    def drunk_fn():
        # Drunk Professor thinks their ability works but it actually doesn't, and they are not told anything different.
        # They should be able to choose targets as normal, but their ability has no effect
        dead_players = [p for p in gs.players if not p.alive]
        if not dead_players:
            return None
        
        # Get player choice (common logic for both normal and drunk)
        choice_result = get_professor_choice(gs, player, dead_players)
        if choice_result is None:
            return None
        
        target = choice_result["target"]
        target_name = choice_result["target_name"]
        
        # Handle choosing no-one
        if target is None:
            gs.log_secret(f"Drunk Professor {player.label()} chooses to target no-one tonight.")
            # Do NOT mark ability as used - they can still use it later
            # player.memory["professor_used"] = True  # REMOVED - ability remains available
            
            if is_human_player(player):
                print_colored(f"[PRIVATE] You choose to target no-one tonight. Your ability is still usable for this game.", 'PRIVATE')
            
            return {"target": None, "was_townsfolk": False, "resurrected": False}
        
        # Drunk Professor's ability has no effect, but they think it does
        # They are not told that their ability failed
        gs.log_secret(f"Drunk Professor {player.label()} targets {target.label()} but their ability has no effect (they are drunk/poisoned).")
        
        # Mark ability as used
        player.memory["professor_used"] = True
        
        # Create message for player (they think their ability worked)
        msg = f"You choose {target.name} (Seat {target.seat}). You are not told whether or not they are a Townsfolk."
        
        if is_human_player(player):
            print_colored(f"[PRIVATE] {player.name} (Seat {player.seat}) is told: {msg}", 'PRIVATE')
        
        return {"target": target.seat, "was_townsfolk": False, "resurrected": False}
    
    result = resolve_ability(player, normal_fn, drunk_fn)
    if result:
        player.memory["professor"] = {"type": "professor", "data": {"target": result["target"], "was_townsfolk": result["was_townsfolk"], "resurrected": result["resurrected"], "night": gs.day}}
        
        # Log the action end with appropriate message
        if result["target"] is None:
            gs.log_action_end("professor_ability", "Chose no-one", player)
        else:
            gs.log_action_end("professor_ability", f"Targeted seat {result['target']}, {'resurrected' if result['resurrected'] else 'no effect'}", player)
    else:
        gs.log_action_end("professor_ability", "Failed", player)

# Minion Abilities
def capo_crimini_night_ability(gs: GameState, player: Player):
    """Capo Crimini night ability: If 1 died today, choose a player tonight: they die."""
    gs.log_action_start("capo_crimini_night_ability", player)
    
    # Check if an Outsider died today
    executed_today = gs.memory.get("executed_today")
    if not executed_today or executed_today.role.alignment != Alignment.OUTSIDER:
        gs.log_secret(f"Capo Crimini {player.label()} cannot use ability - no Outsider died today.")
        gs.log_action_end("capo_crimini_night_ability", "No Outsider died today", player)
        return
    
    def normal_fn():
        targets = get_targetable_players(gs, allow_dead=False, exclude_self=player)
        if not targets:
            gs.log_secret(f"Capo Crimini {player.label()} has no valid targets.")
            return None
        
        # Prompt human player for choice
        if is_human_player(player):
            effective_role_name = get_effective_role_name(player)
            print_colored(f"[PRIVATE] {player.name} (Seat {player.seat}), you are the {effective_role_name}.", 'PRIVATE')
            print_colored(f"[PRIVATE] An Outsider died today, so you can choose a player to kill tonight.", 'PRIVATE')
            print_colored(f"[PRIVATE] Choose a player to kill:", 'PRIVATE')
            
            # Show available targets
            for i, target in enumerate(targets, 1):
                print_colored(f"[PRIVATE] {i}. {target.name} (Seat {target.seat})", 'PRIVATE')
            
            while True:
                try:
                    choice = int(input(f"[PRIVATE] Enter your choice (1-{len(targets)}): ").strip())
                    if 1 <= choice <= len(targets):
                        target = targets[choice - 1]
                        break
                    else:
                        print_colored(f"[PRIVATE] Please enter a number between 1 and {len(targets)}.", 'PRIVATE')
                except ValueError:
                    print_colored(f"[PRIVATE] Please enter a valid number.", 'PRIVATE')
        else:
            # LLM player - use LLM to make choice
            prompt = format_player_prompt(gs, player, "target_selection")
            prompt.append({
                "role": "system",
                "content": f"You are the Capo Crimini. An Outsider died today, so you can choose a player to kill tonight. Available targets: {', '.join(f'{t.name} (Seat {t.seat})' for t in targets)}"
            })
            
            llm_response = call_gpt(prompt, label=f"Capo Crimini targeting (Seat {player.seat})")
            target_name = parse_llm_response(llm_response, "targeting", options=[t.name for t in targets], player=player)
            
            # Find the target
            target = next((t for t in targets if t.name.lower() == target_name.lower()), None)
            if not target:
                # Fallback to random choice if LLM fails
                target = random.choice(targets)
        
        # Kill the target
        attempt_kill_player(gs, target, "Capo Crimini")
        
        msg = f"An Outsider died today, so you choose {target.name} (Seat {target.seat}) to die."
        if is_human_player(player):
            print_colored(f"[PRIVATE] {player.name} (Seat {player.seat}) is told: {msg}", 'PRIVATE')
        gs.log_secret(f"[PRIVATE] {player.label()} is told: {msg}")
        
        return {"target": target.seat}
    
    def drunk_fn():
        # Drunk Capo makes random choice
        targets = get_targetable_players(gs, allow_dead=False, exclude_self=player)
        if not targets:
            return None
        
        target = random.choice(targets)
        attempt_kill_player(gs, target, "Drunk Capo Crimini")
        
        msg = f"An Outsider died today, so you choose {target.name} (Seat {target.seat}) to die."
        gs.log_secret(f"Drunk Capo Crimini {player.label()} kills {target.label()}.")
        
        if is_human_player(player):
            print_colored(f"[PRIVATE] {player.name} (Seat {player.seat}) is told: {msg}", 'PRIVATE')
        
        return {"target": target.seat}
    
    result = resolve_ability(player, normal_fn, drunk_fn)
    if result:
        player.memory["capo_crimini_night"] = {"type": "capo_crimini_night", "data": {"target": result["target"], "night": gs.day}}
    gs.log_action_end("capo_crimini_night_ability", f"Killed seat {result['target']}" if result else "Failed", player)

def get_devils_advocate_choice(gs: GameState, player: Player, targets):
    """Helper function to get Devil's Advocate choice (common for both normal and drunk)"""
    if is_human_player(player):
        print_colored(f"[PRIVATE] {player.name} (Seat {player.seat}), you are the Devil's Advocate.", 'PRIVATE')
        print_colored(f"[PRIVATE] Choose a living player (different from last night) to protect from execution tomorrow:", 'PRIVATE')
        
        # Show available targets
        for i, target in enumerate(targets, 1):
            print_colored(f"[PRIVATE] {i}. {target.name} (Seat {target.seat})", 'PRIVATE')
        
        while True:
            try:
                choice = int(input(f"[PRIVATE] Enter your choice (1-{len(targets)}): ").strip())
                if 1 <= choice <= len(targets):
                    target = targets[choice - 1]
                    break
                else:
                    print_colored(f"[PRIVATE] Please enter a number between 1 and {len(targets)}.", 'PRIVATE')
            except ValueError:
                print_colored(f"[PRIVATE] Please enter a valid number.", 'PRIVATE')
    else:
        # LLM player - use LLM to make choice
        prompt = format_player_prompt(gs, player, "target_selection")
        # Add targeting information
        targeting_desc = get_targeting_description(allow_dead=False)
        prompt.append({
            "role": "system",
            "content": f"Choose a living player to protect from execution tomorrow. You cannot choose the same player as last night. Available targets: {', '.join(f'{t.name} (Seat {t.seat})' for t in targets)}"
        })
        
        llm_response = call_gpt(prompt, label=f"Devil's Advocate targeting (Seat {player.seat})")
        target_name = parse_llm_response(llm_response, "targeting", options=[t.name for t in targets], player=player)
        
        # Find the target
        target = next((t for t in targets if t.name.lower() == target_name.lower()), None)
        if not target:
            # Fallback to random choice if LLM fails
            target = random.choice(targets)
    
    return {"target": target}

def devils_advocate_ability(gs: GameState, player: Player):
    """Each night, choose a living player (different to last night): if executed tomorrow, they don't die."""
    gs.log_action_start("devils_advocate_ability", player)
    
    def normal_fn():
        # Check if we can use ability (different target from last night)
        last_target = player.memory.get("devils_advocate_last_target")
        targets = get_targetable_players(gs, allow_dead=False, exclude_self=player)
        
        # Filter out last night's target if it exists
        if last_target is not None:
            targets = [t for t in targets if t.seat != last_target]
        
        if not targets:
            gs.log_secret(f"Devil's Advocate {player.label()} has no valid targets (different from last night).")
            return None
        
        # Get player choice (common logic for both normal and drunk)
        choice_result = get_devils_advocate_choice(gs, player, targets)
        if choice_result is None:
            return None
        
        target = choice_result["target"]
        
        # Store this target for next night
        player.memory["devils_advocate_last_target"] = target.seat
        
        # Protect target from execution tomorrow
        target.can_die = False
        # Store protection info in target's hidden state to track when it expires (not visible to player)
        target.hidden_state["devils_advocate_protection"] = {"expires_after_day": gs.day + 1, "protector": player.seat}
        # Don't store protection memory in target - they shouldn't know they're protected
        
        msg = f"You choose {target.name} (Seat {target.seat}). If they are executed tomorrow, they won't die."
        if is_human_player(player):
            print_colored(f"[PRIVATE] {player.name} (Seat {player.seat}) is told: {msg}", 'PRIVATE')
        gs.log_secret(f"[PRIVATE] {player.label()} is told: {msg}")
        
        return {"target": target.seat}
    
    def drunk_fn():
        # Drunk Devil's Advocate thinks their ability works but it actually doesn't, and they are not told anything different.
        # They should be able to choose targets as normal, but their ability has no effect
        targets = get_targetable_players(gs, allow_dead=False, exclude_self=player)
        if not targets:
            return None
        
        # Filter out last night's target if it exists
        last_target = player.memory.get("devils_advocate_last_target")
        if last_target is not None:
            targets = [t for t in targets if t.seat != last_target]
        
        if not targets:
            gs.log_secret(f"Drunk Devil's Advocate {player.label()} has no valid targets (different from last night).")
            return None
        
        # Get player choice (common logic for both normal and drunk)
        choice_result = get_devils_advocate_choice(gs, player, targets)
        if choice_result is None:
            return None
        
        target = choice_result["target"]
        
        # Drunk Devil's Advocate's ability has no effect, but they think it does
        # They are not told that their ability failed
        gs.log_secret(f"Drunk Devil's Advocate {player.label()} targets {target.label()}, but their ability has no effect (they are drunk/poisoned).")
        
        # Do NOT protect the target (ability has no effect)
        
        # Store this target for next night (even though it had no effect)
        player.memory["devils_advocate_last_target"] = target.seat
        
        # Create message for player (they think their ability worked)
        msg = f"You choose {target.name} (Seat {target.seat}). If they are executed tomorrow, they won't die."
        
        if is_human_player(player):
            print_colored(f"[PRIVATE] {player.name} (Seat {player.seat}) is told: {msg}", 'PRIVATE')
        
        return {"target": target.seat}
    
    result = resolve_ability(player, normal_fn, drunk_fn)
    if result:
        player.memory["devils_advocate"] = {"type": "devils_advocate", "data": {"target": result["target"], "night": gs.day}}
    gs.log_action_end("devils_advocate_ability", f"Protected seat {result['target']}" if result else "Failed", player)

def get_assassin_choice(gs: GameState, player: Player, targets):
    """Helper function to get Assassin choice (common for both normal and drunk)"""
    if is_human_player(player):
        print_colored(f"[PRIVATE] {player.name} (Seat {player.seat}), you are the Assassin.", 'PRIVATE')
        print_colored(f"[PRIVATE] Once per game, you can choose a player to kill. They die, even if they could not normally die.", 'PRIVATE')
        print_colored(f"[PRIVATE] You can either:", 'PRIVATE')
        print_colored(f"[PRIVATE] 1. Choose a player to kill", 'PRIVATE')
        print_colored(f"[PRIVATE] 2. Choose not to kill anyone", 'PRIVATE')
        
        while True:
            choice = input(f"[PRIVATE] Enter your choice (1 or 2): ").strip()
            if choice == "1":
                print_colored(f"[PRIVATE] Choose a player to kill:", 'PRIVATE')
                # Show available targets
                for i, target in enumerate(targets, 1):
                    print_colored(f"[PRIVATE] {i}. {target.name} (Seat {target.seat})", 'PRIVATE')
                
                while True:
                    try:
                        target_choice = int(input(f"[PRIVATE] Enter your choice (1-{len(targets)}): ").strip())
                        if 1 <= target_choice <= len(targets):
                            target = targets[target_choice - 1]
                            break
                        else:
                            print_colored(f"[PRIVATE] Please enter a number between 1 and {len(targets)}.", 'PRIVATE')
                    except ValueError:
                        print_colored(f"[PRIVATE] Please enter a valid number.", 'PRIVATE')
                break
            elif choice == "2":
                target = None
                break
            else:
                print_colored(f"[PRIVATE] Please enter 1 or 2.", 'PRIVATE')
    else:
        # LLM player - use LLM to make choice
        prompt = format_player_prompt(gs, player, "target_selection")
        prompt.append({
            "role": "system",
            "content": f"You are the Assassin. Once per game, you can choose a player to kill. They die, even if they could not normally die. You can choose 1 player or no-one. Available targets: {', '.join(f'{t.name} (Seat {t.seat})' for t in targets)}"
        })
        
        llm_response = call_gpt(prompt, label=f"Assassin targeting (Seat {player.seat})")
        target_name = parse_llm_response(llm_response, "targeting", options=[t.name for t in targets] + ["no-one"], player=player)
        
        if target_name and target_name.lower() != "no-one":
            # Find the target
            target = next((t for t in targets if t.name.lower() == target_name.lower()), None)
            if not target:
                # Fallback to random choice if LLM fails
                target = random.choice(targets)
        else:
            target = None
    
    return {"target": target}

def assassin_ability(gs: GameState, player: Player):
    """Once per game, at night*, choose a player: they die, even if for some reason they could not."""
    gs.log_action_start("assassin_ability", player)
    
    # Check if already used
    if "assassin_used" in player.memory:
        gs.log_secret(f"Assassin {player.label()} has already used their ability.")
        gs.log_action_end("assassin_ability", "Already used", player)
        return
    
    def normal_fn():
        targets = get_targetable_players(gs, allow_dead=False, exclude_self=player)
        if not targets:
            gs.log_secret(f"Assassin {player.label()} has no valid targets.")
            return None
        
        # Get player choice (common logic for both normal and drunk)
        choice_result = get_assassin_choice(gs, player, targets)
        if choice_result is None:
            return None
        
        target = choice_result["target"]
        
        if target is None:
            # Assassin chose not to kill anyone
            msg = "You choose not to kill anyone."
            if is_human_player(player):
                print_colored(f"[PRIVATE] {player.name} (Seat {player.seat}) is told: {msg}", 'PRIVATE')
            gs.log_secret(f"[PRIVATE] {player.label()} is told: {msg}")
            
            # Mark ability as used
            player.memory["assassin_used"] = True
            
            return {"target": None}
        else:
            # Assassin can kill even if target is protected
            original_can_die = target.can_die
            target.can_die = True
            attempt_kill_player(gs, target, "Assassin")
            target.can_die = original_can_die  # Restore original state
            
            msg = f"You choose {target.name} (Seat {target.seat}). They die, even if they could not normally die."
            if is_human_player(player):
                print_colored(f"[PRIVATE] {player.name} (Seat {player.seat}) is told: {msg}", 'PRIVATE')
            gs.log_secret(f"[PRIVATE] {player.label()} is told: {msg}")
            
            # Mark ability as used
            player.memory["assassin_used"] = True
            
            return {"target": target.seat}
    
    def drunk_fn():
        # Drunk Assassin thinks their ability works but it actually doesn't, and they are not told anything different.
        # They should be able to choose targets as normal, but their ability has no effect
        targets = get_targetable_players(gs, allow_dead=False, exclude_self=player)
        if not targets:
            return None
        
        # Get player choice (common logic for both normal and drunk)
        choice_result = get_assassin_choice(gs, player, targets)
        if choice_result is None:
            return None
        
        target = choice_result["target"]
        
        # Drunk Assassin's ability has no effect, but they think it does
        # They are not told that their ability failed
        gs.log_secret(f"Drunk Assassin {player.label()} targets {target.label() if target else 'no-one'}, but their ability has no effect (they are drunk/poisoned).")
        
        # Do NOT kill the target (ability has no effect)
        
        # Create message for player (they think their ability worked)
        if target is None:
            # Assassin chose not to kill anyone
            msg = "You choose not to kill anyone."
        else:
            msg = f"You choose {target.name} (Seat {target.seat}). They die, even if they could not normally die."
        
        if is_human_player(player):
            print_colored(f"[PRIVATE] {player.name} (Seat {player.seat}) is told: {msg}", 'PRIVATE')
        
        # Mark ability as used (even though it had no effect)
        player.memory["assassin_used"] = True
        
        return {"target": target.seat if target else None}
    
    result = resolve_ability(player, normal_fn, drunk_fn)
    if result:
        player.memory["assassin"] = {"type": "assassin", "data": {"target": result["target"], "night": gs.day}}
    gs.log_action_end("assassin_ability", f"Killed seat {result['target']}" if result else "Failed", player)

# Demon Abilities
def run_zombuul_ability(gs: GameState, player: Player):
    """Zombuul: Each night*, if no-one died today, choose a player: they die. The 1st time you die, you live but register as dead."""
    gs.log_action_start("zombuul_ability", player)
    
    # Check if anyone died today (including executions and other day deaths)
    # Zombuul kills if no one died during the day
    someone_died_today = (
        not gs.memory.get("no_execution_today", True) or  # There was an execution
        gs.memory.get("executed_today") is not None or     # Someone was executed
        gs.memory.get("killed_by_demon") is not None or    # Demon killed someone
        gs.memory.get("day_deaths", [])                    # Any other day deaths
    )
    
    if not someone_died_today:
        # No one died today, so Zombuul must kill
        targets = get_targetable_players(gs, allow_dead=False, exclude_self=player)
        if not targets:
            gs.log_secret(f"Zombuul {player.label()} has no valid targets.")
            gs.log_action_end("zombuul_ability", "No targets available", player)
            return
        
        # Prompt human player for choice
        if is_human_player(player):
            effective_role_name = get_effective_role_name(player)
            print_colored(f"[PRIVATE] {player.name} (Seat {player.seat}), you are the {effective_role_name}.", 'PRIVATE')
            print_colored(f"[PRIVATE] Each night*, if no-one died today, choose a player: they die. The 1st time you die, you live but register as dead.", 'PRIVATE')
            print_colored(f"[PRIVATE] No one died today, so you must kill someone. Choose a player to kill:", 'PRIVATE')
            
            # Show available targets
            for i, target in enumerate(targets, 1):
                print_colored(f"[PRIVATE] {i}. {target.name} (Seat {target.seat})", 'PRIVATE')
            
            while True:
                try:
                    choice = int(input(f"[PRIVATE] Enter your choice (1-{len(targets)}): ").strip())
                    if 1 <= choice <= len(targets):
                        target = targets[choice - 1]
                        break
                    else:
                        print_colored(f"[PRIVATE] Please enter a number between 1 and {len(targets)}.", 'PRIVATE')
                except ValueError:
                    print_colored(f"[PRIVATE] Please enter a valid number.", 'PRIVATE')
        else:
            # LLM player - use LLM to make choice
            prompt = format_player_prompt(gs, player, "target_selection")
            effective_role_name = get_effective_role_name(player)
            prompt.append({
                "role": "system",
                "content": f"You are the {effective_role_name}. Each night*, if no-one died today, choose a player: they die. No one died today, so you must kill someone. Available targets: {', '.join(f'{t.name} (Seat {t.seat})' for t in targets)}"
            })
            prompt.append({
                "role": "system",
                "content": "IMPORTANT: You are the Demon. You should generally avoid targeting your own teammates (other evil players). Focus on eliminating good players to help your team win."
            })
            
            llm_response = call_gpt(prompt, label=f"Zombuul targeting (Seat {player.seat})")
            target_name = parse_llm_response(llm_response, "targeting", options=[t.name for t in targets], player=player)
            
            # Find the target
            target = next((t for t in targets if t.name.lower() == target_name.lower()), None)
            if not target:
                # Fallback to random choice if LLM fails
                target = random.choice(targets)
        
        # Kill the target
        attempt_kill_player(gs, target, "Zombuul")
        gs.memory["killed_by_demon"] = target
        
        gs.log_secret(f"Zombuul â†’ {player.label()} kills {target.label()} because no one died today.")
        gs.log_action_end("zombuul_ability", f"Killed {target.label()}", player)
    else:
        gs.log_secret(f"Zombuul {player.label()} does not kill because someone died today.")
        gs.log_action_end("zombuul_ability", "Someone died today, no kill", player)

def run_pukka_ability(gs: GameState, player: Player):
    """Pukka: Each night, choose a player: they are poisoned. The previously poisoned player dies then becomes healthy."""
    gs.log_action_start("pukka_ability", player)
    
    # Kill the previously poisoned player (if they were poisoned last night)
    previously_poisoned = gs.memory.get("pukka_poisoned_player")
    if previously_poisoned and previously_poisoned.poisoned:
        if previously_poisoned.alive:
            success = attempt_kill_player(gs, previously_poisoned, "Pukka poison")
            if success:
                # Track this death for dawn announcement
                if "night_deaths_this_night" not in gs.memory:
                    gs.memory["night_deaths_this_night"] = []
                gs.memory["night_deaths_this_night"].append(previously_poisoned.seat)
            gs.log_secret(f"Pukka â†’ {player.label()} kills previously poisoned {previously_poisoned.label()} and makes them healthy.")
        else:
            gs.log_secret(f"Pukka â†’ {player.label()} cannot kill previously poisoned {previously_poisoned.label()} (already dead).")
        previously_poisoned.poisoned = False  # Make them healthy
        previously_poisoned.poisoned_turns = 0  # Reset poison counter
    
    # Choose new target to poison
    targets = get_targetable_players(gs, allow_dead=False, exclude_self=player)
    if not targets:
        gs.log_secret(f"Pukka {player.label()} has no valid targets.")
        gs.log_action_end("pukka_ability", "No targets available", player)
        return
    
    # Prompt human player for choice
    if is_human_player(player):
        effective_role_name = get_effective_role_name(player)
        print_colored(f"[PRIVATE] {player.name} (Seat {player.seat}), you are the {effective_role_name}.", 'PRIVATE')
        print_colored(f"[PRIVATE] Each night, choose a player: they are poisoned. The previously poisoned player dies then becomes healthy.", 'PRIVATE')
        print_colored(f"[PRIVATE] Choose a player to poison:", 'PRIVATE')
        
        # Show available targets
        for i, target in enumerate(targets, 1):
            print_colored(f"[PRIVATE] {i}. {target.name} (Seat {target.seat})", 'PRIVATE')
        
        while True:
            try:
                choice = int(input(f"[PRIVATE] Enter your choice (1-{len(targets)}): ").strip())
                if 1 <= choice <= len(targets):
                    target = targets[choice - 1]
                    break
                else:
                    print_colored(f"[PRIVATE] Please enter a number between 1 and {len(targets)}.", 'PRIVATE')
            except ValueError:
                print_colored(f"[PRIVATE] Please enter a valid number.", 'PRIVATE')
    else:
        # LLM player - use LLM to make choice
        prompt = format_player_prompt(gs, player, "target_selection")
        effective_role_name = get_effective_role_name(player)
        prompt.append({
            "role": "system",
            "content": f"You are the {effective_role_name}. Each night, choose a player: they are poisoned. The previously poisoned player dies then becomes healthy. Available targets: {', '.join(f'{t.name} (Seat {t.seat})' for t in targets)}"
        })
        prompt.append({
            "role": "system",
            "content": "IMPORTANT: You are the Demon. You should generally avoid targeting your own teammates (other evil players). Focus on eliminating good players to help your team win."
        })
        
        llm_response = call_gpt(prompt, label=f"Pukka targeting (Seat {player.seat})")
        target_name = parse_llm_response(llm_response, "targeting", options=[t.name for t in targets], player=player)
        
        # Find the target
        target = next((t for t in targets if t.name.lower() == target_name.lower()), None)
        if not target:
            # Fallback to random choice if LLM fails
            target = random.choice(targets)
    
    # Poison the target
    mark_poisoned(target, 1, source="Pukka")
    gs.memory["pukka_poisoned_player"] = target
    
    gs.log_secret(f"Pukka â†’ {player.label()} poisons {target.label()}.")
    gs.log_action_end("pukka_ability", f"Poisoned {target.label()}", player)

def run_shabaloth_ability(gs: GameState, player: Player):
    """Shabaloth: Each night*, choose 2 players: they die. A dead player you chose last night might be regurgitated."""
    gs.log_action_start("shabaloth_ability", player)
    
    # Check for regurgitation first (only if we have targets from last night)
    last_night_targets = gs.memory.get("shabaloth_last_targets", [])
    if last_night_targets:
        # Find dead players from last night's targets who are eligible for regurgitation
        # Only players killed by Shabaloth the previous night can be regurgitated
        dead_targets = []
        for target_seat in last_night_targets:
            target = next((p for p in gs.players if p.seat == target_seat), None)
            if target and not target.alive:
                # Check if this player was killed by Shabaloth the previous night
                # We need to track when they died to ensure it was last night
                # Only night deaths (numeric) are eligible, not day deaths ("day") or game termination ("game_end")
                if ("died_night" in target.hidden_state and 
                    isinstance(target.hidden_state["died_night"], int) and 
                    target.hidden_state["died_night"] == gs.day - 1):
                    dead_targets.append(target_seat)
        
        if dead_targets:
            gs.log_secret(f"Shabaloth {player.label()} has {len(dead_targets)} eligible targets for regurgitation from last night.")
            # 80% chance to regurgitate exactly one of last night's Shabaloth victims
            if random.random() < 0.8: 
                target_seat = random.choice(dead_targets)
                target = next((p for p in gs.players if p.seat == target_seat), None)
                if target:
                    target.alive = True
                    target.death_count = 0
                    # Clear death-related memory since they're no longer dead
                    if "last_alive_day" in target.memory:
                        del target.memory["last_alive_day"]
                    # Clear death night tracking since they're no longer dead from that death
                    if "died_night" in target.hidden_state:
                        del target.hidden_state["died_night"]
                    gs.log_secret(f"Shabaloth â†’ {player.label()} regurgitates {target.label()}.")
                    
                    # Track resurrection for dawn announcement
                    if "resurrections" not in gs.memory:
                        gs.memory["resurrections"] = []
                    gs.memory["resurrections"].append({
                        "player": target.seat,
                        "type": "Shabaloth regurgitation",
                        "night": gs.day
                    })
                    
                    # Remove this target from future regurgitation attempts
                    # (they can't be regurgitated again from the same death)
                    last_night_targets.remove(target_seat)
                    gs.memory["shabaloth_last_targets"] = last_night_targets
                    gs.log_secret(f"Shabaloth regurgitation complete. Remaining targets for future regurgitation: {last_night_targets}")
            else:
                gs.log_secret(f"Shabaloth {player.label()} regurgitation roll failed (80% chance to regurgitate). No regurgitation this night.")
        else:
            gs.log_secret(f"Shabaloth {player.label()} has no eligible targets for regurgitation from last night.")
    
    # Choose 2 new targets
    targets = get_targetable_players(gs, allow_dead=False, exclude_self=player)
    if len(targets) < 2:
        gs.log_secret(f"Shabaloth {player.label()} needs 2 targets but only {len(targets)} available.")
        gs.log_action_end("shabaloth_ability", "Not enough targets", player)
        return
    
    # Prompt human player for choice
    if is_human_player(player):
        effective_role_name = get_effective_role_name(player)
        print_colored(f"[PRIVATE] {player.name} (Seat {player.seat}), you are the {effective_role_name}.", 'PRIVATE')
        print_colored(f"[PRIVATE] Each night*, choose 2 players: they die. A dead player you chose last night might be regurgitated.", 'PRIVATE')
        print_colored(f"[PRIVATE] Choose 2 players to kill:", 'PRIVATE')
        
        # Show available targets
        for i, target in enumerate(targets, 1):
            print_colored(f"[PRIVATE] {i}. {target.name} (Seat {target.seat})", 'PRIVATE')
        
        selected_targets = []
        for choice_num in [1, 2]:
            while True:
                try:
                    choice = int(input(f"[PRIVATE] Enter your {choice_num}{'st' if choice_num == 1 else 'nd'} choice (1-{len(targets)}): ").strip())
                    if 1 <= choice <= len(targets):
                        target = targets[choice - 1]
                        if target not in selected_targets:
                            selected_targets.append(target)
                            break
                        else:
                            print_colored(f"[PRIVATE] You already chose {target.name}. Please choose a different player.", 'PRIVATE')
                    else:
                        print_colored(f"[PRIVATE] Please enter a number between 1 and {len(targets)}.", 'PRIVATE')
                except ValueError:
                    print_colored(f"[PRIVATE] Please enter a valid number.", 'PRIVATE')
    else:
        # LLM player - use LLM to make choice
        prompt = format_player_prompt(gs, player, "target_selection")
        effective_role_name = get_effective_role_name(player)
        prompt.append({
            "role": "system",
            "content": f"You are the {effective_role_name}. Each night*, choose 2 players: they die. A dead player you chose last night might be regurgitated. Available targets: {', '.join(f'{t.name} (Seat {t.seat})' for t in targets)}"
        })
        prompt.append({
            "role": "system",
            "content": "IMPORTANT: You are the Demon. You should generally avoid targeting your own teammates (other evil players). Focus on eliminating good players to help your team win."
        })
        
        llm_response = call_gpt(prompt, label=f"Shabaloth targeting (Seat {player.seat})")
        target_names = parse_llm_response(llm_response, "targeting", options=[t.name for t in targets], player=player)
        
        # Parse LLM response for two targets
        if isinstance(target_names, str):
            # Try to extract two names from the response
            words = target_names.split()
            selected_targets = []
            for word in words:
                if len(selected_targets) >= 2:
                    break
                target = next((t for t in targets if t.name.lower() == word.lower()), None)
                if target and target not in selected_targets:
                    selected_targets.append(target)
        
        if len(selected_targets) < 2:
            # Fallback to random choice if LLM fails
            selected_targets = random.sample(targets, 2)
    
    # Kill both targets
    killed_targets = []
    for target in selected_targets:
        if attempt_kill_player(gs, target, "Shabaloth"):
            killed_targets.append(target)
    
    # Store targets for next night's regurgitation
    gs.memory["shabaloth_last_targets"] = [target.seat for target in selected_targets]
    
    if killed_targets:
        gs.memory["killed_by_demon"] = killed_targets[0]  # Store first killed for night death reporting
    
    gs.log_secret(f"Shabaloth â†’ {player.label()} kills {', '.join(t.label() for t in selected_targets)}.")
    gs.log_action_end("shabaloth_ability", f"Killed {len(killed_targets)} players", player)

def run_po_ability(gs: GameState, player: Player):
    """Po: Each night*, you may choose a player: they die. If your last choice was no-one, choose 3 players tonight."""
    gs.log_action_start("po_ability", player)
    
    # Check if Po is blocked by Exorcist tonight
    if gs.memory.get("demon_blocked_tonight", False):
        gs.log_secret(f"Po {player.label()} is blocked by Exorcist tonight - cannot use ability.")
        gs.log_action_end("po_ability", "Blocked by Exorcist", player)
        return
    
    # Check last night's choice and current night
    last_choice = gs.memory.get("po_last_choice")
    # Po cannot kill 3 people at once on night 2 (second night)
    # They can only kill 3 if their last choice was no-one AND it's not night 2
    # This prevents the exploit of choosing no-one on night 1, then killing 3 on night 2
    must_choose_three = (last_choice is None and gs.day != 2)
    
    targets = get_targetable_players(gs, allow_dead=False, exclude_self=player)
    
    if must_choose_three:
        if len(targets) < 3:
            gs.log_secret(f"Po {player.label()} must choose 3 targets but only {len(targets)} available.")
            gs.log_action_end("po_ability", "Not enough targets for 3 kills", player)
            return
        
        # If it's night 2, override the 3-kill requirement
        if gs.day == 2:
            must_choose_three = False
            gs.log_secret(f"Po {player.label()} would normally choose 3 targets, but night 2 restriction applies.")
        
        # Prompt human player for choice
        if is_human_player(player):
            effective_role_name = get_effective_role_name(player)
            print_colored(f"[PRIVATE] {player.name} (Seat {player.seat}), you are the {effective_role_name}.", 'PRIVATE')
            print_colored(f"[PRIVATE] Each night*, you may choose a player: they die. If your last choice was no-one, choose 3 players tonight.", 'PRIVATE')
            if gs.day == 2:
                print_colored(f"[PRIVATE] Your last choice was no-one, but you cannot kill 3 people on night 2. You must choose 1 player or no-one.", 'PRIVATE')
                print_colored(f"[PRIVATE] Choose 1 player to kill or no-one:", 'PRIVATE')
            else:
                print_colored(f"[PRIVATE] Your last choice was no-one, so you must choose 3 players to kill tonight.", 'PRIVATE')
                print_colored(f"[PRIVATE] Choose 3 players to kill:", 'PRIVATE')
            
            # Show available targets
            for i, target in enumerate(targets, 1):
                print_colored(f"[PRIVATE] {i}. {target.name} (Seat {target.seat})", 'PRIVATE')
            
            selected_targets = []
            if gs.day == 2 and must_choose_three:
                # Night 2 restriction: can only choose 1 or no-one
                print_colored(f"[PRIVATE] Due to night 2 restrictions, you can only choose 1 player or no-one.", 'PRIVATE')
                while True:
                    choice = input(f"[PRIVATE] Enter your choice (1 for a player, 2 for no-one): ").strip()
                    if choice == "1":
                        if not targets:
                            print_colored(f"[PRIVATE] No valid targets available. Choosing no-one.", 'PRIVATE')
                            selected_targets = []
                            break
                        
                        print_colored(f"[PRIVATE] Choose 1 player to kill:", 'PRIVATE')
                        for i, target in enumerate(targets, 1):
                            print_colored(f"[PRIVATE] {i}. {target.name} (Seat {target.seat})", 'PRIVATE')
                        
                        while True:
                            try:
                                target_choice = int(input(f"[PRIVATE] Enter your choice (1-{len(targets)}): ").strip())
                                if 1 <= target_choice <= len(targets):
                                    selected_targets = [targets[target_choice - 1]]
                                    break
                                else:
                                    print_colored(f"[PRIVATE] Please enter a number between 1 and {len(targets)}.", 'PRIVATE')
                            except ValueError:
                                print_colored(f"[PRIVATE] Please enter a valid number.", 'PRIVATE')
                        break
                    elif choice == "2":
                        selected_targets = []
                        break
                    else:
                        print_colored(f"[PRIVATE] Please enter 1 or 2.", 'PRIVATE')
            else:
                # Normal 3-choice logic
                for choice_num in [1, 2, 3]:
                    while True:
                        try:
                            choice = int(input(f"[PRIVATE] Enter your {choice_num}{'st' if choice_num == 1 else 'nd' if choice_num == 2 else 'rd'} choice (1-{len(targets)}): ").strip())
                            if 1 <= choice <= len(targets):
                                target = targets[choice - 1]
                                if target not in selected_targets:
                                    selected_targets.append(target)
                                    break
                                else:
                                    print_colored(f"[PRIVATE] You already chose {target.name}. Please choose a different player.", 'PRIVATE')
                            else:
                                print_colored(f"[PRIVATE] Please enter a number between 1 and {len(targets)}.", 'PRIVATE')
                        except ValueError:
                            print_colored(f"[PRIVATE] Please enter a valid number.", 'PRIVATE')
        else:
            # LLM player - use LLM to make choice
            prompt = format_player_prompt(gs, player, "target_selection")
            effective_role_name = get_effective_role_name(player)
            if gs.day == 2:
                prompt.append({
                    "role": "system",
                    "content": f"You are the {effective_role_name}. Each night*, you may choose a player: they die. If your last choice was no-one, choose 3 players tonight. Your last choice was no-one, but you cannot kill 3 people on night 2. You must choose 1 player or no-one. Available targets: {', '.join(f'{t.name} (Seat {t.seat})' for t in targets)}"
                })
            else:
                prompt.append({
                    "role": "system",
                    "content": f"You are the {effective_role_name}. Each night*, you may choose a player: they die. If your last choice was no-one, choose 3 players tonight. Your last choice was no-one, so you must choose 3 players. Available targets: {', '.join(f'{t.name} (Seat {t.seat})' for t in targets)}"
                })
            prompt.append({
                "role": "system",
                "content": "IMPORTANT: You are the Demon. You should generally avoid targeting your own teammates (other evil players). Focus on eliminating good players to help your team win."
            })
            
            llm_response = call_gpt(prompt, label=f"Po targeting (Seat {player.seat})")
            target_names = parse_llm_response(llm_response, "targeting", options=[t.name for t in targets] + (["no-one"] if gs.day > 1 else []), player=player)
            
            # Parse LLM response for targets
            if isinstance(target_names, str):
                if gs.day == 2 and must_choose_three:
                    # Night 2 restriction: only choose 1 player or no-one
                    if target_names.lower() == "no-one":
                        selected_targets = []
                    else:
                        words = target_names.split()
                        selected_targets = []
                        for word in words:
                            if len(selected_targets) >= 1:
                                break
                            target = next((t for t in targets if t.name.lower() == word.lower()), None)
                            if target and target not in selected_targets:
                                selected_targets.append(target)
                        
                        if len(selected_targets) < 1:
                            # Fallback to random choice if LLM fails
                            selected_targets = random.sample(targets, 1)
                else:
                    # Normal 3-choice logic
                    words = target_names.split()
                    selected_targets = []
                    for word in words:
                        if len(selected_targets) >= 3:
                            break
                        target = next((t for t in targets if t.name.lower() == word.lower()), None)
                        if target and target not in selected_targets:
                            selected_targets.append(target)
                    
                    if len(selected_targets) < 3:
                        # Fallback to random choice if LLM fails
                        selected_targets = random.sample(targets, 3)
        
        # Track the choice for next night
        if must_choose_three:
            # Must choose 3 players (not night 2)
            gs.memory["po_last_choice"] = "three_kills"
        else:
            # Normal choice: track the actual choice
            if len(selected_targets) == 1:
                gs.memory["po_last_choice"] = selected_targets[0].seat
            else:
                gs.memory["po_last_choice"] = None
    else:
        # May choose 1 or no-one
        if is_human_player(player):
            effective_role_name = get_effective_role_name(player)
            print_colored(f"[PRIVATE] {player.name} (Seat {player.seat}), you are the {effective_role_name}.", 'PRIVATE')
            print_colored(f"[PRIVATE] Each night*, you may choose a player: they die. If your last choice was no-one, choose 3 players tonight.", 'PRIVATE')
            print_colored(f"[PRIVATE] You can either:", 'PRIVATE')
            print_colored(f"[PRIVATE] 1. Choose a player to kill", 'PRIVATE')
            print_colored(f"[PRIVATE] 2. Choose no-one", 'PRIVATE')
            
            while True:
                choice = input(f"[PRIVATE] Enter your choice (1 or 2): ").strip()
                if choice == "1":
                    if not targets:
                        print_colored(f"[PRIVATE] No valid targets available. Choosing no-one.", 'PRIVATE')
                        selected_targets = []
                        gs.memory["po_last_choice"] = None
                        break
                    
                    print_colored(f"[PRIVATE] Choose a player to kill:", 'PRIVATE')
                    for i, target in enumerate(targets, 1):
                        print_colored(f"[PRIVATE] {i}. {target.name} (Seat {target.seat})", 'PRIVATE')
                    
                    while True:
                        try:
                            target_choice = int(input(f"[PRIVATE] Enter your choice (1-{len(targets)}): ").strip())
                            if 1 <= target_choice <= len(targets):
                                selected_targets = [targets[target_choice - 1]]
                                gs.memory["po_last_choice"] = selected_targets[0].seat
                                break
                            else:
                                print_colored(f"[PRIVATE] Please enter a number between 1 and {len(targets)}.", 'PRIVATE')
                        except ValueError:
                            print_colored(f"[PRIVATE] Please enter a valid number.", 'PRIVATE')
                    break
                elif choice == "2":
                    selected_targets = []
                    gs.memory["po_last_choice"] = None
                    break
                else:
                    print_colored(f"[PRIVATE] Please enter 1 or 2.", 'PRIVATE')
        else:
            # LLM player - use LLM to make choice
            prompt = format_player_prompt(gs, player, "target_selection")
            effective_role_name = get_effective_role_name(player)
            prompt.append({
                "role": "system",
                "content": f"You are the {effective_role_name}. Each night*, you may choose a player: they die. If your last choice was no-one, choose 3 players tonight. You can choose 1 player or no-one. Available targets: {', '.join(f'{t.name} (Seat {t.seat})' for t in targets)}"
            })
            prompt.append({
                "role": "system",
                "content": "IMPORTANT: You are the Demon. You should generally avoid targeting your own teammates (other evil players). Focus on eliminating good players to help your team win."
            })
            
            llm_response = call_gpt(prompt, label=f"Po targeting (Seat {player.seat})")
            target_name = parse_llm_response(llm_response, "targeting", options=[t.name for t in targets] + ["no-one"], player=player)
            
            if target_name and target_name.lower() != "no-one":
                # Find the target
                target = next((t for t in targets if t.name.lower() == target_name.lower()), None)
                if target:
                    selected_targets = [target]
                    gs.memory["po_last_choice"] = target.seat
                else:
                    selected_targets = []
                    gs.memory["po_last_choice"] = None
            else:
                selected_targets = []
                gs.memory["po_last_choice"] = None
    
    # Kill selected targets
    killed_targets = []
    for target in selected_targets:
        if attempt_kill_player(gs, target, "Po"):
            killed_targets.append(target)
    
    if killed_targets:
        gs.memory["killed_by_demon"] = killed_targets[0]  # Store first killed for night death reporting
    
    if selected_targets:
        gs.log_secret(f"Po â†’ {player.label()} kills {', '.join(t.label() for t in selected_targets)}.")
    else:
        gs.log_secret(f"Po â†’ {player.label()} chooses no-one.")
    
    gs.log_action_end("po_ability", f"Killed {len(killed_targets)} players", player)

# Day Action System
def run_day_actions(gs: GameState):
    """Run day action abilities (Moonchild only - Gossip is now handled during day discussion)."""
    gs.log_secret(f"-- Day {gs.day} Actions --")
    
    # Moonchild ability (if they learned they died and haven't used it yet)
    moonchildren = [p for p in gs.players if p.role.name == "Moonchild" and not p.alive]
    for moonchild in moonchildren:
        if ("moonchild_learned_death" in moonchild.memory and 
            "moonchild_ability_used" not in moonchild.memory):
            moonchild_ability(gs, moonchild)

def get_moonchild_choice(gs: GameState, player: Player, alive_players):
    """Helper function to get Moonchild choice (common for both normal and drunk)"""
    if is_human_player(player):
        effective_role_name = get_effective_role_name(player)
        print_colored(f"[PRIVATE] {player.name} (Seat {player.seat}), you are the {effective_role_name}.", 'PRIVATE')
        print_colored(f"[PRIVATE] You learned that you died! You MUST publicly choose 1 alive player. Tonight, if it was a good player, they die.", 'PRIVATE')
        print_colored(f"[PRIVATE] Choose a player to target:", 'PRIVATE')
        
        # Show available targets
        for i, target in enumerate(alive_players, 1):
            print_colored(f"[PRIVATE] {i}. {target.name} (Seat {target.seat})", 'PRIVATE')
        
        # Give them multiple attempts to make a valid choice
        max_attempts = 3
        for attempt in range(max_attempts):
            try:
                choice = int(input(f"[PRIVATE] Enter your choice (1-{len(alive_players)}) [Attempt {attempt + 1}/{max_attempts}]: ").strip())
                if 1 <= choice <= len(alive_players):
                    target = alive_players[choice - 1]
                    break
                else:
                    print_colored(f"[PRIVATE] Please enter a number between 1 and {len(alive_players)}.", 'PRIVATE')
            except ValueError:
                print_colored(f"[PRIVATE] Please enter a valid number.", 'PRIVATE')
        else:
            # If they failed to make a valid choice, choose randomly and make it public
            target = random.choice(alive_players)
            gs.log_public(f"{player.name} (Seat {player.seat}) failed to make a valid choice, so a random player was chosen.")
            gs.log_secret(f"Moonchild {player.label()} failed to make valid choice after {max_attempts} attempts, chose {target.label()} randomly.")
    else:
        # LLM player - use LLM to make choice
        prompt = format_player_prompt(gs, player, "target_selection")
        effective_role_name = get_effective_role_name(player)
        prompt.append({
            "role": "system",
            "content": f"You are the {effective_role_name}. You learned that you died! You MUST publicly choose 1 alive player. Tonight, if it was a good player, they die. Available targets: {', '.join(f'{t.name} (Seat {t.seat})' for t in alive_players)}"
        })
        
        llm_response = call_gpt(prompt, label=f"Moonchild targeting (Seat {player.seat})")
        target_name = parse_llm_response(llm_response, "targeting", options=[t.name for t in alive_players], player=player)
        
        # Find the target
        target = next((t for t in alive_players if t.name.lower() == target_name.lower()), None)
        if not target:
            # Fallback to random choice if LLM fails
            target = random.choice(alive_players)
            gs.log_secret(f"Moonchild {player.label()} LLM failed to make valid choice, chose {target.label()} randomly.")
    
    return {"target": target}

def moonchild_ability(gs: GameState, player: Player): # Unfortunately, I have not figured out how to implement a way to bluff as the Moonchild, since the public choice and whatnot is announced only if the player is actually a moonchild. Plausibly this could be handled by allowing a death message, where every player says something whenever they die, but I do not want to implement this because it seems inefficient and tricky.
    """When you learn that you died, publicly choose 1 alive player. Tonight, if it was a good player, they die."""
    gs.log_action_start("moonchild_ability", player)
    
    def normal_fn():
        # Choose a random alive player
        alive_players = [p for p in gs.players if p.alive and p != player]
        if not alive_players:
            gs.log_secret(f"Moonchild {player.label()} has no valid targets.")
            return None
        
        # Get player choice (common logic for both normal and drunk)
        choice_result = get_moonchild_choice(gs, player, alive_players)
        if choice_result is None:
            return None
        
        target = choice_result["target"]
        
        # Store the choice
        player.memory["moonchild_target"] = {"target": target.seat, "day": gs.day}
        
        # Mark that the Moonchild ability has been used
        player.memory["moonchild_ability_used"] = True
        
        msg = f"You publicly choose {target.name} (Seat {target.seat})."
        if is_human_player(player):
            print_colored(f"[PRIVATE] {player.name} (Seat {player.seat}) is told: {msg}", 'PRIVATE')
        gs.log_secret(f"[PRIVATE] {player.label()} is told: {msg}")
        
        # Announce the choice publicly
        gs.log_public(f"{player.name} (Seat {player.seat}) publicly chooses {target.name} (Seat {target.seat}).")
        
        return {"target": target.seat, "target_alignment": target.role.alignment}
    
    def drunk_fn():
        # Drunk Moonchild thinks their ability works but it actually doesn't, and they are not told anything different.
        # They should be able to choose targets as normal, but their ability has no effect
        alive_players = [p for p in gs.players if p.alive and p != player]
        if not alive_players:
            return None
        
        # Get player choice (common logic for both normal and drunk)
        choice_result = get_moonchild_choice(gs, player, alive_players)
        if choice_result is None:
            return None
        
        target = choice_result["target"]
        
        # Drunk Moonchild's ability has no effect, but they think it does
        # They are not told that their ability failed
        gs.log_secret(f"Drunk Moonchild {player.label()} targets {target.label()}, but their ability has no effect (they are drunk/poisoned).")
        
        # Store the choice (even though it had no effect)
        player.memory["moonchild_target"] = {"target": target.seat, "day": gs.day}
        
        # Mark that the Moonchild ability has been used (even though it had no effect)
        player.memory["moonchild_ability_used"] = True
        
        # Create message for player (they think their ability worked)
        msg = f"You publicly choose {target.name} (Seat {target.seat})."
        
        if is_human_player(player):
            print_colored(f"[PRIVATE] {player.name} (Seat {player.seat}) is told: {msg}", 'PRIVATE')
        
        # Announce the choice publicly (even though it had no effect)
        gs.log_public(f"{player.name} (Seat {player.seat}) publicly chooses {target.name} (Seat {target.seat}).")
        
        return {"target": target.seat, "target_alignment": target.role.alignment}
    
    result = resolve_ability(player, normal_fn, drunk_fn)
    if result:
        gs.log_action_end("moonchild_ability", f"Chose seat {result['target']}", player)
    else:
        gs.log_action_end("moonchild_ability", "No target chosen", player)

# Complex Character Abilities
def goon_ability(gs: GameState, player: Player):
    """Each night, the 1st player to choose you with their ability is drunk until dusk. You become their alignment."""
    # This is a passive ability that triggers when other players target the Goon
    pass

def handle_goon_targeting(gs: GameState, targeting_player: Player, target: Player):
    """Handle when a player targets the Goon with their ability."""
    if target.role.name == "Goon" and target.alive:
        # Check if this is the first targeting of the night
        if "goon_targeted_tonight" not in target.memory:
            # Make the targeting player drunk until dusk
            mark_drunk(targeting_player, gs.day + 1)
            gs.log_secret(f"Goon {target.label()} makes {targeting_player.label()} drunk until dusk.")
            
            # Change Goon's alignment to match the targeting player
            original_alignment = target.role.alignment
            target.role.alignment = targeting_player.role.alignment
            gs.log_secret(f"Goon {target.label()} changes alignment from {original_alignment.value} to {target.role.alignment.value}.")
            
            # Mark that Goon has been targeted tonight
            target.memory["goon_targeted_tonight"] = True
            target.memory["goon_alignment_change"] = {
                "from": original_alignment.value,
                "to": target.role.alignment.value,
                "by": targeting_player.seat,
                "night": gs.day
            }

def clear_goon_targeting(gs: GameState):
    """Clear Goon targeting flags at the start of each night."""
    for player in gs.players:
        if "goon_targeted_tonight" in player.memory:
            del player.memory["goon_targeted_tonight"]

def evaluate_gossip_statement(gs: GameState, statement: str) -> bool:
    """Evaluate whether a Gossip statement is true using LLM."""
    # Create a comprehensive game state summary for the LLM
    game_summary = []
    
    # Add basic game info
    game_summary.append(f"Current day: {gs.day}")
    game_summary.append(f"Total players: {len(gs.players)}")
    
    # Add player status and roles (what would be publicly known)
    alive_players = [p for p in gs.players if p.alive]
    dead_players = [p for p in gs.players if not p.alive]
    
    game_summary.append(f"Alive players ({len(alive_players)}): {', '.join(f'{p.name} (Seat {p.seat})' for p in alive_players)}")
    if dead_players:
        game_summary.append(f"Dead players ({len(dead_players)}): {', '.join(f'{p.name} (Seat {p.seat})' for p in dead_players)}")
    
    # Add recent public events
    recent_events = []
    for entry in gs.public_log[-20:]:  # Last 20 public events
        if any(keyword in entry['msg'] for keyword in ['killed', 'executed', 'died', 'dawn', 'discuss', 'nomination', 'vote']):
            recent_events.append(entry['msg'])
    
    if recent_events:
        game_summary.append("Recent events:")
        game_summary.extend(f"- {event}" for event in recent_events[-10:])  # Last 10 relevant events
    
    # Create the evaluation prompt
    evaluation_prompt = [
        {
            "role": "system",
            "content": """You are evaluating a statement made by a Gossip character in a game of Blood on the Clocktower. 
The Gossip's ability is: "Each day, you may make a public statement. Tonight, if it was true, a player dies."

Your task is to determine if the given statement is TRUE or FALSE based on the current game state.
You may consider private information that only you as the storyteller know.

IMPORTANT EVALUATION RULES:
1. Be very strict in your evaluation - only mark as TRUE if the statement is definitively correct based on the game state
2. Consider player deaths, executions, nominations, votes, and public announcements
3. If the statement is ambiguous or could be interpreted multiple ways, default to FALSE
4. Only factual statements about game events can be TRUE

Examples:
- "Someone died last night" = TRUE if someone died last night
- "Player X is the Demon" = TRUE if that player is the Demon
- "The demon is either a Shabaloth or a Pukka" = TRUE if the demon is either a Shabaloth or a Pukka.
- "Player X is the Professor" = TRUE if that player is the Professor.

Respond with only 'TRUE' or 'FALSE'."""
        },
        {
            "role": "user", 
            "content": f"""Game State:
{chr(10).join(game_summary)}

Statement to evaluate: "{statement}"

Is this statement TRUE or FALSE based on the game state?"""
        }
    ]
    
    # Get LLM evaluation
    llm_response = call_gpt(evaluation_prompt, label=f"Gossip statement evaluation: '{statement}'")
    
    # Parse the response
    response_clean = llm_response.strip().upper()
    if "TRUE" in response_clean:
        return True
    elif "FALSE" in response_clean:
        return False
    else:
        # Fallback: default to false if LLM response is unclear
        gs.log_secret(f"Gossip evaluation unclear response: '{llm_response}', defaulting to FALSE")
        return False

def lunatic_ability(gs: GameState, player: Player):
    """You think you are a Demon, but you are not. The Demon knows who you are & who you choose at night."""
    # This is handled by making the Lunatic think they're a Demon
    # The Demon will be informed about the Lunatic during setup
    pass



def handle_lunatic_night_action(gs: GameState, player: Player):
    """Handle the Lunatic's night action (they think they're killing someone)."""
    if player.role.name != "Lunatic":
        return
    
    # Get the fake demon type the Lunatic thinks they are
    fake_demon_type = player.hidden_state.get("lunatic_demon_info", {}).get("fake_demon_type", "Imp")
    
    # Mirror the appropriate demon ability based on what the Lunatic thinks they are
    if fake_demon_type == "Imp":
        # Lunatic thinks they're the Imp - mirror Imp ability
        run_lunatic_imp_ability(gs, player)
    elif fake_demon_type == "Zombuul":
        # Lunatic thinks they're the Zombuul - mirror Zombuul ability
        run_lunatic_zombuul_ability(gs, player)
    elif fake_demon_type == "Pukka":
        # Lunatic thinks they're the Pukka - mirror Pukka ability
        run_lunatic_pukka_ability(gs, player)
    elif fake_demon_type == "Shabaloth":
        # Lunatic thinks they're the Shabaloth - mirror Shabaloth ability
        run_lunatic_shabaloth_ability(gs, player)
    elif fake_demon_type == "Po":
        # Lunatic thinks they're the Po - mirror Po ability
        run_lunatic_po_ability(gs, player)
    else:
        # Fallback to Imp behavior
        run_lunatic_imp_ability(gs, player)

def run_lunatic_imp_ability(gs: GameState, player: Player):
    """Lunatic thinks they're the Imp - mirror Imp ability."""
    gs.log_action_start("lunatic_imp_ability", player)
    
    # Imp kills on all regular nights (Night 1+)
    if gs.day == 0:  # First night
        gs.log_secret(f"Lunatic {player.label()} thinks they are the Imp but it's the first night - no kill.")
        return
    
    # Get targets (same as real Imp)
    targets = get_targetable_players(gs, allow_dead=False, exclude_self=player)
    if not targets:
        gs.log_secret(f"Lunatic {player.label()} thinks they are the Imp but has no valid targets.")
        return
    
    # For now, random selection (can be enhanced with LLM later)
    target = random.choice(targets)
    
    # Store the Lunatic's "kill" choice
    player.memory["kill_choice"] = {"target": target.seat, "night": gs.day}
    
    # Inform the real Demon about the Lunatic's choice
    demon = next((p for p in gs.players if p.role.alignment == Alignment.DEMON), None)
    if demon:
        demon.memory["lunatic_choice"] = {"target": target.seat, "night": gs.day}
        gs.log_secret(f"Demon {demon.label()} learns Lunatic {player.label()} chose to 'kill' {target.label()}.")
    
    # The Lunatic thinks they killed someone, but nothing actually happens
    msg = f"You choose to kill {target.name} (Seat {target.seat})."
    if is_human_player(player):
        print_colored(f"[PRIVATE] {player.name} (Seat {player.seat}) is told: {msg}", 'PRIVATE')
    gs.log_secret(f"[PRIVATE] {player.label()} is told: {msg}")
    
    gs.log_action_end("lunatic_imp_ability", f"Chose to 'kill' {target.label()}", player)

def run_lunatic_zombuul_ability(gs: GameState, player: Player):
    """Lunatic thinks they're the Zombuul - mirror Zombuul ability."""
    gs.log_action_start("lunatic_zombuul_ability", player)
    
    # Zombuul kills on all regular nights (Night 1+)
    if gs.day == 0:  # First night
        gs.log_secret(f"Lunatic {player.label()} thinks they are the Zombuul but it's the first night - no kill.")
        return
    
    # Check if anyone died today (including executions and other day deaths)
    # Lunatic Zombuul wakes if no one died during the day
    someone_died_today = (
        not gs.memory.get("no_execution_today", True) or  # There was an execution
        gs.memory.get("executed_today") is not None or     # Someone was executed
        gs.memory.get("killed_by_demon") is not None or    # Demon killed someone
        gs.memory.get("day_deaths", [])                    # Any other day deaths
    )
    
    if someone_died_today:
        gs.log_secret(f"Lunatic {player.label()} thinks they are the Zombuul but someone died today - no kill.")
        return
    
    # Get targets
    targets = get_targetable_players(gs, allow_dead=False, exclude_self=player)
    if not targets:
        gs.log_secret(f"Lunatic {player.label()} thinks they are the Zombuul but has no valid targets.")
        return
    
    # For now, random selection
    target = random.choice(targets)
    
    # Store the Lunatic's "kill" choice
    player.memory["kill_choice"] = {"target": target.seat, "night": gs.day}
    
    # Inform the real Demon about the Lunatic's choice
    demon = next((p for p in gs.players if p.role.alignment == Alignment.DEMON), None)
    if demon:
        demon.memory["lunatic_choice"] = {"target": target.seat, "night": gs.day}
        gs.log_secret(f"Demon {demon.label()} learns Lunatic {player.label()} chose to 'kill' {target.label()}.")
    
    # The Lunatic thinks they killed someone, but nothing actually happens
    msg = f"You choose to kill {target.name} (Seat {target.seat})."
    if is_human_player(player):
        print_colored(f"[PRIVATE] {player.name} (Seat {player.seat}) is told: {msg}", 'PRIVATE')
    gs.log_secret(f"[PRIVATE] {player.label()} is told: {msg}")
    
    gs.log_action_end("lunatic_zombuul_ability", f"Chose to 'kill' {target.label()}", player)

def run_lunatic_pukka_ability(gs: GameState, player: Player):
    """Lunatic thinks they're the Pukka - mirror Pukka ability."""
    gs.log_action_start("lunatic_pukka_ability", player)
    
    # Pukka kills on all regular nights (Night 1+)
    if gs.day == 0:  # First night
        gs.log_secret(f"Lunatic {player.label()} thinks they are the Pukka but it's the first night - no kill.")
        return
    
    # Get targets
    targets = get_targetable_players(gs, allow_dead=False, exclude_self=player)
    if not targets:
        gs.log_secret(f"Lunatic {player.label()} thinks they are the Pukka but has no valid targets.")
        return
    
    # For now, random selection
    target = random.choice(targets)
    
    # Store the Lunatic's "kill" choice
    player.memory["kill_choice"] = {"target": target.seat, "night": gs.day}
    
    # Inform the real Demon about the Lunatic's choice
    demon = next((p for p in gs.players if p.role.alignment == Alignment.DEMON), None)
    if demon:
        demon.memory["lunatic_choice"] = {"target": target.seat, "night": gs.day}
        gs.log_secret(f"Demon {demon.label()} learns Lunatic {player.label()} chose to 'kill' {target.label()}.")
    
    # The Lunatic thinks they killed someone, but nothing actually happens
    msg = f"You choose to kill {target.name} (Seat {target.seat})."
    if is_human_player(player):
        print_colored(f"[PRIVATE] {player.name} (Seat {player.seat}) is told: {msg}", 'PRIVATE')
    gs.log_secret(f"[PRIVATE] {player.label()} is told: {msg}")
    
    gs.log_action_end("lunatic_pukka_ability", f"Chose to 'kill' {target.label()}", player)

def run_lunatic_shabaloth_ability(gs: GameState, player: Player):
    """Lunatic thinks they're the Shabaloth - mirror Shabaloth ability."""
    gs.log_action_start("lunatic_shabaloth_ability", player)
    
    # Shabaloth kills on all regular nights (Night 1+)
    if gs.day == 0:  # First night
        gs.log_secret(f"Lunatic {player.label()} thinks they are the Shabaloth but it's the first night - no kill.")
        return
    
    # Get targets
    targets = get_targetable_players(gs, allow_dead=False, exclude_self=player)
    if not targets:
        gs.log_secret(f"Lunatic {player.label()} thinks they are the Shabaloth but has no valid targets.")
        return
    
    # For now, random selection (Shabaloth would normally choose 2, but Lunatic just chooses 1)
    target = random.choice(targets)
    
    # Store the Lunatic's "kill" choice
    player.memory["kill_choice"] = {"target": target.seat, "night": gs.day}
    
    # Inform the real Demon about the Lunatic's choice
    demon = next((p for p in gs.players if p.role.alignment == Alignment.DEMON), None)
    if demon:
        demon.memory["lunatic_choice"] = {"target": target.seat, "night": gs.day}
        gs.log_secret(f"Demon {demon.label()} learns Lunatic {player.label()} chose to 'kill' {target.label()}.")
    
    # The Lunatic thinks they killed someone, but nothing actually happens
    msg = f"You choose to kill {target.name} (Seat {target.seat})."
    if is_human_player(player):
        print_colored(f"[PRIVATE] {player.name} (Seat {player.seat}) is told: {msg}", 'PRIVATE')
    gs.log_secret(f"[PRIVATE] {player.label()} is told: {msg}")
    
    gs.log_action_end("lunatic_shabaloth_ability", f"Chose to 'kill' {target.label()}", player)

def run_lunatic_po_ability(gs: GameState, player: Player):
    """Lunatic thinks they're the Po - mirror Po ability."""
    gs.log_action_start("lunatic_po_ability", player)
    
    # Po kills on all regular nights (Night 1+)
    if gs.day == 0:  # First night
        gs.log_secret(f"Lunatic {player.label()} thinks they are the Po but it's the first night - no kill.")
        return
    
    # Get targets
    targets = get_targetable_players(gs, allow_dead=False, exclude_self=player)
    if not targets:
        gs.log_secret(f"Lunatic {player.label()} thinks they are the Po but has no valid targets.")
        return
    
    # For now, random selection
    target = random.choice(targets)
    
    # Store the Lunatic's "kill" choice
    player.memory["kill_choice"] = {"target": target.seat, "night": gs.day}
    
    # Inform the real Demon about the Lunatic's choice
    demon = next((p for p in gs.players if p.role.alignment == Alignment.DEMON), None)
    if demon:
        demon.memory["lunatic_choice"] = {"target": target.seat, "night": gs.day}
        gs.log_secret(f"Demon {demon.label()} learns Lunatic {player.label()} chose to 'kill' {target.label()}.")
    
    # The Lunatic thinks they killed someone, but nothing actually happens
    msg = f"You choose to kill {target.name} (Seat {target.seat})."
    if is_human_player(player):
        print_colored(f"[PRIVATE] {player.name} (Seat {player.seat}) is told: {msg}", 'PRIVATE')
    gs.log_secret(f"[PRIVATE] {player.label()} is told: {msg}")
    
    gs.log_action_end("lunatic_po_ability", f"Chose to 'kill' {target.label()}", player)

# ... existing code ...

if __name__ == "__main__":
    # --- Prompt for default setup option ---
    print("=== BLOOD ON THE CLOCKTOWER ===")
    print("\nQuick Setup Options:")
    print("1. Default Setup (Recommended)")
    print("   - Debug logging: OFF")
    print("   - Full LLM mode: ON")
    print("   - Human player: ON (random seat)")
    print("   - Test mode: OFF")
    print("   - Fast voting: ON")
    print("2. Custom Setup")
    
    setup_choice = input("Choose setup option (1-2): ").strip()
    
    if setup_choice == "1":
        # Default setup
        DEBUG_ALL_LOGS = False
        USE_LLM = True
        TEST_MODE = False
        FAST_LLM_VOTING = True
        
        print("\n=== Using Default Setup ===")
        
        # Character set selection
        print("\nAvailable character sets:")
        print("1. Trouble Brewing (Original)")
        print("2. Bad Moon Rising (Expansion)")
        print("3. Both (Mixed)")
        
        while True:
            try:
                character_set = int(input("Select character set (1-3): ").strip())
                if 1 <= character_set <= 3:
                    break
                else:
                    print("Please enter 1, 2, or 3.")
            except ValueError:
                print("Please enter a valid number.")
        
        while True:
            try:
                player_count = int(input("Enter number of players (5-15): ").strip())
                if 5 <= player_count <= 15:
                    break
                else:
                    print("Player count must be between 5 and 15.")
            except ValueError:
                print("Please enter a valid number.")

        # Alphabetical names (Alpha, Bravo, Charlie, ...)
        default_names = [
            "Alpha", "Bravo", "Charlie", "Delta", "Echo", "Foxtrot", "Golf", "Hotel", "India", "Juliet",
            "Kilo", "Lima", "Mike", "November", "Oscar"
        ]
        names = default_names[:player_count]
        print(f"\nPlayers: {', '.join(names)}")

        # --- NEW: Prompt for print statistics option ---
        stats_input = input("Enable prompt/usage statistics printing? (y/n): ").strip().lower()
        print_statistics = stats_input.startswith("y")

        # Random human seat
        human_seat = random.randint(0, player_count-1)
        print(f"Randomly assigned to seat {human_seat}")

        gs = setup_game(names, character_set, print_statistics)
        
        # Initialize PER_SEAT_IS_HUMAN after gs is created (0-indexed)
        PER_SEAT_IS_HUMAN = [False] * len(gs.players)
        PER_SEAT_IS_HUMAN[human_seat] = True
        
        # Initialize PER_SEAT_USE_LLM (all seats use LLM except human seat)
        PER_SEAT_USE_LLM = [True] * len(gs.players)
        PER_SEAT_USE_LLM[human_seat] = False
        
        # Set up special role information (Lunatic thinking they're a demon, etc.) before showing role info
        demon_minion_info(gs)
        
        print_colored(f"You are playing as {gs.players[human_seat].name} (Seat {human_seat})", 'STORYTELLER')
        
        # Print human player's role and ability at the start
        human_player = gs.players[human_seat]
        effective_role, effective_ability, _ = get_effective_role(human_player)
        print_colored(f"You are {human_player.name} (Seat {human_seat}), the {effective_role}. Ability: {effective_ability}", 'PROMPT')
        
        # Show role distribution information to human player
        base_town, base_outsider, base_minion, base_demon = get_base_role_distribution(len(gs.players))
        print_colored(f"Base role distribution for {len(gs.players)} players (excluding any Baron/Capo Crimini modifications):", 'PROMPT')
        print_colored(f"- Townsfolk: {base_town}", 'PROMPT')
        print_colored(f"- Outsiders: {base_outsider}", 'PROMPT')
        print_colored(f"- Minions: {base_minion}", 'PROMPT')
        print_colored(f"- Demons: {base_demon}", 'PROMPT')
        print_colored("Note: The actual distribution may differ due to Baron, Capo Crimini, or other character effects.", 'PROMPT')
        
        # If the human is a demon, tell them their bluffs and minions
        if human_player.role.alignment is Alignment.DEMON:
            if "bluffs" in human_player.memory:
                bluffs = human_player.memory["bluffs"]
                print_colored(f"[PRIVATE] As the {human_player.role.name}, your three bluff roles are: {', '.join(bluffs)}", 'PRIVATE')
                gs.log_secret(f"[PRIVATE] {human_player.label()} ({human_player.role.name}) is told their bluffs: {', '.join(bluffs)}")
            # Tell the demon who the minions are
            minions = [p for p in gs.players if p.role.alignment is Alignment.MINION]
            if minions:
                minion_str = ', '.join(f"{p.name} (Seat {p.seat})" for p in minions)
                print_colored(f"[PRIVATE] As the {human_player.role.name}, your minions are: {minion_str}", 'PRIVATE')
                gs.log_secret(f"[PRIVATE] {human_player.label()} ({human_player.role.name}) is told their minions: {minion_str}")
        # If the human is a minion, tell them who the Demon is
        if human_player.role.alignment is Alignment.MINION:
            demon = next((p for p in gs.players if p.role.alignment is Alignment.DEMON), None)
            if demon:
                print_colored(f"[PRIVATE] As a minion, the Demon is {demon.name} (Seat {demon.seat})", 'PRIVATE')
                gs.log_secret(f"[PRIVATE] {human_player.label()} (Minion) is told the Demon: {demon.name} (Seat {demon.seat})")
        
        print_colored(f"LLM MODE: USE_LLM={USE_LLM}, TEST_MODE={TEST_MODE}, PER_SEAT_USE_LLM={PER_SEAT_USE_LLM}, PER_SEAT_IS_HUMAN={PER_SEAT_IS_HUMAN}, FAST_LLM_VOTING={FAST_LLM_VOTING}", 'STORYTELLER')
        
    else:
        # Custom setup
        # --- Prompt for debug logging at the very start ---
        debug_input = input("Enable DEBUG/VERBOSE LOGGING MODE (all logs, LLM prompts, etc)? (y/n): ").strip().lower()
        DEBUG_ALL_LOGS = debug_input.startswith("y")
        
        # Character set selection
        print("\nAvailable character sets:")
        print("1. Trouble Brewing (Original)")
        print("2. Bad Moon Rising (Expansion)")
        print("3. Both (Mixed)")
        
        while True:
            try:
                character_set = int(input("Select character set (1-3): ").strip())
                if 1 <= character_set <= 3:
                    break
                else:
                    print("Please enter 1, 2, or 3.")
            except ValueError:
                print("Please enter a valid number.")
        
        while True:
            try:
                player_count = int(input("Enter number of players (5-15): ").strip())
                if 5 <= player_count <= 15:
                    break
                else:
                    print("Player count must be between 5 and 15.")
            except ValueError:
                print("Please enter a valid number.")

        # Alphabetical names (Alpha, Bravo, Charlie, ...)
        default_names = [
            "Alpha", "Bravo", "Charlie", "Delta", "Echo", "Foxtrot", "Golf", "Hotel", "India", "Juliet",
            "Kilo", "Lima", "Mike", "November", "Oscar"
        ]
        names = default_names[:player_count]
        print(f"\nPlayers: {', '.join(names)}")

        # --- NEW: Prompt for FULL LLM MODE ---
        llm_input = input("Enable FULL LLM MODE (all seats use LLM)? (y/n): ").strip().lower()
        USE_LLM = llm_input.startswith("y")

        # --- NEW: Prompt for Human Play ---
        human_input = input("Do you want to play as a human? (y/n): ").strip().lower()
        if human_input.startswith("y"):
            while True:
                try:
                    seat = int(input(f"Which seat (0-{player_count-1}) do you want to play as? "))
                    if 0 <= seat <= player_count-1:
                        human_seat = seat  # Use 0-indexed for PER_SEAT_IS_HUMAN
                        break
                    else:
                        print(f"Enter a number between 0 and {player_count-1}.")
                except ValueError:
                    print("Please enter a valid number.")
        else:
            human_seat = None

        # --- NEW: Prompt for print statistics option ---
        stats_input = input("Enable prompt/usage statistics printing? (y/n): ").strip().lower()
        print_statistics = stats_input.startswith("y")

        gs = setup_game(names, character_set, print_statistics)
        
        # Initialize PER_SEAT_IS_HUMAN after gs is created (0-indexed)
        if human_seat is not None:
            PER_SEAT_IS_HUMAN = [i == human_seat for i in range(len(gs.players))]  # 0-indexed list
        else:
            PER_SEAT_IS_HUMAN = [False for _ in range(len(gs.players))]  # 0-indexed list
        print(f"\nGame setup complete with {len(gs.players)} players.")
        # print(f"Role distribution: {[p.role.name for p in gs.players]}")  # REMOVED: Do not reveal roles to human
        
        # Set up special role information (Lunatic thinking they're a demon, etc.) before showing role info
        if any(PER_SEAT_IS_HUMAN):
            demon_minion_info(gs)
        
        # TEST MODE: ask if enabled, and which seat
        test_input = input("Enable TEST MODE (one LLM seat, others random)? (y/n): ").strip().lower()
        if test_input.startswith("y"):
            TEST_MODE = True
            while True:
                try:
                    seat = int(input(f"Which seat (0-{len(gs.players)-1}) should be LLM-driven? "))
                    if 0 <= seat <= len(gs.players)-1:
                        LLM_SEAT = seat  # Use 0-indexed for PER_SEAT_USE_LLM
                        break
                    else:
                        print(f"Enter a number between 0 and {len(gs.players)-1}.")
                except ValueError:
                    print("Please enter a valid number.")
            PER_SEAT_USE_LLM = [i == LLM_SEAT for i in range(len(gs.players))]  # 0-indexed list
            print(f"TEST MODE: Only {gs.players[LLM_SEAT].name} (Seat {LLM_SEAT}) will use LLM. Others random.")
        else:
            TEST_MODE = False
            PER_SEAT_USE_LLM = [USE_LLM for _ in range(len(gs.players))]  # 0-indexed list
            if not USE_LLM and not any(PER_SEAT_IS_HUMAN):
                print_colored("WARNING: Neither FULL LLM MODE, TEST MODE, nor human play is enabled. All actions will be random.", 'ERROR')
        
        # --- NEW: Prompt for FAST LLM VOTING ---
        fast_voting_input = input("Enable FAST LLM VOTING (LLMs vote on all nominations at once)? (y/n): ").strip().lower()
        FAST_LLM_VOTING = fast_voting_input.startswith("y")

        print_colored(f"LLM MODE: USE_LLM={USE_LLM}, TEST_MODE={TEST_MODE}, PER_SEAT_USE_LLM={PER_SEAT_USE_LLM}, PER_SEAT_IS_HUMAN={PER_SEAT_IS_HUMAN}, FAST_LLM_VOTING={FAST_LLM_VOTING}", 'STORYTELLER')
    
    # Run the game with storyteller controls
    def run_game_with_storyteller(gs: GameState):
        print_colored("\n=== GAME STARTED ===", 'STORYTELLER')
        gs.log_phase_start("game_start")
        
        # Only print 'You are now the Storyteller.' if no human seat is set
        if not any(PER_SEAT_IS_HUMAN):
            print_colored("You are now the Storyteller.", 'STORYTELLER')
        gs.phase = Phase.FIRST_NIGHT  # Ensure phase is initialized
        
        while gs.phase != Phase.END:
            if gs.phase == Phase.FIRST_NIGHT:
                print_colored("\n--- FIRST NIGHT ---", 'STORYTELLER')
                gs.log_phase_start("first_night")
                run_first_night(gs)
                
                # Now that first night is complete, display human player's role and ability
                if any(PER_SEAT_IS_HUMAN):
                    human_seat = next(i for i, is_human in enumerate(PER_SEAT_IS_HUMAN) if is_human)
                    human_player = gs.players[human_seat]
                    effective_role, effective_ability, _ = get_effective_role(human_player)
                    print_colored(f"You are {human_player.name} (Seat {human_seat}), the {effective_role}. Ability: {effective_ability}", 'PROMPT')
                    
                    # Show role distribution information to human player
                    base_town, base_outsider, base_minion, base_demon = get_base_role_distribution(len(gs.players))
                    print_colored(f"Base role distribution for {len(gs.players)} players (excluding any Baron/Capo Crimini modifications):", 'PROMPT')
                    print_colored(f"- Townsfolk: {base_town}", 'PROMPT')
                    print_colored(f"- Outsiders: {base_outsider}", 'PROMPT')
                    print_colored(f"- Minions: {base_minion}", 'PROMPT')
                    print_colored(f"- Demons: {base_demon}", 'PROMPT')
                    print_colored("Note: The actual distribution may differ due to Baron, Capo Crimini, or other character effects.", 'PROMPT')
                    
                    # If the human is a demon, tell them their bluffs and minions
                    if human_player.role.alignment is Alignment.DEMON:
                        if "bluffs" in human_player.memory:
                            bluffs = human_player.memory["bluffs"]
                            print_colored(f"[PRIVATE] As the {human_player.role.name}, your three bluff roles are: {', '.join(bluffs)}", 'PRIVATE')
                            gs.log_secret(f"[PRIVATE] {human_player.label()} ({human_player.role.name}) is told their bluffs: {', '.join(bluffs)}")
                        # Tell the demon who the minions are
                        minions = [p for p in gs.players if p.role.alignment is Alignment.MINION]
                        if minions:
                            minion_str = ', '.join(f"{p.name} (Seat {p.seat})" for p in minions)
                            print_colored(f"[PRIVATE] As the {human_player.role.name}, your minions are: {minion_str}", 'PRIVATE')
                            gs.log_secret(f"[PRIVATE] {human_player.label()} ({human_player.role.name}) is told their minions: {minion_str}")
                    # If the human is a minion, tell them who the Demon is
                    if human_player.role.alignment is Alignment.MINION:
                        demon = next((p for p in gs.players if p.role.alignment is Alignment.DEMON), None)
                        if demon:
                            print_colored(f"[PRIVATE] As a minion, the Demon is {demon.name} (Seat {demon.seat})", 'PRIVATE')
                            gs.log_secret(f"[PRIVATE] {human_player.label()} (Minion) is told the Demon: {demon.name} (Seat {demon.seat})")
                
                gs.log_phase_end("first_night")
                gs.phase = Phase.DAY_DISCUSSION
            elif gs.phase == Phase.NIGHT:
                # Check win condition before starting night
                if check_win_condition(gs):
                    gs.phase = Phase.END
                    continue
                print_colored(f"\n--- NIGHT {gs.day} ---", 'STORYTELLER')
                gs.log_phase_start(f"night_{gs.day}")
                run_night(gs)
                gs.log_phase_end(f"night_{gs.day}")
                gs.phase = Phase.DAY_DISCUSSION
                gs.set_phase_tick(f"Day {gs.day}")  # LLM: Set phase tick for logging
            elif gs.phase == Phase.DAY_DISCUSSION:
                # Check win condition before starting day discussion
                if check_win_condition(gs):
                    gs.phase = Phase.END
                    continue
                print_colored(f"\n--- DAY {gs.day} DISCUSSION ---", 'PUBLIC')
                gs.log_phase_start(f"day_{gs.day}_discussion")
                try:
                    run_day_discussion(gs)
                except GameEndException:
                    # Game was terminated early, immediately end the game by killing evil players
                    gs.log_secret("Game terminated early by player - killing all evil players to end game")
                    for player in gs.players:
                        if player.role.alignment in {Alignment.MINION, Alignment.DEMON} and player.alive:
                            player.alive = False
                            player.death_count += 1
                            player.hidden_state["died_night"] = "game_end"  # Track that they died due to game termination
                            gs.log_secret(f"Killed {player.label()} to end game early")
                    gs.phase = Phase.END
                    break
                gs.log_phase_end(f"day_{gs.day}_discussion")
                gs.phase = Phase.NOMINATIONS
                gs.set_phase_tick(f"Nominations {gs.day}")  # LLM: Set phase tick for logging
            elif gs.phase == Phase.NOMINATIONS:
                # Check win condition before starting nominations
                if check_win_condition(gs):
                    gs.phase = Phase.END
                    continue
                print_colored(f"\n--- DAY {gs.day} NOMINATIONS ---", 'PUBLIC')
                gs.log_phase_start(f"day_{gs.day}_nominations")
                try:
                    run_nominations(gs)
                except GameEndException:
                    # Game was terminated early, immediately end the game by killing evil players
                    gs.log_secret("Game terminated early by player - killing all evil players to end game")
                    for player in gs.players:
                        if player.role.alignment in {Alignment.MINION, Alignment.DEMON} and player.alive:
                            player.alive = False
                            player.death_count += 1
                            player.hidden_state["died_night"] = "game_end"  # Track that they died due to game termination
                            gs.log_secret(f"Killed {player.label()} to end game early")
                    gs.phase = Phase.END
                    break
                gs.log_phase_end(f"day_{gs.day}_nominations")
                gs.phase = Phase.VOTING
                gs.set_phase_tick(f"Voting {gs.day}")  # LLM: Set phase tick for logging
            elif gs.phase == Phase.VOTING:
                # Check win condition before starting voting
                if check_win_condition(gs):
                    gs.phase = Phase.END
                    continue
                print_colored(f"\n--- DAY {gs.day} VOTING ---", 'PUBLIC')
                gs.log_phase_start(f"day_{gs.day}_voting")
                run_voting(gs)
                gs.log_phase_end(f"day_{gs.day}_voting")
                gs.phase = Phase.EXECUTION
                gs.set_phase_tick(f"Execution {gs.day}")  # LLM: Set phase tick for logging
            elif gs.phase == Phase.EXECUTION:
                # Check win condition before starting execution
                if check_win_condition(gs):
                    gs.phase = Phase.END
                    continue
                print_colored(f"\n--- DAY {gs.day} EXECUTION ---", 'PUBLIC')
                gs.log_phase_start(f"day_{gs.day}_execution")
                run_execution(gs)
                gs.log_phase_end(f"day_{gs.day}_execution")
                # Check win condition after execution, but don't override if phase is already END
                if gs.phase != Phase.END and check_win_condition(gs):
                    gs.phase = Phase.END
                elif gs.phase != Phase.END:
                    gs.phase = Phase.NIGHT
        
        gs.log_phase_start("game_end")
        print_colored("\n=== GAME OVER ===", 'STORYTELLER')
        print_colored("Final Game State:", 'STORYTELLER')
        print(get_game_snapshot(gs))
        print_colored("\nStoryteller log:", 'STORYTELLER')
        for log in gs.storyteller_log:
            print_colored(log, 'STORYTELLER')
        print_colored("\nPublic log:", 'PUBLIC')
        for log in gs.public_log:
            print_colored(log['msg'], 'PUBLIC')
        
        # Print LLM input statistics
        print_llm_input_stats()
        
        save_logs_to_xml(gs)
        gs.log_phase_end("game_end")

    run_game_with_storyteller(gs) 
